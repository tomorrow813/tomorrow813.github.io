<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="java进阶之路">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>java进阶之路</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">java进阶之路</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle-o" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Movies</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Books</span>
        </a>
      </li>
      
      <li>
        <a href="/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Galleries</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">java进阶之路</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle-o"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>Movies</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Books</span>
                  </a>
                </li>
              
                <li>

                  <a href="/galleries " style="margin-left:75px">
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>Galleries</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-11-29
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-11-29
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    11.9k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1.Spring概述"></a>1.Spring概述</h1><h2 id="1-1：什么是spring"><a href="#1-1：什么是spring" class="headerlink" title="1-1：什么是spring?"></a>1-1：什么是spring?</h2><p>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。<br>Spring使你能够编写更干净、更可管理、并且更易于测试的代码。</p>
<h2 id="1-2：Spring的优缺点是什么？"><a href="#1-2：Spring的优缺点是什么？" class="headerlink" title="1-2：Spring的优缺点是什么？"></a>1-2：Spring的优缺点是什么？</h2><p><code>优点：</code><br>   整个 Spring 优势，传达出⼀个信号，Spring 是⼀个综合性，且有很强的思想性框架，每学习⼀ 天，就能体会到它的⼀些优势。</p>
<h3>⽅便解耦，简化开发</h3>
通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进⾏控制，避免硬编码所造成的 过度程序耦合。⽤户也不必再为单例模式类、属性⽂件解析等这些很底层的需求编写代码，可以更 专注于上层的应⽤。
<h3>AOP编程的⽀持</h3>
通过Spring的AOP功能，⽅便进⾏⾯向切⾯的编程，许多不容易⽤传统OOP实现的功能可以通过 AOP轻松应付。
<h3>声明式事务的⽀持</h3>
@Transactional
可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式⽅式灵活的进⾏事务的管理，提⾼ 开发效率和质量。
<h3>⽅便程序的测试</h3>
可以⽤⾮容器依赖的编程⽅式进⾏⼏乎所有的测试⼯作，测试不再是昂贵的操作，⽽是随⼿可做的 事情。

<h3>⽅便集成各种优秀框架</h3>
Spring可以降低各种框架的使⽤难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、 Quartz等）的直接⽀持。

<h3>降低JavaEE API的使⽤难度</h3>
Spring对JavaEE API（如JDBC、JavaMail、远程调⽤等）进⾏了薄薄的封装层，使这些API的使⽤ 难度⼤为降低。
<h3>源码是经典的 Java 学习范例</h3>
Spring的源代码设计精妙、结构清晰、匠⼼独⽤，处处体现着⼤师对Java设计模式灵活运⽤以及对 Java技术的⾼深造诣。它的源代码⽆意是Java技术的最佳实践的范例。

<p><code>缺点</code><br>   使用了大量的反射机制，反射机制非常占用内存。</p>
<h2 id="1-3：Spring-有哪些配置方式"><a href="#1-3：Spring-有哪些配置方式" class="headerlink" title="1-3：Spring 有哪些配置方式"></a>1-3：Spring 有哪些配置方式</h2><p><code>1、XML 配置文件。</code></p>
<p>Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。<br>这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。<br>它们通常以 bean 标签开头。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;
    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;
&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>2、注解配置。</code></p>
<p>可以通过在相关的类，方法或字段声明上使用注解，<br>将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。<br>默认情况下，Spring 容器中未打开注解装配。<br>因此，需要在使用它之前在 Spring 配置文件中启用它。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;beans&gt;
&lt;context:annotation-config&#x2F;&gt;
&lt;!-- bean definitions go here --&gt;
&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>3、Java Config 配置。</code></p>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<br>@Bean 注解扮演与 <bean /> 元素相同的角色。<br>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 Bean 间依赖关系。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class StudentConfig &#123;
    
    @Bean
    public StudentBean myStudent() &#123;
        return new StudentBean();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="2-Spring用到的设计模式有哪些"><a href="#2-Spring用到的设计模式有哪些" class="headerlink" title="2.Spring用到的设计模式有哪些"></a>2.Spring用到的设计模式有哪些</h1><ol>
<li>工厂模式:通过 BeanFactory 或 ApplicationContext 创建 bean 对象。</li>
<li>单例模式:Bean默认为单例模式。<br> xml : <bean id="userService" class="top.snailclimb.UserService" scope="singleton"/><br> 注解：@Scope(value = “singleton”)</li>
<li>代理模式:Spring 的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术;</li>
<li>模板模式:<br>Spring 中 jdbcTemplate、hibernateTemplate 等<br>以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。<br>一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，<br>而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</li>
<li>观察者模式:<br>Spring 事件驱动模型就是观察者模式，<br>比如我们每次添加商品的时候都需要重新更新商品索引，<br>这个时候就可以利用观察者模式来解决这个问题。</li>
<li>适配器模式<ul>
<li>在SpringAOP和SpringMVC中都有适配器模式<br>虽然Spring AOP 的实现是基于代理模式，<br>但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，<br>比如说Spring预定义要通过对应的适配器，<br>适配成 MethodInterceptor接口(方法拦截器)类型的对象<br>如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice</li>
</ul>
</li>
</ol>
<ul>
<li>spring MVC中的适配器模式<br>在Spring MVC中，DispatcherServlet根据请求信息<br>调用HandlerMapping，<br>解析请求对应的Handler。<br>解析到对应的 Handler,也就是我们平常说的 Controller 控制器后，<br>开始由HandlerAdapter 适配器处理。<br>HandlerAdapter 作为期望接口，<br>具体的适配器实现类用于对目标类进行适配，<br>Controller 作为需要适配的类。<br>因为Spring MVC 中的 Controller 种类众多，<br>不同类型的 Controller 通过不同的方法来对请求进行处理。<br>如果不利用适配器模式的话，<br>DispatcherServlet 直接获取对应类型的 Controller，<br>需要的自行来判断</li>
</ul>
<ol start="7">
<li>装饰者模式<br>当我们需要修改原有的功能，<br>但我们又不愿直接去修改原有的代码时，<br>设计一个Decorator套在原有代码外面<br>Spring 中配置 DataSource 的时候，<br>DataSource 可能是不同的数据库和数据源。<br>我们能否根据客户的需求在少<br>修改原有类的代码下动态切换不同的数据源<br>这个时候就要用到装饰者模式。<br>Spring 中用到的包装器模式<br>在类名上含有 Wrapper或者 Decorator。<br>这些类基本上都是动态地给一个对象添加一些额外的职责</li>
</ol>
<h1 id="3-循环依赖"><a href="#3-循环依赖" class="headerlink" title="3. 循环依赖"></a>3. 循环依赖</h1><h2 id="3-1：什么是Spring的循环依赖"><a href="#3-1：什么是Spring的循环依赖" class="headerlink" title="3-1：什么是Spring的循环依赖"></a>3-1：什么是Spring的循环依赖</h2><p>就是有一个 A 对象，创建 A 的时候发现 A 对象依赖 B，<br>然后去创建 B 对象的时候，又发现 B 对象依赖 C，<br>然后去创建 C 对象的时候，又发现 C 对象依赖 A。</p>
<h2 id="3-2：什么是三级缓存"><a href="#3-2：什么是三级缓存" class="headerlink" title="3-2：什么是三级缓存"></a>3-2：什么是三级缓存</h2><ol>
<li>第一级缓存：单例缓存池 singletonObjects。</li>
<li>第二级缓存：早期提前暴露的对象缓存 earlySingletonObjects。</li>
<li>第三级缓存：singletonFactories 单例对象工厂缓存</li>
</ol>
<p>先从一级缓存singletonObjects中去获取，<br>如果获取到 Bean 就直接返回。<br>如果获取不到或者对象正在创建中，<br>那就再从二级缓存earlySingletonObjects中获取，<br>如果获取到就直接返回。<br>如果前两级缓存都没成功返回，<br>且允许 singletonFactories(allowEarlyReference=true)<br>通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。<br>如果获取到了就从singletonFactories中移除，<br>并且放进earlySingletonObjects。<br>其实也就是从三级缓存移动到了二级缓存。是剪切、不是复制。</p>
<h2 id="3-3：什么是早期暴露的对象"><a href="#3-3：什么是早期暴露的对象" class="headerlink" title="3-3：什么是早期暴露的对象"></a>3-3：什么是早期暴露的对象</h2><p>你是一个不完整的对象，你的属性还没有值，<br>你的对象也没有被初始化。这就是早期暴露的对象，<br>只是提前拿出来给你认识认识。但他非常重要。<br>这是多级缓存解决循环依赖问题的一个巧妙的地方。</p>
<h2 id="3-4：如何解决循环依赖"><a href="#3-4：如何解决循环依赖" class="headerlink" title="3-4：如何解决循环依赖"></a>3-4：如何解决循环依赖</h2><p>主要是用三级缓存来解决循环依赖问题</p>
<p>比如说A、B类的互相依赖注入，使用属性field注入循环依赖来解决</p>
<ol>
<li>使用context.getBean(A.class)，<br>旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，<br>显然初次获取A是不存在的，因此走A的创建之路~</li>
<li>实例化A（注意此处仅仅是实例化），<br>并将它放进缓存（此时A已经实例化完成，已经可以被引用了）</li>
<li>初始化A：@Autowired依赖注入B（此时需要去容器内获取B）</li>
<li>为了完成依赖注入B，会通过getBean(B)去容器内找B。<br>但此时B在容器内不存在，就走向B的创建之路~</li>
<li>实例化B，并将其放入缓存。（此时B也能够被引用了）</li>
<li>初始化B，@Autowired依赖注入A（此时需要去容器内获取A）</li>
<li>此处重要：初始化B时会调用getBean(A)去容器内找到A，<br>因为A已经实例化完成了并且放进了缓存里，<br>所以这个时候去看缓存里是已经存在A的引用了的，<br>所以getBean(A)能够正常返回</li>
<li>B初始化成功（此时已经注入A成功了，已成功持有A的引用了），<br>return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中</li>
<li> 因为B实例已经成功返回了，因此最终A也初始化成功</li>
<li>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，</li>
</ol>
<h1 id="4-IOC"><a href="#4-IOC" class="headerlink" title="4.IOC"></a>4.IOC</h1><h2 id="4-1：IOC原理"><a href="#4-1：IOC原理" class="headerlink" title="4-1：IOC原理"></a>4-1：IOC原理</h2><p>ioc也叫控制反转，是一种设计思想。<br>就是将对象的创建和管理交由spring管理。<br>ioc容器本质上是一个map，存放着各种bean对象，<br>key是bean对象名，value是bean配置信息。<br>bean对象的创建、依赖关系都交由ioc容器完成，<br>使用时不需要关心bean对象什么时候创建<br>也不需要手动维护对象间的关系。<br>ioc容器相当于一个第三方的容器，<br>关联着使用资源的双方。<br>比如一个user类和userinfo类，<br>user类要使用userinfo类的属性，<br>需要调用时创建user类和userinfo类的的对象，<br>然后进行属性注入。<br>但是如果将user和userinfo都交由ioc容器管理，<br>调用时只需要从ioc容器中取出user对象，<br>那么user对象需要的userinfo属性会在ioc容器中进行注入，<br>取出的user对象是已经完成依赖注入的对象。</p>
<h3 id="4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）"><a href="#4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）" class="headerlink" title="4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）"></a>4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）</h3><p>首先初始化上下文，<br>生成ClassPathXmlApplicationContext对象，<br>在获取resourcePatternResolver对象将xml解析成Resource对象。<br>利用生成的 context、resource 初始化工厂，<br>并将 resource 解析成 beandefinition,<br>再将 beandefinition 注册到 beanfactory 中。</p>
<h3 id="4-1-2：IOC好处"><a href="#4-1-2：IOC好处" class="headerlink" title="4-1-2：IOC好处"></a>4-1-2：IOC好处</h3><p>它将最小化应用程序中的代码量。<br>它以最小的影响和最少的侵入机制促进松耦合。<br>它支持即时的实例化和延迟加载 Bean 对象。<br>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</p>
<h2 id="4-2：IOC的实现机制（继续扩产—芋头）"><a href="#4-2：IOC的实现机制（继续扩产—芋头）" class="headerlink" title="4-2：IOC的实现机制（继续扩产—芋头）"></a>4-2：IOC的实现机制（继续扩产—芋头）</h2><p>Spring 中的 IoC 的实现原理，就是工厂模式加反射机制</p>
<p>a. 加载配置文件，解析成 BeanDefinition 放在 Map 里。<br>b. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，<br>   拿出 Class 对象进行实例化，同时，如果有依赖关系，<br>   将递归调用 getBean 方法 —— 完成依赖注入。</p>
<h2 id="4-2：IOC容器种类"><a href="#4-2：IOC容器种类" class="headerlink" title="4-2：IOC容器种类"></a>4-2：IOC容器种类</h2><p>一共是两种</p>
<h3 id="4-2-1：BeanFactory与ApplicationContext区别"><a href="#4-2-1：BeanFactory与ApplicationContext区别" class="headerlink" title="4-2-1：BeanFactory与ApplicationContext区别"></a>4-2-1：BeanFactory与ApplicationContext区别</h3><p>ApplicationContext和BeanFactory是Spring的两大核心接口。<br>都可以当做Spring的容器<br>其中ApplicationContext是 BeanFactory的子接口。<br>(1）BeanFactory:是Spring里面最底层的接口，包含了各种Bean的定义，读取bean<br>配置文档，管理 bean 的加载、实例化，控制 bean的生命周期，维护 bean之间的依赖关系。<br>ApplicationContext 接口作为 BeanFactory的派生，除了提供BeanFactory所具有的功能外，<br>还提供了更完整的框架功能:继承MessageSource，因此支持国际化。统一的资源文件访问<br>方式。提供在监听器中注册bean的事件。同时加载多个配置文件。载入多个(有继承关系）<br>上下文，使得每个上下文都专注于一个特定的层次，比如应用web层<br>(2）BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时<br>(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring<br>的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用<br>getBean方法才会抛出异常。<br>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动<br>时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注<br>入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当<br>你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的 BeanFactory，<br>ApplicationContext唯一的不足是占用内存空间。当应用程序配置Bean较多时，<br>程序启动较慢。<br>(3)BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，<br>如使用 ContextLoader。<br>（4） BeanFactory和 ApplicationContext 都支持 BeanPostProcessor、<br>BeanFactoryPostProcessor的使用，但两者之间的区别是: BeanFactory需要手动注册，而<br>ApplicationContext则是自动注册。</p>
<h4 id="4-2-1-1：请介绍下常用的-BeanFactory-容器？"><a href="#4-2-1-1：请介绍下常用的-BeanFactory-容器？" class="headerlink" title="4-2-1-1：请介绍下常用的 BeanFactory 容器？"></a>4-2-1-1：请介绍下常用的 BeanFactory 容器？</h4><p>BeanFactory 最常用的是 XmlBeanFactory 。<br>它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p>
<h4 id="4-2-1-2：请介绍下常用的-ApplicationContext-容器？"><a href="#4-2-1-2：请介绍下常用的-ApplicationContext-容器？" class="headerlink" title="4-2-1-2：请介绍下常用的 ApplicationContext 容器？"></a>4-2-1-2：请介绍下常用的 ApplicationContext 容器？</h4><p>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，<br>                                    并生成上下文定义。应用程序上下文从程序环境变量中取得。<br>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。示<br>3、XmlWebApplicationContext ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</p>
<p>第四种 ApplicationContext 容器，ConfigServletWebServerApplicationContext 。</p>
<h3 id="4-2-2：BeanFactory和FactoryBean的区别（51期）"><a href="#4-2-2：BeanFactory和FactoryBean的区别（51期）" class="headerlink" title="4-2-2：BeanFactory和FactoryBean的区别（51期）"></a>4-2-2：BeanFactory和FactoryBean的区别（51期）</h3><p>BeanFactory是个Factory，也就是IOC容器或对象工厂，<br>FactoryBean是个Bean。在Spring中，<br>所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。<br>但对FactoryBean而言，这个Bean不是简单的Bean，<br>而是一个能生产或者修饰对象生成的工厂Bean,<br>它的实现与设计模式中的工厂模式和修饰器模式类似</p>
<h4 id="4-2-2-1：BeanFactory"><a href="#4-2-2-1：BeanFactory" class="headerlink" title="4-2-2-1：BeanFactory"></a>4-2-2-1：BeanFactory</h4><p>以Factory结尾，表示它是一个工厂类(接口)，<br>它负责生产和管理bean的一个工厂。<br>在Spring中，BeanFactory是IOC容器的核心接口，<br>它的职责包括：实例化、定位、配置<br>应用程序中的对象及建立这些对象间的依赖。</p>
<h4 id="4-2-2-2：FactoryBean"><a href="#4-2-2-2：FactoryBean" class="headerlink" title="4-2-2-2：FactoryBean"></a>4-2-2-2：FactoryBean</h4><p>一般情况下，Spring通过反射机制利用<bean><br>的class属性指定实现类实例化Bean，<br>在某些情况下，实例化Bean过程比较复杂，<br>如果按照传统的方式，<br>则需要在<bean>中提供大量的配置信息。<br>配置方式的灵活性是受限的，<br>这时采用编码的方式可能会得到一个简单的方案。</p>
<h2 id="4-3：依赖注入"><a href="#4-3：依赖注入" class="headerlink" title="4-3：依赖注入"></a>4-3：依赖注入</h2><h3 id="4-3-1：依赖注入概念"><a href="#4-3-1：依赖注入概念" class="headerlink" title="4-3-1：依赖注入概念"></a>4-3-1：依赖注入概念</h3><p>在依赖注入中，不必主动、手动创建对象，但必须描述如何创建它们。<br>不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。<br>然后，再由 IoC 容器将它们装配在一起。</p>
<h3 id="4-3-2：有哪些不同类型的IOC（依赖注入）方式？"><a href="#4-3-2：有哪些不同类型的IOC（依赖注入）方式？" class="headerlink" title="4-3-2：有哪些不同类型的IOC（依赖注入）方式？"></a>4-3-2：有哪些不同类型的IOC（依赖注入）方式？</h3><p><code>构造器依赖注入</code>： 构造器依赖注入通过容器触发一个类的构造器来实现的，<br>                  该类有一系列参数，每个参数代表一个对其他类的依赖。<br><code>Setter方法注入</code>： Setter方法注入是容器通过调用无参构造器或无参static工厂<br>                  方法实例化bean之后，调用该bean的setter方法，<br>                  即实现了基于setter的依赖注入。<br><code>接口注入</code>：       定义接口</p>
<h4 id="4-3-2-1：三种方式的区别小结"><a href="#4-3-2-1：三种方式的区别小结" class="headerlink" title="4-3-2-1：三种方式的区别小结"></a>4-3-2-1：三种方式的区别小结</h4><ol>
<li>基于构造器的注入，会固定依赖注入的顺序；<br>该方式不允许我们创建bean对象之间的循环依赖关系，<br>这种限制其实是一种利用构造器来注入的益处<br>没有注意到使用setter注入的时候，Spring能解决循环依赖的问题；</li>
<li>基于setter的注入，只有当对象是需要被注入的时候它才会帮助我们注入依赖，<br>而不是在初始化的时候就注入；另一方面如果你使用基于constructor注入，<br>CGLIB不能创建一个代理，迫使你使用基于接口的代理或虚拟的无参数构造函数。</li>
<li>使用直接在成员变量上写上注解来注入这种方式<br>看起来非常好，精短，可读性高，不需要多余的代码，也方便维护；</li>
</ol>
<h2 id="4-4：IOC与DI的的区别（修改）"><a href="#4-4：IOC与DI的的区别（修改）" class="headerlink" title="4-4：IOC与DI的的区别（修改）"></a>4-4：IOC与DI的的区别（修改）</h2><p>IOC:  控制反转,将类的对象的创建交给Spring类管理创建.<br>DI:   依赖注入,将类里面的属性在创建类的过程中给属性赋值. </p>
<h2 id="4-5：Spring-框架中有哪些不同类型的事件？"><a href="#4-5：Spring-框架中有哪些不同类型的事件？" class="headerlink" title="4-5：Spring 框架中有哪些不同类型的事件？"></a>4-5：Spring 框架中有哪些不同类型的事件？</h2><ol>
<li>上下文更新事件（ContextRefreshedEvent）：<br>该事件会在ApplicationContext 被初始化或者更新时发布。<br>也可以在调用ConfigurableApplicationContext 接口中的 #refresh() 方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：<br>当容器调用ConfigurableApplicationContext 的 #start()<br>方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：<br>当容器调用 ConfigurableApplicationContext 的<br>#stop() 方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：<br>当ApplicationContext 被关闭时触发该事件。<br>容器被关闭时，其管理的所有单例 Bean 都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：<br>在 We b应用中，当一个HTTP 请求（request）结束触发该事件。</li>
<li>通过扩展 ApplicationEvent 类来开发自定义的事件</li>
</ol>
<h1 id="5-AOP"><a href="#5-AOP" class="headerlink" title="5.AOP"></a>5.AOP</h1><h2 id="5-1：什么是aop"><a href="#5-1：什么是aop" class="headerlink" title="5-1：什么是aop"></a>5-1：什么是aop</h2><p>AOP面向切面编程, 它与OOP我认为是共同作用的，<br>他所提供了与 OOP 不同的抽象软件结构的视角。<br>   在 OOP 中，以类( Class )作为基本单元<br>   在 AOP 中，以切面( Aspect )作为基本单元。<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:<br>   如何通过 PointCut 和 Advice 定位到特定的 JoinPoint 上。<br>   如何在 Advice 中编写切面代码。</p>
<h3 id="5-1-1：什么是-Aspect"><a href="#5-1-1：什么是-Aspect" class="headerlink" title="5-1-1：什么是 Aspect"></a>5-1-1：什么是 Aspect</h3><p>@Aspect 注解的类就是切面<br>Aspect 由 PointCut 和 Advice 组成。<br>   它既包含了横切逻辑的定义，也包括了连接点的定义。<br>   Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</p>
<h3 id="5-1-2：什么是-JoinPoint"><a href="#5-1-2：什么是-JoinPoint" class="headerlink" title="5-1-2：什么是 JoinPoint"></a>5-1-2：什么是 JoinPoint</h3><p>JoinPoint ，切点，程序运行中的一些时间点, 例如：<br>一个方法的执行。<br>或者是一个异常的处理。<br>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p>
<h3 id="5-1-3：什么是-PointCut"><a href="#5-1-3：什么是-PointCut" class="headerlink" title="5-1-3：什么是 PointCut"></a>5-1-3：什么是 PointCut</h3><p>PointCut 是匹配 JoinPoint 的条件。</p>
<p>Advice 是和特定的 PointCut 关联的，<br>并且在 PointCut 相匹配的 JoinPoint 中执行。<br>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，<br>但是我们并不希望在所有的方法上都添加 Advice 。<br>而 PointCut 的作用，就是提供一组规则 来匹配 JoinPoint ，<br>给满足规则的 JoinPoint 添加 Advice 。</p>
<h3 id="5-1-3-4：关于-JoinPoint-和-PointCut-的区别"><a href="#5-1-3-4：关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="5-1-3~4：关于 JoinPoint 和 PointCut 的区别"></a>5-1-3~4：关于 JoinPoint 和 PointCut 的区别</h3><ol>
<li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。<br>而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，<br>通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li>
<li>Advice 是在 JoinPoint 上执行的，<br>而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li>
</ol>
<p>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。<br>然后，Advice 在查询到 JoinPoint 上执行逻辑。</p>
<h3 id="5-1-5：什么是-Advice-？"><a href="#5-1-5：什么是-Advice-？" class="headerlink" title="5-1-5：什么是 Advice ？"></a>5-1-5：什么是 Advice ？</h3><p>通知。<br>比如说特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。<br>Spring AOP 使用一个 Advice 作为拦截器，<br>在 JoinPoint “周围”维护一系列的拦截器。</p>
<h4 id="5-1-5-1：有哪些类型的-Advice？"><a href="#5-1-5-1：有哪些类型的-Advice？" class="headerlink" title="5-1-5-1：有哪些类型的 Advice？"></a>5-1-5-1：有哪些类型的 Advice？</h4><ol>
<li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，<pre><code>     并使用 @Before 注解标记进行配置。</code></pre>
</li>
<li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，<pre><code>              并使用 @AfterReturning 注解标记进行配置。</code></pre>
</li>
<li>After Throwing - 这些类型的 Advice 仅在 JoinPoint <pre><code>             方法通过抛出异常退出并使用 
             @AfterThrowing 注解标记配置时执行。</code></pre>
</li>
<li>After Finally - 这些类型的 Advice 在连接点方法之后执行，<pre><code>            无论方法退出是正常还是异常返回，
            并使用 @After 注解标记进行配置。</code></pre>
</li>
<li>Around - 这些类型的 Advice 在连接点之前和之后执行，<pre><code>     并使用 @Around 注解标记进行配置。</code></pre>
</li>
</ol>
<h3 id="5-1-6：什么是-Target"><a href="#5-1-6：什么是-Target" class="headerlink" title="5-1-6：什么是 Target"></a>5-1-6：什么是 Target</h3><p>Target ，织入 Advice 的目标对象。目标对象也被称为 Advised Object 。</p>
<p>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，<br>因此 Advised Object 总是一个代理对象(Proxied Object) 。<br>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象。<br>Advice + Target Object = Advised Object = Proxy 。</p>
<h3 id="5-1-7：什么是编织（Weaving）"><a href="#5-1-7：什么是编织（Weaving）" class="headerlink" title="5-1-7：什么是编织（Weaving）"></a>5-1-7：什么是编织（Weaving）</h3><p>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，叫做编织。<br>在 Spring AOP 中，编织在运行时执行，即动态代理</p>
<h3 id="5-1-8：AOP中的切面、切点、连接点、通知，四者的关系"><a href="#5-1-8：AOP中的切面、切点、连接点、通知，四者的关系" class="headerlink" title="5-1-8：AOP中的切面、切点、连接点、通知，四者的关系"></a>5-1-8：AOP中的切面、切点、连接点、通知，四者的关系</h3><p>切面，一定要给spring 管理<br>切点，目的是为了将注解写在上面而已<br>pointcut是连接点的集合<br>通知—》配置切点</p>
<h2 id="5-2：aop有哪些实现方式"><a href="#5-2：aop有哪些实现方式" class="headerlink" title="5-2：aop有哪些实现方式"></a>5-2：aop有哪些实现方式</h2><p>实现 AOP 的技术，主要分为两大类：</p>
<ol>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，<pre><code>      从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</code></pre>
例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，<br>  实现类加载时编织时增强，从而实现链路追踪的透明埋点。</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，<pre><code>     因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：
     JDK 动态代理
     CGLIB</code></pre>
</li>
</ol>
<h3 id="5-2-1：Spring-什么时候使用-JDK-动态代理，什么时候使用-CGLIB-呢"><a href="#5-2-1：Spring-什么时候使用-JDK-动态代理，什么时候使用-CGLIB-呢" class="headerlink" title="5-2-1：Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢"></a>5-2-1：Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢</h3><ol>
<li>JDK 动态代理<br>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。<br>JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</li>
<li>CGLIB 动态代理<br>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。<br>当然，Spring 也支持配置，强制使用CGLIB动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，<br>可以在运行时动态的生成某个类的子类，CGLIB 是通过继承的方式做的动态代理，<br>因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的。</li>
</ol>
<h3 id="5-2-2：是编译时期进行织入，还是运行期进行织入"><a href="#5-2-2：是编译时期进行织入，还是运行期进行织入" class="headerlink" title="5-2-2：是编译时期进行织入，还是运行期进行织入"></a>5-2-2：是编译时期进行织入，还是运行期进行织入</h3><p>运行期，生成字节码，再加载到虚拟机中，<br>JDK是利用反射原理，CGLIB使用了ASM原理。</p>
<h3 id="5-2-3：初始化时期织入还是获取对象时织入"><a href="#5-2-3：初始化时期织入还是获取对象时织入" class="headerlink" title="5-2-3：初始化时期织入还是获取对象时织入"></a>5-2-3：初始化时期织入还是获取对象时织入</h3><p>初始化的时候，已经将目标对象进行代理，放入到spring 容器中</p>
<h3 id="5-2-4：spring-AOP-默认使用jdk动态代理还是cglib"><a href="#5-2-4：spring-AOP-默认使用jdk动态代理还是cglib" class="headerlink" title="5-2-4：spring AOP 默认使用jdk动态代理还是cglib"></a>5-2-4：spring AOP 默认使用jdk动态代理还是cglib</h3><p>要看条件，如果实现了接口的类，是使用jdk。<br>如果没实现接口，就使用cglib。</p>
<h3 id="5-2-5：动态代理步骤"><a href="#5-2-5：动态代理步骤" class="headerlink" title="5-2-5：动态代理步骤"></a>5-2-5：动态代理步骤</h3><h4 id="5-2-5-1：JDK动态代理的步骤"><a href="#5-2-5-1：JDK动态代理的步骤" class="headerlink" title="5-2-5-1：JDK动态代理的步骤"></a>5-2-5-1：JDK动态代理的步骤</h4><ol>
<li>先检查委托类是否实现了相应接口，保证被访问方法在接口中也要有定义</li>
<li>创建一个实现InvocationHandler接口的类</li>
<li>在类中定义一个被代理对象的成员属性，为了扩展方便可以直接使用Object类，<br>也可以根据需求定义相应的接口</li>
<li>在invoke方法中实现对委托对象的调用，根据需求对方法进行增强</li>
<li>使用Proxy.newProxyInstance(…)方法创建代理对象，并提供要给获取代理对象的方法</li>
</ol>
<h4 id="5-2-5-2：cglib动态代理实现步骤"><a href="#5-2-5-2：cglib动态代理实现步骤" class="headerlink" title="5-2-5-2：cglib动态代理实现步骤"></a>5-2-5-2：cglib动态代理实现步骤</h4><ol>
<li>创建一个实现MethodInterceptor接口的类</li>
<li>在类中定义一个被代理对象的成员属性，<br>为了扩展方便可以直接使用Object类，也可以根据需求定义相应的接口</li>
<li>在invoke方法中实现对委托对象的调用，根据需求对方法进行增强</li>
<li>使用Enhancer创建生成代理对象，并提供要给获取代理对象的方法</li>
</ol>
<h3 id="5-2-6：jdk动态代理-VS-cglib"><a href="#5-2-6：jdk动态代理-VS-cglib" class="headerlink" title="5-2-6：jdk动态代理 VS cglib"></a>5-2-6：jdk动态代理 VS cglib</h3><h4 id="5-2-6-1：两种代理模式的比较"><a href="#5-2-6-1：两种代理模式的比较" class="headerlink" title="5-2-6-1：两种代理模式的比较"></a>5-2-6-1：两种代理模式的比较</h4><ol>
<li>JDK Proxy 的优势：<ul>
<li>最小化依赖关系，减少依赖意味着简化开发和维护，<br>JDK 本身的支持，可能比 cglib 更加可靠。</li>
<li>平滑进行 JDK 版本升级，<br>而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li>
<li>代码实现简单。</li>
</ul>
</li>
<li>cglib 优势：<ul>
<li>有的时候调用目标可能不便实现额外接口，<br>从某种角度看，限定调用者实现接口是有些侵入性的实践，<br>类似 cglib 动态代理就没有这种限制。</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量。</li>
</ul>
</li>
</ol>
<h4 id="5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？"><a href="#5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？" class="headerlink" title="5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？"></a>5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？</h4><p>JDK有一个限制，就是它只能为接口创建代理实例，<br>而对于没有通过接口定义业务方法的类,需要通过CGLib创建动态代理实例  </p>
<h4 id="5-2-6-3：JDK的动态代理为什么需要接口"><a href="#5-2-6-3：JDK的动态代理为什么需要接口" class="headerlink" title="5-2-6-3：JDK的动态代理为什么需要接口"></a>5-2-6-3：JDK的动态代理为什么需要接口</h4><ol>
<li>在需要继承proxy类获得有关方法和InvocationHandler构造方法传参的同时,<br>java不能同时继承两个类，我们需要和想要代理的类建立联系，只能实现一个接口   </li>
<li>需要反射获得代理类的有关参数，必须要通过某个类，<br>反射获取有关方法，</li>
<li>成功返回的是object类型，要获取原类，<br>只能继承/实现，或者就是那个代理类</li>
<li>对具体实现的方法内部并不关心，<br>这个交给InvocationHandler.invoke那个方法里去处理就好了，<br>我只想根据你给我的接口反射出对我有用的东西。</li>
<li>考虑到设计模式，以及proxy编者编写代码的逻辑</li>
</ol>
<h2 id="5-3：Spring-AOP-and-AspectJ-AOP-有什么区别"><a href="#5-3：Spring-AOP-and-AspectJ-AOP-有什么区别" class="headerlink" title="5-3：Spring AOP and AspectJ AOP 有什么区别"></a>5-3：Spring AOP and AspectJ AOP 有什么区别</h2><ol>
<li>代理方式不同<br>   Spring AOP 基于动态代理方式实现。<br>   AspectJ AOP 基于静态代理方式实现。</li>
<li>PointCut 支持力度不同<br>   Spring AOP 仅支持方法级别的 PointCut 。<br>   AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li>
</ol>
<h2 id="5-4：Spring-如何使用-AOP-切面"><a href="#5-4：Spring-如何使用-AOP-切面" class="headerlink" title="5-4：Spring 如何使用 AOP 切面"></a>5-4：Spring 如何使用 AOP 切面</h2><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p>
<p>基于 XML 方式的切面实现。<br>基于 注解 方式的切面实现。<br>目前，主流喜欢使用 注解 方式。</p>
<h2 id="5-5：aop的应用场景有哪些"><a href="#5-5：aop的应用场景有哪些" class="headerlink" title="5-5：aop的应用场景有哪些"></a>5-5：aop的应用场景有哪些</h2><p>1、日志记录<br>2、权限验证<br>3、效率检查<br>4、事务管理</p>
<h1 id="6-Spring-Bean"><a href="#6-Spring-Bean" class="headerlink" title="6.Spring Bean"></a>6.Spring Bean</h1><h2 id="6-1：什么是SpringBean"><a href="#6-1：什么是SpringBean" class="headerlink" title="6-1：什么是SpringBean"></a>6-1：什么是SpringBean</h2><p>Bean 由 Spring IoC 容器实例化，配置，装配和管理。</p>
<h2 id="6-1：Bean的五种作用域"><a href="#6-1：Bean的五种作用域" class="headerlink" title="6-1：Bean的五种作用域"></a>6-1：Bean的五种作用域</h2><p>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。<br>prototype : 每次请求都会创建一个新的 bean 实例。<br>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。<br>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。<br>global-session： 全局session作用域，<br>                 仅仅在基于portlet的web应用中才有意义，</p>
<h3 id="6-1-2：Spring中的单例bean的线程安全问题了解吗？"><a href="#6-1-2：Spring中的单例bean的线程安全问题了解吗？" class="headerlink" title="6-1-2：Spring中的单例bean的线程安全问题了解吗？"></a>6-1-2：Spring中的单例bean的线程安全问题了解吗？</h3><p>单例 bean 存在线程问题，<br>主要是因为当多个线程操作同一个对象的时候，<br>对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<h4 id="6-1-2-1：常见的有两种解决办法"><a href="#6-1-2-1：常见的有两种解决办法" class="headerlink" title="6-1-2-1：常见的有两种解决办法"></a>6-1-2-1：常见的有两种解决办法</h4><ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义一个ThreadLocal成员变量，<br>将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li>
</ol>
<h2 id="6-2：Bean的生命周期"><a href="#6-2：Bean的生命周期" class="headerlink" title="6-2：Bean的生命周期"></a>6-2：Bean的生命周期</h2><p>（1）实例化（必须的）构造函数构造对象<br>（2）装配（可选的）为属性赋值<br>（3）回调（可选的）（容器-控制类和组件-回调类）<br>（4）初始化(init-method=” “)<br>（5）就绪<br>（6）销毁（destroy-method=” “） </p>
<p>（1）实例化Bean：<br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，<br>或初始化bean的时候需要注入<br>另一个尚未初始化的依赖时，<br>容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，<br>当容器启动结束后，<br>通过获取BeanDefinition对象中的信息，实例化所有的bean。<br>（2）设置对象属性（依赖注入）：<br>实例化后的对象被封装在BeanWrapper对象中，紧接着，<br>Spring根据BeanDefinition中的信息<br>以及通过BeanWrapper提供的设置属性的接口完成依赖注入。<br>（3）处理Aware接口：<br>接着，Spring会检测该对象是否实现了xxxAware接口，<br>并将相关的xxxAware实例注入给Bean：<br>①如果这个Bean已经实现了BeanNameAware接口，<br>会调用它实现的setBeanName(String beanId)方法，<br>此处传递的就是Spring配置文件中Bean的id值；<br>②如果这个Bean已经实现了BeanFactoryAware接口，<br>会调用它实现的setBeanFactory()方法，<br>传递的是Spring工厂自身。<br>③如果这个Bean已经实现了ApplicationContextAware接口，<br>会调用setApplicationContext(ApplicationContext)方法，<br>传入Spring上下文；<br>（4）BeanPostProcessor：<br>如果想对Bean进行一些自定义的处理，<br>那么可以让Bean实现了BeanPostProcessor接口，<br>那将会调用postProcessBeforeInitialization(Object obj, String s)方法。<br>（5）InitializingBean 与 init-method：<br>如果Bean在Spring配置文件中配置了 init-method 属性，<br>则会自动调用其配置的初始化方法。<br>（6）如果这个Bean实现了BeanPostProcessor接口，<br>将会调用postProcessAfterInitialization(Object<br>obj, String s)方法；由于这个方法是在Bean初始化结束时使用的，<br>所以可以被应用于内存或缓存技术；<br>以上几个步骤完成后，Bean就已经被正确创建了，<br>之后就可以使用这个Bean了。<br>（7）DisposableBean：<br>当Bean不再需要时，会经过清理阶段，<br>如果Bean实现了DisposableBean这个接口，会调用其实现的<br>destroy()方法；<br>（8）destroy-method：<br>最后，如果这个Bean的Spring配置中<br>配置了destroy-method属性，<br>会自动调用其配置的销毁方法。<br>方法二：实现org.springframework.beans.factory.DisposableBean接口。<br>执行它的destroy()方法。<br>如果一个Bean实现了org.springframework.beans.factory.DisposableBean接口，<br>则会自动装配</p>
<h2 id="6-3：Spring的Bean注入方式"><a href="#6-3：Spring的Bean注入方式" class="headerlink" title="6-3：Spring的Bean注入方式"></a>6-3：Spring的Bean注入方式</h2><ol>
<li>set方法注入</li>
<li>构造器注入</li>
<li>静态工厂注入</li>
<li>实例工厂注入
 </li>
<li><code>set注入</code><br>如果我们需要使用set注入，那么必须要为属性提供set方法，<br>Spring容器就是通过调用bean的set方法为属性注入值的。<br>而在xml文件中，使用set注入的方式就是通过property标签，</li>
<li><code>构造器注入</code><br>   就是通过调用bean所属类的带参构造器为bean的属性注入值。<br>我们如果需要使用构造器注入，就得为类提供包含参数的构造方法。<br>构造器注入，实际上有多种匹配属性值的方式，比如说<br>（一）匹配构造器的参数名称<br>  我们需要通过constructor-arg标签为构造器传入参数值，<br>每个constructor-arg标签对应直接匹配参数名<br>（二）匹配构造器的参数下标<br>  通过参数在参数列表中的下标进行匹配的方式。<br>通过参数的下标为构造器的参数赋值，<br>参实的下标从0开始。使用第一种方式配置，若赋值的类型与参数的类型不一致，<br>将会在容器初始化bean的时候抛出异常。<br>如果bean存在多个参数数量一样的构造器，<br>Spring容器会自动找到类型匹配的那个进行调用。<br>比如说，Car有如下两个构造器，Spring容器将会调用第二个，<br>因为上面的配置中，index = 1对应的value是double类型，<br>与第二个构造器匹配，而第一个不匹配：<br>（三）匹配构造器的参数类型<br>  直接通过匹配构造器的参数类型，<br>从而选择一个能够完全匹配的构造器，调用这个构造器完成bean的创建和属性注入。<br>类型并不需要按构造器中声明的顺序编写，Spring也能进行匹配。</li>
<li><code>静态工厂注入</code><br>  静态工厂注入就是我们编写一个静态的工厂方法，<br>这个工厂方法会返回一个我们需要的值，然后在配置文件中，<br>我们指定使用这个工厂方法创建bean。首先我们需要一个静态工厂，</li>
<li> <code>实例工厂</code>与静态工厂类似，不同的是，<br>静态工厂调用工厂方法不需要先创建工厂类的对象，<br>因为静态方法可以直接通过类调用，<br>所以在上面的配置文件中，并没有声明工厂类的bean。<br>但是，实例工厂，需要有一个实例对象，才能调用它的工厂方法。</li>
</ol>
<h2 id="6-4：接口与bean"><a href="#6-4：接口与bean" class="headerlink" title="6-4：接口与bean"></a>6-4：接口与bean</h2><h3 id="6-4-1：没有注入接口，使用时怎么能获取的接口"><a href="#6-4-1：没有注入接口，使用时怎么能获取的接口" class="headerlink" title="6-4-1：没有注入接口，使用时怎么能获取的接口"></a>6-4-1：没有注入接口，使用时怎么能获取的接口</h3><p>@Autowired是Spring的注解，Autowired默认先按byType，<br>如果发现找到多个bean，则，又按照byName方式比对，<br>如果还有多个，则报出异常；@Resource<br>默认按照名称(Byname)进行装配, 如果没有指定name属性，<br>当注解写在字段上时，默认取字段名，按照名称查找，<br>如果注解写在setter方法上默认取属性名进行装配。<br>当找不到与名称匹配的bean时才按照类型进行装配。<br>如果name属性一旦指定，就只会按照名称进行装配。<br>对于Controller获取实例的过程，使用@Autowired，<br>程序在spring的容器中查找类型是TestService的bean，<br>刚好找到有且只有一个此类型的bean，即testServiceImpl，<br>所以就把testServiceImpl自动装配到了controller<br>的实例testService中，testService其实就是TestServiceImpl实现类；<br>如果使用的是@Resource，<br>则是先在容器中查找名字为testService的bean，<br>但并没有找到，因为容器中的bean名字是TestServiceImpl<br>如果@Service没指定bean的value属性，<br>则注入bean的名字就是类名，如果指定了则是指定的名字，<br>然后再通过类型查找TestService类型的bean，<br>找到唯一的了个TestService类型bean（即TestServiceImpl），<br>所以就自动装配实例成功了。</p>
<h3 id="6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？"><a href="#6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？" class="headerlink" title="6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？"></a>6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？</h3><p>1、 通过指定bean的名字来明确到底要实例哪一个类<br>2、 通过在实现类上添加@Primary注解来指定默认加载类</p>
<h3 id="6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？"><a href="#6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？" class="headerlink" title="6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？"></a>6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？</h3><p>1、 直接获取实现类serviceImpl的bean也是可以的；<br>2、 至于加一层接口的原因：一是AOP程序设置思想指导，<br>    给别人调用的接口，调用者只想知道方法和功能，<br>    而对于这个方法内部逻辑怎么实现的并不关心；<br>    二是可以降低各个模块间的关联，<br>    实现松耦合、程序分层、高扩展性，使程序更加灵活，<br>    他除了在规范上有卓越贡献外，最精髓的是在多态上的运用；<br>    继承只能单一继承，接口却可以多实现<br>3、 当业务逻辑简单，变更较少，项目自用时，<br>    省略掉接口直接使用实现类更简单明了；反之则推荐使用接口;</p>
<h2 id="6-5：什么是-Spring-的内部-bean？"><a href="#6-5：什么是-Spring-的内部-bean？" class="headerlink" title="6-5：什么是 Spring 的内部 bean？"></a>6-5：什么是 Spring 的内部 bean？</h2><p>只有将 Bean 仅用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。</p>
<p>为了定义Bean，Spring 提供基于 XML 的配置元数据在<br><property>或 <constructor-arg> 中提供了 <bean>元素的使用。<br>内部 Bean 总是匿名的，并且它们总是作为原型 Prototype 。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。<br>这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;!-- bean.xml --&gt;

&lt;bean id&#x3D;“StudentBean&quot; class&#x3D;&quot;com.edureka.Student&quot;&gt;
    &lt;property name&#x3D;&quot;person&quot;&gt;
        &lt;!--This is inner bean --&gt;
        &lt;bean class&#x3D;&quot;com.edureka.Person&quot;&gt;
            &lt;property name&#x3D;&quot;name&quot; value&#x3D;“Scott&quot;&gt;&lt;&#x2F;property&gt;
            &lt;property name&#x3D;&quot;address&quot; value&#x3D;“Bangalore&quot;&gt;&lt;&#x2F;property&gt;
        &lt;&#x2F;bean&gt;
    &lt;&#x2F;property&gt;
&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h1 id="7-Spring事务"><a href="#7-Spring事务" class="headerlink" title="7.Spring事务"></a>7.Spring事务</h1><h2 id="7-1：spring事务种类"><a href="#7-1：spring事务种类" class="headerlink" title="7-1：spring事务种类"></a>7-1：spring事务种类</h2><p>spring支持编程式事务管理和声明式事务管理两种方式<br>①编程式事务管理使用TransactionTemplate.<br>②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，<br>将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完<br>目标方法之后根据执行情况提交或者回滚事务。</p>
<h3 id="7-1-1：-Transactional原理"><a href="#7-1-1：-Transactional原理" class="headerlink" title="7-1-1：@Transactional原理"></a>7-1-1：@Transactional原理</h3><p>@Transactional 的工作机制是基于 AOP 实现的，<br>AOP 又是使用动态代理实现的。如果目标对象实现了接口，<br>默认情况下会采用 JDK 的动态代理，<br>如果目标对象没有实现了接口,会使用 CGLIB 动态代理。<br>通过createAopProxy() 方法决定了是使用 JDK 还是 Cglib 来做动态代理<br>如果一个类或者一个类中的 public 方法上<br>被标注@Transactional 注解的话，<br>Spring 容器就会在启动的时候为其创建一个代理类，<br>在调用被@Transactional 注解的 public 方法的时候，<br>实际调用的是，TransactionInterceptor 类中的 invoke()方法。<br>这个方法的作用就是在目标方法之前开启事务方法<br>执行过程中如果遇到异常的时候回滚事务，<br>方法调用完成之后提交事务。</p>
<h4 id="7-1-1-1：注解使用详解"><a href="#7-1-1-1：注解使用详解" class="headerlink" title="7-1-1-1：注解使用详解"></a>7-1-1-1：注解使用详解</h4><p>方法 ：将注解使用于方法上，不过需要注意的是：<br>      该注解只能应用到 public 方法上，否则不生效。<br>类 ：如果这个注解使用在类上的话，<br>     表明该注解对该类中所有的 public 方法都生效。<br>接口 ：不推荐在接口上使用。</p>
<h4 id="7-1-1-2：注解常用属性"><a href="#7-1-1-2：注解常用属性" class="headerlink" title="7-1-1-2：注解常用属性"></a>7-1-1-2：注解常用属性</h4><ol>
<li>propagation    事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过</li>
<li>isolation    事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过</li>
<li>timeout        事务的超时时间，默认值为-1（不会超时）。<pre><code>         如果超过该时间限制但事务还没有完成，则自动回滚事务。</code></pre>
</li>
<li>readOnly        指定事务是否为只读事务，默认值为 false。</li>
<li>rollbackFor    用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</li>
</ol>
<h3 id="7-1-2：Spring两种事务区别"><a href="#7-1-2：Spring两种事务区别" class="headerlink" title="7-1-2：Spring两种事务区别"></a>7-1-2：Spring两种事务区别</h3><p>1）声明式事务最大的优点就是不需要<br>   在业务逻辑代码中掺杂事务管理的代码，<br>   只需在配置文件中做相关的事务<br>   规则声明或通过@Transactional注解的方式，<br>   便可以将事务规则应用到业务逻辑中。<br>2）声明式事务管理要优于编程式事务管理，<br>   这正是 spring倡导的非侵入式的开发方式，<br>   使业务代码不受污染，<br>   只要加上注解就可以获得完全的事务支持。<br>   唯一不足地方是，最细粒度只能作用到方法级别，<br>   无法做到像编程式事务那样可以作用到代码块级别。</p>
<h2 id="7-2：事务管理接口"><a href="#7-2：事务管理接口" class="headerlink" title="7-2：事务管理接口"></a>7-2：事务管理接口</h2><ol>
<li>PlatformTransactionManager： （平台）事务管理器，Spring 事务策略的核心。</li>
<li>TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li>
<li>TransactionStatus： 事务运行状态。</li>
</ol>
<p>我们可以把 PlatformTransactionManager 接口可以被看作是事务上层的管理者，<br>而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事物的描述。<br>PlatformTransactionManager 会根据 TransactionDefinition<br>的定义比如事务超时时间、隔离界别、传播行为等来进行事务管理 ，<br>而 TransactionStatus 接口则提供了<br>一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p>
<h2 id="7-3：事务属性详解"><a href="#7-3：事务属性详解" class="headerlink" title="7-3：事务属性详解"></a>7-3：事务属性详解</h2><p>事务属性主要包括五部分：隔离级别、传播行为、回滚规则、是否只读、事务超时</p>
<h3 id="7-3-1：事务隔离级别"><a href="#7-3-1：事务隔离级别" class="headerlink" title="7-3-1：事务隔离级别"></a>7-3-1：事务隔离级别</h3><p>ISOLATION_DEFAULT:这是个PlatfromTransactionManager默认的隔离级别，<br>                   使用数据库默认的事务隔离级别。<br>ISOLATION_READ_UNCOMMITTED:读未提交，<br>                           允许另外一个事务可以看到这个事务未提交的数据。<br>ISOLATION_READ_COMMITTED:读已提交，<br>                         保证一个事务修改的数据提交后<br>                         才能被另一事务读取，<br>                         而且能看到该事务对已有记录的更新。<br>ISOLATION_REPEATABLE_READ:可重复读，<br>                          保证一个事务修改的数据提交后<br>                          才能另一事务读取，<br>                          但是不能看到该事务对已有记录的更新。<br>ISOLATION_SERIALIZABLE:一个事务在执行的过程中<br>                       完全看不到其他事务对数据库所</p>
<h3 id="7-3-2：事务传播行为（为什么要有）"><a href="#7-3-2：事务传播行为（为什么要有）" class="headerlink" title="7-3-2：事务传播行为（为什么要有）"></a>7-3-2：事务传播行为（为什么要有）</h3><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如<br>我们在 A 类的aMethod（）方法中调用了 B 类的 bMethod() 方法。<br>这个时候就涉及到业务层方法之间互相调用的事务问题。<br>如果我们的 bMethod()如果发生异常需要回滚，<br>如何配置事务传播行为才能让 aMethod()也跟着回滚呢<br>这个时候就需要事务传播行为的知识了，</p>
<h4 id="7-3-2-1：传播行为级别"><a href="#7-3-2-1：传播行为级别" class="headerlink" title="7-3-2-1：传播行为级别"></a>7-3-2-1：传播行为级别</h4><p><code>PROPAGATION_REQUIRED</code>:如果当前没有事务，<br>                     就创建一个新事务，<br>                     如果当前存在事务，<br>                     就加入该事务，<br>                     该设置是最常用的设置。<br><code>PROPAGATION_SUPPORTS</code>:支持当前事务，<br>                     如果当前存在事务，<br>                     就加入该事务，<br>                     如果当前不存在事务，<br>                     就以非事务执行。<br><code>PROPAGATION_MANDATORY</code>:支持当前事务，<br>                      如果当前仔在事分，<br>                      影果当前不存在事务，<br>                      就抛出异常。<br><code>PROPAGATION_REOUIRES NEW</code>:创建新事务，<br>                         无论当前存不存在事务，<br>                         都创建新事务。<br><code>PROPAGATION_NOT_SUPPORTED</code>:以非事务方式执行操作，<br>                          如果当前存在事务，<br>                          就把当前事务挂起。<br><code>PROPAGATION_NEVER</code>:以非事务方式执行，<br>                  如果当前存在事务，<br>                  则抛出异常。<br><code>PROPAGATION_NESTED</code>:如果当前存在事务，<br>                   则在嵌套事务内执行。<br>                   如果当前没有事务，<br>                   则按 REQUIRED属性执行。</p>
<h3 id="7-3-3：事务的回滚规则"><a href="#7-3-3：事务的回滚规则" class="headerlink" title="7-3-3：事务的回滚规则"></a>7-3-3：事务的回滚规则</h3><p>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</p>
<p>默认情况下，事务只有遇到运行期异常时才会回滚，<br>而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。<br>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。<br>同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p>
<h3 id="7-3-4：事务的只读属性"><a href="#7-3-4：事务的只读属性" class="headerlink" title="7-3-4：事务的只读属性"></a>7-3-4：事务的只读属性</h3><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</p>
<h5 id="7-3-4-1：什么是事务性资源"><a href="#7-3-4-1：什么是事务性资源" class="headerlink" title="7-3-4-1：什么是事务性资源"></a>7-3-4-1：什么是事务性资源</h5><p>事务性资源就是指那些被事务管理的资源，<br>比如数据源、JMS 资源，以及自定义的事务性资源等等。<br>如果确定只对事务性资源进行只读操作，<br>那么我们可以将事务标志为只读的，<br>以提高事务处理的性能。</p>
<h3 id="7-3-5：事务的超时属性"><a href="#7-3-5：事务的超时属性" class="headerlink" title="7-3-5：事务的超时属性"></a>7-3-5：事务的超时属性</h3><p>就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。<br>在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。<br>当然，这个属性，貌似我们基本也没用过。</p>
<h2 id="7-4：Spring的事务和数据库的事务隔离是一个概念么？"><a href="#7-4：Spring的事务和数据库的事务隔离是一个概念么？" class="headerlink" title="7-4：Spring的事务和数据库的事务隔离是一个概念么？"></a>7-4：Spring的事务和数据库的事务隔离是一个概念么？</h2><p>Spring 并不直接管理事务，而是提供了多种事务管理器 。<br>Spring 事务管理器的接口是： PlatformTransactionManager 。<br>通过这个接口，Spring 为各个平台如<br>JDBC(DataSourceTransactionManager)、<br>Hibernate(HibernateTransactionManager)、<br>JPA(JpaTransactionManager)等都提供了<br>对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<h2 id="7-5：Spring事务底层原理"><a href="#7-5：Spring事务底层原理" class="headerlink" title="7-5：Spring事务底层原理"></a>7-5：Spring事务底层原理</h2><ol>
<li>划分处理单元 IOC<br> 之前在看源码，发现Spring 解决的问题是对单个数据库进行局部事务处理的，<br> 具体的实现首先使用 Spring 中的 IOC 划分了事务处理单元。<br> 并且将对事务的各种配置放到了 IOC 容器中<br> （设置事务管理器，设置事务的传播特性及隔离机制）。</li>
<li>AOP 拦截需要进行事务处理的类<br> Spring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，<br> 具体操作（比如事务实行的配置和读取，事务对象的抽象），<br> 用 TransactionProxyFactoryBean 接口来使用 AOP 功能，<br> 生成 proxy 代理对象，通过 TransactionInterceptor 完成对代理方法的拦截，<br> 将事务处理的功能编织到拦截的方法中。读取 IOC 容器事务配置属性，<br> 转化为 Spring 事务处理需要的内部数据结构<br> （TransactionAttributeSourceAdvisor），<br> 转化为 TransactionAttribute 表示的数据对象。</li>
<li>对事物处理实现（事务的生成、提交、回滚、挂起）<br> Spring 委托给具体的事务处理器实现。实现了一个抽象和适配。<br> 适配的具体事务处理器：DataSource 数据源支持、<br> Hibernate 数据源事务处理支持、JDO 数据源事务处理支持，<br> JPA、JTA 数据源事务处理支持。<br> 这些支持都是通过设计 PlatformTransactionManager、<br> AbstractPlatforTransaction 一系列事务处理的支持。<br> 为常用数据源支持提供了一系列的 TransactionManager。</li>
</ol>
<h2 id="7-6：为什么在-Spring-事务中不能切换数据源？"><a href="#7-6：为什么在-Spring-事务中不能切换数据源？" class="headerlink" title="7-6：为什么在 Spring 事务中不能切换数据源？"></a>7-6：为什么在 Spring 事务中不能切换数据源？</h2><p>因为，在 Spring 的事务管理中，<br>所使用的数据库连接会和当前线程所绑定，<br>即使我们设置了另外一个数据源，使用的还是当前的数据源连接。<br>另外，多个数据源且需要事务的场景，<br>本身会带来多事务一致性的问题，暂时的话，可能没有太好的解决方案<br>所以一般一个应用，推荐除非了读写分离所带来的多数据源，<br>其它情况下，建议只有一个数据源。</p>
<h1 id="8-Spring的装配"><a href="#8-Spring的装配" class="headerlink" title="8.Spring的装配"></a>8.Spring的装配</h1><h2 id="8-1：什么是Spring装配"><a href="#8-1：什么是Spring装配" class="headerlink" title="8-1：什么是Spring装配"></a>8-1：什么是Spring装配</h2><p>当 Bean 在 Spring 容器中组合在一起时，它被称为装配或 Bean 装配</p>
<h2 id="8-2：自动装配有哪些方式"><a href="#8-2：自动装配有哪些方式" class="headerlink" title="8-2：自动装配有哪些方式"></a>8-2：自动装配有哪些方式</h2><p>Spring 容器能够自动装配 Bean 。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 Bean 的协作者。<br>自动装配的不同模式：</p>
<p>no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。<br>byName - 它根据 Bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。<br>【最常用】byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。<br>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。<br>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">小丸子</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://github.com/tomorrow813/2020/11/29/spring/">https://github.com/tomorrow813/2020/11/29/spring/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">小丸子</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/12/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-12-01
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            小丸子
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/11/28/%E5%8F%8D%E5%B0%84/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="反射">
                        
                        <span class="card-title">反射</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-11-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            小丸子
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java%E5%9F%BA%E7%A1%80/">
                        <span class="chip bg-color">java基础</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2020</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">小丸子</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
