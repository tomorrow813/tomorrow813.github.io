<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode</title>
      <link href="2021/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
      <url>2021/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/</url>
      
        <content type="html"><![CDATA[<h2 id="树："><a href="#树：" class="headerlink" title="树："></a>树：</h2><p>平衡二叉             2020/8/4/19    3    先序遍历剪纸    待研究dfs<br>二叉树的中序遍历        2020/8/4/19    3    栈    递归<br>二叉树的前序遍历        2020/8/4    3    栈<br>二叉树的后序遍历        2020/8/4    3    栈<br>二叉树的层次遍历        2020/8/4/19    4    队列<br>二叉树的锯齿形层次遍历    2020/8/19    1    队列    双端队列<br>二叉树的最近公共祖先      2020/8/19    1<br>二叉搜索树的最近公共祖先    2020/8/19<br>二叉搜索树中第K小的元素            中序遍历<br>二叉搜索树的第 k 大节点            中序遍历倒过来<br>从上到下打印二叉树 III            队列<br>从上到下打印二叉树 II            队列<br>从上到下打印二叉树            队列<br>实现二叉树先序，中序和后序遍历            牛客网，也是递归 不过数组时候需要知道节点的数目<br>二叉搜索树与双向链表<br>二叉树的最大深度    2020/8/19    2    递归（容易想到）    迭代方法掌握的不好（类似层序遍历）<br>二叉树的最小深度    2020/8/19    1    递归+类层序遍历<br>二叉树的镜像/翻转二叉树    2020/8/19    1    递归/迭代（前序遍历）<br>树的子结构<br>完全二叉树的节点个数            公式法，<br>最大二叉树<br>合并二叉树<br>二叉树的直径            就是求高度中更新max的值l+r+1；经历的节点树，最终结果减一即可<br>把二叉搜索树转换为累加树            反向去中序遍历二叉树，修改sum的值，然后复制给当前节点的值<br>相同的树<br>二叉树中和为某一值的路径<br>二叉树的完全性检验（层序遍历）            判断一棵树是不是完全二叉树，主要就是层序遍历，如果遍历的过程中左子节点或者是右子节点没有值的情况下，就说明已经是最后一层。然后再遍历的过程中        </p><p>二叉树的右视图    2020/9/2    0    层序遍历，i==size-1的时候给他增加到list中<br>二叉树展开为链表            利用栈的先序遍历 然后更新pre 的值；当pre!=null pre.left=null,pre.right=node<br>判断t1树中是否有与t2树拓扑结构完全相同的子树<br>有序链表转换二叉搜索树<br>将有序数组转换为二叉搜索树<br>从前序与中序遍历序列构造二叉树    2020/8/22    0    递归<br>对称二叉树    2020/8/19    1    递归+广度优先搜索<br>验证二叉搜索树            中序遍历，每一次弹出来的值大于前一个值<br>序列化                    </p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><pre><code>- [哑节点](#哑节点)    - [203. 移除链表元素](#203-移除链表元素)- [剑指 Offer 18. 删除链表的节点](#剑指-offer-18-删除链表的节点)    - [237. 删除链表中的节点](#237-删除链表中的节点)    - [2. 两数相加](#2-两数相加)    - [21. 合并两个有序链表](#21-合并两个有序链表)    - [86. 分隔链表(下一道题变形题)](#86-分隔链表下一道题变形题)- [双指针](#双指针)    - [面试题 02.04. 分割链表（类似下一道）](#面试题-0204-分割链表类似下一道)    - [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](#剑指-offer-21-调整数组顺序使奇数位于偶数前面)    - [剑指 Offer 24. 反转链表](#剑指-offer-24-反转链表)    - [234. 回文链表（面试题 02.06    回文链表  ）](#234-回文链表面试题-0206    回文链表--)- [快慢指针](#快慢指针)    - [141. 环形链表](#141-环形链表)    - [142. 环形链表 II](#142-环形链表-ii)    - [剑指 Offer 52. 两个链表的第一个公共节点](#剑指-offer-52-两个链表的第一个公共节点)    - [剑指 Offer 22. 链表中倒数第k个节点](#剑指-offer-22-链表中倒数第k个节点)</code></pre><ul><li><a href="#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8">328. 奇偶链表</a><ul><li><a href="#%E8%A7%A3%E6%B3%951-%E5%93%91%E8%8A%82%E7%82%B9%E7%9A%84%E8%AE%BE%E7%BD%AE">解法1: 哑节点的设置</a></li><li><a href="#%E8%A7%A3%E6%B3%952-%E5%8F%8C%E6%8C%87%E9%92%88">解法2: 双指针</a></li></ul></li><li><a href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">876. 链表的中间结点 快慢指针</a></li><li><a href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E5%93%91%E8%8A%82%E7%82%B9">24. 两两交换链表中的节点 哑节点</a></li><li><a href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%E5%89%91%E6%8C%87-offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-%E5%93%91%E8%8A%82%E7%82%B9">19. 删除链表的倒数第N个节点(剑指 Offer 22. 链表中倒数第k个节点) 快慢指针 哑节点</a></li><li><a href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-ii">92. 反转链表 II</a></li><li><a href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88">83. 删除排序链表中的重复元素 双指针</a></li><li><a href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii">82. 删除排序链表中的重复元素 II</a></li><li><a href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8">61. 旋转链表</a></li><li><a href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8">143. 重排链表</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值传递与引用传递</title>
      <link href="2021/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
      <url>2021/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%80%BC%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<font color = gold size =5>接着上次做笔记</font><h1 id="5-java基础-值传递与引用传递"><a href="#5-java基础-值传递与引用传递" class="headerlink" title="5.java基础-值传递与引用传递"></a>5.java基础-值传递与引用传递</h1><p>对基本类型的数据进行操作：由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。<br>对引用类型的数据进行操作，分两种情况：<br>一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。<br>一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</p><h2 id="5-1：值传递与引用传递的概念"><a href="#5-1：值传递与引用传递的概念" class="headerlink" title="5-1：值传递与引用传递的概念"></a>5-1：值传递与引用传递的概念</h2><ol><li><p>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本的值不影响原变量的值</p></li><li><p>引用传递一般是对于引用类型变量而言的,传递的是该对象地址的一个副本，是一个地址。</p><ul><li>如果说改变了原地址的值（注意是  值  ），那么会影响</li><li>如果改变了副本地址，如new 一个原地址不会改变  </li></ul></li></ol><p>一般认为,java传递都是值传递.</p><h2 id="5-2：值传递与引用传递的实例举证"><a href="#5-2：值传递与引用传递的实例举证" class="headerlink" title="5-2：值传递与引用传递的实例举证"></a>5-2：值传递与引用传递的实例举证</h2><ol><li>基本类型<br>那我先说一下基本类型作为参数传递的例子：<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test1 &#123;       public static void main(String[] args) &#123;        int n &#x3D; 3;        System.out.println(&quot;Before change, n &#x3D; &quot; + n);        changeData(n);        System.out.println(&quot;After changeData(n), n &#x3D; &quot; + n);    &#125;public static void changeData(int n) &#123;        n &#x3D; 10;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>基本类型作为参数传递时，是传递值的拷贝，<br>无论你怎么改变这个拷贝，原值是不会改变的，输出的结果证明了这一点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Before change, n &#x3D; 3After changeData(n), n &#x3D; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>引用类型</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">   public class TransferTest2 &#123;    public static void main(String[] args) &#123;        Person person &#x3D; new Person();        System.out.println(person);        change(person);        System.out.println(person);    &#125;&#x2F;&#x2F;    public static void change(Person p) &#123;        p &#x3D; new Person();    &#125;&#125;&#x2F;** * Person类 *&#x2F;class Person &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两次打印结果一致。</p><p>在调用change()方法后，person变量并没发生改变。</p><p>01.当程序执行到第3行 Person person = new Person()时，<br>   程序在堆内存（heap）中开辟了一块内存空间用来存储Person类实例对象，<br>   同时在栈内存（stack）中开辟了一个存储单元来存储该实例对象的引用，即上图中person指向的存储单元。</p><p>02.当程序执行到第5行 change(person)时，person作为参数（实参）传递给饿了change()方法。<br>   这里是person将自己的存储单元的内容传递给了change()方法的p变量。<br>   此后在change()方法中对p变量的一切操作都是针对于p变量所指向的存储单元，与perosn所指向的存储单元就没有关系了。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础</title>
      <link href="2021/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%9F%BA%E7%A1%80.md/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%9F%BA%E7%A1%80.md/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<font color = gold size =5>接着上次做笔记</font><h1 id="java基础-面对对象"><a href="#java基础-面对对象" class="headerlink" title="java基础-面对对象"></a>java基础-面对对象</h1><h2 id="2-1：面对对象三大特征-特点"><a href="#2-1：面对对象三大特征-特点" class="headerlink" title="2-1：面对对象三大特征(特点)"></a>2-1：面对对象三大特征(特点)</h2><ol><li><p>封装</p></li><li><p>继承</p><p>继承的出现提高了代码的复用性。<br>继承的出现让类与类之间产生了关系，提供了多态的前提。</p></li><li><p>多态</p></li></ol><h2 id="2-3：封装"><a href="#2-3：封装" class="headerlink" title="2-3：封装"></a>2-3：封装</h2><h3 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h3><p>封装就有两个含义：把该隐藏的隐藏起来，把该暴露的暴露出来。<br>   把字段（成员变量）和实现细节隐藏起来，不允许外部直接访问<br>   把方法暴露出来<br>   <strong>以实现下述目的：</strong><br>隐藏一个类中不需要对外提供的实现细节；<br>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；<br>便于修改，增强代码的可维护性；</p><p>封装的应用场景</p><p>如果一个属性不想被其他人直接的访问，那么这时候就可以使用封装。<br>现实开发中的实体类的成员属性(成员变量)一般我们都会封装起来。</p><h2 id="2-4：继承"><a href="#2-4：继承" class="headerlink" title="2-4：继承"></a>2-4：继承</h2><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，<br>新类的定义可以增加新的数据或新的功能，<br>也可以用父类的功能，但不能选择性地继承父类。<br>通过使用继承我们能够非常方便地复用以前的代码，<br>能够大大的提高开发的效率</p><p>继承的出现让类与类之间产生了关系，提供了多态的前提。</p><h2 id="2-5：多态"><a href="#2-5：多态" class="headerlink" title="2-5：多态"></a>2-5：多态</h2><h3 id="2-5-1：多态的必要条件（实现方式、机制）"><a href="#2-5-1：多态的必要条件（实现方式、机制）" class="headerlink" title="2-5-1：多态的必要条件（实现方式、机制）"></a>2-5-1：多态的必要条件（实现方式、机制）</h3><ol><li>有类继承或者接口实现</li><li>子类要重写父类的方法</li><li>父类的引用指向子类的对象</li></ol><h3 id="2-5-2：多态的好处"><a href="#2-5-2：多态的好处" class="headerlink" title="2-5-2：多态的好处"></a>2-5-2：多态的好处</h3><p>不必为每一个派生类编写功能调用，大大提高程序的扩展性。<br>父类引用指向子类。同时又有方法重写，运行的时候肯定是个各子类重写的方法在起作用。从而利用多态实现好的扩展性<br>缺点:<br>利用多态无法访问子类所特有的方法</p><p>缺点解决办法:<br>向下转型+instanceof关键字</p><h1 id="java基础-构造器"><a href="#java基础-构造器" class="headerlink" title="java基础-构造器"></a>java基础-构造器</h1><h2 id="3-1：⼀个类的构造⽅法的作⽤是什么"><a href="#3-1：⼀个类的构造⽅法的作⽤是什么" class="headerlink" title="3-1：⼀个类的构造⽅法的作⽤是什么"></a>3-1：⼀个类的构造⽅法的作⽤是什么</h2><p>主要作⽤是完成对类对象的初始化⼯作。<br>可以执⾏。因为⼀个类即使没有声明构造⽅法也会有默认的不带参数的构造⽅法。</p><h2 id="3-2：构造⽅法有哪些特性？"><a href="#3-2：构造⽅法有哪些特性？" class="headerlink" title="3-2：构造⽅法有哪些特性？"></a>3-2：构造⽅法有哪些特性？</h2><ol><li>名字与类名相同。</li><li>没有返回值，但不能⽤ void 声明构造函数。</li><li>⽣成类的对象时⾃动执⾏，⽆需调⽤。</li></ol><h2 id="3-3：构造方法可不可以被重写和重载"><a href="#3-3：构造方法可不可以被重写和重载" class="headerlink" title="3-3：构造方法可不可以被重写和重载"></a>3-3：构造方法可不可以被重写和重载</h2><p>构造方法可以被重载。<br>构造方法不可以被重写，因为重写发生在父类和子类之间，要求方法名称相同，<br>而构造方法的名称是和类名相同的，而子类类名不会和父类类名相同，所以不可以被重写。</p><h2 id="3-4：构造函数能用private修饰吗"><a href="#3-4：构造函数能用private修饰吗" class="headerlink" title="3-4：构造函数能用private修饰吗"></a>3-4：构造函数能用private修饰吗</h2><p>可以的，用private修饰的构造方法不允许被new了<br>因为编译会出现访问private私有的成员</p><h1 id="4-java基础-重载与重写"><a href="#4-java基础-重载与重写" class="headerlink" title="4.java基础-重载与重写"></a>4.java基础-重载与重写</h1><h2 id="4-1：重载与重写"><a href="#4-1：重载与重写" class="headerlink" title="4-1：重载与重写"></a>4-1：重载与重写</h2><ol><li>重载——函数或者方法有同样的名称，但是参数列表不相同的情形</li><li>重写——在子类中可以根据需要对从父类中继承来的方法进行改造，也称方法的重写、重置。在程序执行时，子类的方法将覆盖父类的方法。<br><strong>覆盖方法必须和被重写方法具有相同的方法名称、参数列表。</strong></li></ol><p><strong>覆盖方法不能使用比被重写方法更严格的访问权限。</strong><br>class Parent {<br>    public void method1() {}<br>}</p><p>class Child extends Parent {<br>    private void method1() {}<br>//非法，子类中的method1()的访问权限private比被覆盖方法的访问权限public弱<br>}</p><p><strong>子类方法抛出的异常不能大于父类被重写方法的异常</strong><br>，例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。<br><strong>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</strong>（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p><h2 id="4-2：Java-中是否可以覆盖-override-一个-private-或者是-static-的方法？"><a href="#4-2：Java-中是否可以覆盖-override-一个-private-或者是-static-的方法？" class="headerlink" title="4-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？"></a>4-2：Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</h2><ol><li>Java中static方法不能被覆盖， 因为方法覆盖是基于运行时动态绑定的， 而static方法是编译时静态<br>绑定的。 </li><li>Java中也不可以覆盖private的方法， 因为private修饰的变量和方法只能在当前类中使用，如果是其他<br>的类继承当前类是不能访问到 private 变量或方法的， 当然也不能覆盖。</li></ol><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h3 id="2-6-1：Java-抽象类可以有构造函数吗？作用是什么"><a href="#2-6-1：Java-抽象类可以有构造函数吗？作用是什么" class="headerlink" title="2-6-1：Java 抽象类可以有构造函数吗？作用是什么"></a>2-6-1：Java 抽象类可以有构造函数吗？作用是什么</h3><p>可以有， 抽象类可以声明并定义构造函数。<br>1.<strong>抽象类中并不都是抽象方法，里面有成员变量</strong>，<strong>构造器是用来给这些成员变量赋值的。</strong><br>2.另外，即使没有提供任何构造函数，<strong>编译器将为抽象类添加默认的无参数的构造函数，没有的话子类将无法编译</strong>，因为在任何构造函数中的第一条语句隐式调用super ()，子类对象实例化的时候，满足先执行父类构造，再执行子类构造的顺序。</p><h3 id="2-6-2：Java-抽象类可以实现接口吗？-它们需要实现所有的方法吗"><a href="#2-6-2：Java-抽象类可以实现接口吗？-它们需要实现所有的方法吗" class="headerlink" title="2-6-2：Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗"></a>2-6-2：Java 抽象类可以实现接口吗？ 它们需要实现所有的方法吗</h3><p>可以， 抽象类可以通过使用关键字implements来实现接口。<br>由普通的类来实现接口，必须将接口所有抽象方法重写<br>由抽象类来实现接口，则不必重写接口的方法。可以全部不重写或只重写一部分方法。</p><h3 id="2-6-3：Java-抽象类可以是-final-的吗"><a href="#2-6-3：Java-抽象类可以是-final-的吗" class="headerlink" title="2-6-3：Java 抽象类可以是 final 的吗"></a>2-6-3：Java 抽象类可以是 final 的吗</h3><p>不可以， Java 抽象类不能是 final 的。<br>将它们声明为final的将会阻止它们被继承， 而这正是使用抽象类唯一的方法。</p><h3 id="2-6-4：Java-抽象类可以有-static-方法吗"><a href="#2-6-4：Java-抽象类可以有-static-方法吗" class="headerlink" title="2-6-4：Java 抽象类可以有 static 方法吗"></a>2-6-4：Java 抽象类可以有 static 方法吗</h3><p>可以， 抽象类可以声明并定义 static 方法， 没什么阻止这样做。</p><h3 id="2-6-5：可以创建抽象类的实例吗（new-类）"><a href="#2-6-5：可以创建抽象类的实例吗（new-类）" class="headerlink" title="2-6-5：可以创建抽象类的实例吗（new 类）"></a>2-6-5：可以创建抽象类的实例吗（new 类）</h3><p>不可以，</p><ol><li>对象实例化的时候，关键字new向JVM申请内存，这个类的成员会被保存到内存中<br>而抽象类，没有具体的成员，没办法准确分配内存。</li><li>可能也是设计层面上的解释，不希望实例化<br>参考别人：记录：new一个抽象类到底new出了个什么东西</li></ol><p>abstract class A {<br>    abstract void a();<br>}</p><p>A <em>a = new A() {<br>  @Override<br>  public void a() {<br>  Log.e(“wy</em>“,”Class对象是： “ + this.getClass());<br>  Log.e(“wy_”,”类名字是： “ + this.getClass().getSimpleName());<br>  }<br> };</p><p> _a.a();</p><p>//日志输出为：<br>wy_: Class对象是： class activity.newvideo.molb_808_1078.dst.com.myapplication.MainActivity$1<br>wy_: 类名字是： </p><p>可以看出是new出来的 A是一个匿名内部类，只是实现了 a()方法，并不是new出了抽象类</p><p>//复制一下别人的总结：链接<br>抽象类不能直接new出来，如果要new出来必须使用匿名类的方式，匿名类其实就是声明了一个新的类来继承抽象类，所以你必须在匿名类实现所有抽象方法。<br>接口和抽象类类似，只不过里面的方法都是抽象方法，因此匿名类必须实现定义在接口里面的所有方法。<br>普通的非抽象的类也可以用匿名类new出来，只不过默认不需要实现任何方法，因为普通类里面没有抽象方法，当然你可以Override任何非私有方法。</p><p>版权声明：本文为CSDN博主「SkySmile_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/SkySmile_/article/details/105309078">https://blog.csdn.net/SkySmile_/article/details/105309078</a></p><p>1.从Java规范来看：很简单直了，Java程序中规定了抽象类不能实例化。强行实例化就会报错。<br>2.从功能角度来看：抽象类是一个结构和功能“不完整”的类，如果你让他强行“出生”的话，它可能会患有各种疾病，所以我们不能直接进行实例化，需要通过子类对结构和功能进行补全才能让它健康出生。<br>3.从内存分配角度来看：抽象类只在分配了在栈中的引用，没有分配堆中的内存。程序都有一个代码段,在内存中需要占据一定的内存,而抽象类没有具体的实现方法,无法具体的给它分配内存空间,所以为了安全,不JAVA不允许抽象类,接口直接实例化。</p><h3 id="2-6-6：抽象类必须有抽象方法吗"><a href="#2-6-6：抽象类必须有抽象方法吗" class="headerlink" title="2-6-6：抽象类必须有抽象方法吗"></a>2-6-6：抽象类必须有抽象方法吗</h3><p>不需要， 抽象类有抽象方法不是强制性的。但是一般在抽象类中设置抽象方法</p><p><strong>4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</strong></p><h3 id="2-6-8：Java中的抽象方法是什么"><a href="#2-6-8：Java中的抽象方法是什么" class="headerlink" title="2-6-8：Java中的抽象方法是什么"></a>2-6-8：Java中的抽象方法是什么</h3><ol><li>抽象方法是一个没有方法体的方法。 你仅需要声明一个方法，</li><li>不需要定义它并使用关键字abstract 声明。</li></ol><h3 id="2-6-9：Java抽象类中可以包含main方法吗"><a href="#2-6-9：Java抽象类中可以包含main方法吗" class="headerlink" title="2-6-9：Java抽象类中可以包含main方法吗"></a>2-6-9：Java抽象类中可以包含main方法吗</h3><p>是的， 抽象类可以包含 main 方法，<br>它只是一个静态方法， 你可以使用 main 方法执行抽象类， 但不可以创建任何实例。<br><a href="https://blog.csdn.net/u013007900/article/details/79350438?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-6&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/u013007900/article/details/79350438?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-6&amp;spm=1001.2101.3001.4242</a></p><p>必须看</p><h2 id="2-7：面对对象区别"><a href="#2-7：面对对象区别" class="headerlink" title="2-7：面对对象区别"></a>2-7：面对对象区别</h2><h3 id="2-6-7：何时选用抽象类而不是接口"><a href="#2-6-7：何时选用抽象类而不是接口" class="headerlink" title="2-6-7：何时选用抽象类而不是接口"></a>2-6-7：何时选用抽象类而不是接口</h3><ol><li>当关心升级时， 因为不可能在一个发布的接口中添加一个新方法， 用抽象类会更好。</li><li>如果你的接口中有很多方法， 你对它们的实现感到很头疼， 考虑提供一个抽象类作为默认实现。</li></ol><h3 id="2-7-1：接⼝和抽象类的区别"><a href="#2-7-1：接⼝和抽象类的区别" class="headerlink" title="2-7-1：接⼝和抽象类的区别"></a>2-7-1：接⼝和抽象类的区别</h3><ol><li>所有⽅法在接⼝中不能有实现，⽽抽象类可以有⾮抽象的⽅法。</li><li>接⼝中除了final变量，不能有其他变量，⽽抽象类中则不⼀定。</li><li>⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。</li><li>从设计层⾯来说，抽象类作为很多子类的父类，是一种模板式设计，接口是一种行为规范<br>接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为），<strong>也就是提供一种机制，可以强制要求不同的类具有相同的行为</strong>。<strong>它只约束了行为的有无，但不对如何实现行为进行限制</strong>。对“接口为何是约束”的理解，我觉得配合泛型食用效果更佳。<br>而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）。</li></ol><p>作者：阿法利亚<br>链接：<a href="https://www.zhihu.com/question/20149818/answer/150169365">https://www.zhihu.com/question/20149818/answer/150169365</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="2-7-2：继承和接口区别"><a href="#2-7-2：继承和接口区别" class="headerlink" title="2-7-2：继承和接口区别"></a>2-7-2：继承和接口区别</h3><ol><li>java类可以一次继承多个接口，用implements 接口1，接口2</li><li>如果是接口继承接口的话也可以用extends，接口是多继承的，java类才是单继承</li><li><strong>接口继承接口可以不实现父接口中的方法，可以声明自己的新方法，</strong></li><li>类实现接口时，一定要实现接口中声明的方法，<br>如果接口中没有定义抽象方法则不需要，<br>但是如果发生某个类实现了一个接口A,如果B是A的父接口，<br>且B中有抽象方法，则该类必须实现A和B中的所有抽象方法</li><li>抽象方法只能定义在抽象类中，抽象类实现接口，可以不实现接口中的抽象方法<br>继承接口是说的接口来继承接口，是接口与接口间的</li></ol><h3 id="2-7-3：为什么要设计接口、抽象类还有实现类"><a href="#2-7-3：为什么要设计接口、抽象类还有实现类" class="headerlink" title="2-7-3：为什么要设计接口、抽象类还有实现类"></a>2-7-3：为什么要设计接口、抽象类还有实现类</h3><p>比如说我要实现A类的多样式</p><p>接口：定义了a-1，a-2几个接口，让所有的程序都遵守这个。<br>抽象类：我默认实现了一个样式。如果其他扩展的样式不想做这部分的工作就不用实现了。<br>实现类：我只实现我需要关心的方法，如a-1就不用再实现了，只需要实现a-2就可以了。</p><h2 id="2-8：面对对象应用场景"><a href="#2-8：面对对象应用场景" class="headerlink" title="2-8：面对对象应用场景"></a>2-8：面对对象应用场景</h2><h3 id="2-8-1：接口和抽象类的应用场景"><a href="#2-8-1：接口和抽象类的应用场景" class="headerlink" title="2-8-1：接口和抽象类的应用场景"></a>2-8-1：接口和抽象类的应用场景</h3><ol><li>抽象类的使用场景<br>既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量<br>如：模板方法设计模式，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现。</li><li>接口的应用场景</li><li>约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现</li><li>作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。</li><li>实现类需要具备很多不同的功能，但各个功能之间可能没有任何联系。</li><li>使用接口的引用调用具体实现类中实现的方法（多态）</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值传递与引用传递</title>
      <link href="2021/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%9F%BA%E7%A1%80.md/int/"/>
      <url>2021/02/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%9F%BA%E7%A1%80.md/int/</url>
      
        <content type="html"><![CDATA[<font color = gold size =5>接着上次做笔记</font><h1 id="9-java基础-数据类型"><a href="#9-java基础-数据类型" class="headerlink" title="9.java基础-数据类型"></a>9.java基础-数据类型</h1><h2 id="9-1：八种数据类型是什么？"><a href="#9-1：八种数据类型是什么？" class="headerlink" title="9-1：八种数据类型是什么？"></a>9-1：八种数据类型是什么？</h2><ol><li>字符型   char</li><li>布尔型  boolean</li><li>数值型<ol><li>整型：byte、short、int、long</li><li>浮点型：float、double</li></ol></li></ol><p><font color=red>特别注意</font>：String不是基本数据类型，是引用类型。</p><p>然而Java还提供另一种数据类型：引用类型即封装类型（Byte，Short，Integer，Long，Float，Double，Character，Boolean）<br>  比如Integer为int的封装类，所以Interger不是基本数据类型而是类。</p><h3 id="9-1-1：java为什么除了基本数据类型还要有引用数据类型"><a href="#9-1-1：java为什么除了基本数据类型还要有引用数据类型" class="headerlink" title="9-1-1：java为什么除了基本数据类型还要有引用数据类型"></a>9-1-1：java为什么除了基本数据类型还要有引用数据类型</h3><ol><li>它封装了数据和处理该数据的方法，比如Integer.parseInt(String)就是将String字符类型数据转换为Integer整型数据。</li><li>Java中大部分类和方法都是针对类类型对象的，比如ArrayList集合类就只能以类作为它的存储对象，如果要储存int型数据就要将其包装成一个类即Integer，然后才能存入list。</li><li>引用类型在堆里，基本类型在栈里。<br>我们都知道在Java语言中，new一个对象存储在堆里，我们通过栈中的引用来使用这些对象。但是对于经常用到的一系列类型如int、boolean… 如果我们用new将其存储在堆里就不是很高效——特别是简单的小的变量。所以，同C++ 一样Java也采用了相似的做法，决定基本数据类型不是用new关键字来创建，而是直接将变量的值存储在栈中，方法执行时创建，结束时销毁，因此更加高效。</li></ol><p>区别<br>接下来我在几方面总结下二者的区别：<br>1.声明方式不同：<br>基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；<br>2.存储方式及位置不同：<br>基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；<br>3.初始值不同：<br>基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；<br>4.使用方式不同：<br>基本类型直接赋值直接使用就好，而包装类型在集合（如：Collection、Map）时会使用到。</p><h3 id="9-1-2：String为什么不是基本数据类型"><a href="#9-1-2：String为什么不是基本数据类型" class="headerlink" title="9-1-2：String为什么不是基本数据类型"></a>9-1-2：String为什么不是基本数据类型</h3><ol><li>基本类型仅表示简单的数据类型，<br>引用类型可以表示复杂的数据类型，<br>还可以操作这种数据类型的行为 </li><li>java虚拟机处理基础类型与引用类型的方式是不一样的，<br>对于基本类型，java虚拟机会为其分配数据类型实际占用的内存空间，<br>而对于引用类型变量，<br>他仅仅是一个指向堆区中某个实例的指针。</li></ol><h3 id="9-1-3：引用类型有哪几种"><a href="#9-1-3：引用类型有哪几种" class="headerlink" title="9-1-3：引用类型有哪几种"></a>9-1-3：引用类型有哪几种</h3><p>类或者接口，泛型类型，数组类型</p><h2 id="9-2：数据类型的范围"><a href="#9-2：数据类型的范围" class="headerlink" title="9-2：数据类型的范围"></a>9-2：数据类型的范围</h2><p><code>数值型</code><br>byte：-2^7 ~ 2^7-1，<br>short：-2^15 ~ 2^15-1<br>int：-2^31 ~ 2^31-1<br>long：-2^63 ~ 2^63-1，<br><code>浮点型：</code><br>float：4字节。<br>double：8字节。<br><code>字符型：</code><br>char：2字节。</p><h3 id="9-2-1：为什么byte类型是-128-127"><a href="#9-2-1：为什么byte类型是-128-127" class="headerlink" title="9-2-1：为什么byte类型是-128~+127"></a>9-2-1：为什么byte类型是-128~+127</h3><p>使用原码或反码表示的范围为[-127, +127],<br>-0并没有反码补码表示，<br>而使用补码表示的范围为[-128, 127]</p><h2 id="9-3：自动拆装箱"><a href="#9-3：自动拆装箱" class="headerlink" title="9-3：自动拆装箱"></a>9-3：自动拆装箱</h2><h3 id="9-3-1：为什么要有自动拆装箱"><a href="#9-3-1：为什么要有自动拆装箱" class="headerlink" title="9-3-1：为什么要有自动拆装箱"></a>9-3-1：为什么要有自动拆装箱</h3><p>比如说集合类中，要求元素必须是Object类，<br>而int、double等基本数据类型无法使用，<br>那么我们就把基本数据类型包装起来，<br>使其具有对象的特征，并让他有了属性和方法</p><h3 id="9-3-2：自动拆装箱的原理"><a href="#9-3-2：自动拆装箱的原理" class="headerlink" title="9-3-2：自动拆装箱的原理"></a>9-3-2：自动拆装箱的原理</h3><p>自动装箱：调用valueOf（）方法将原始类型值转换成对象<br>自动拆箱：调用intValue()方法，其他的（xxxValue())这类的方法将对象转换成原始类型值。</p><h3 id="9-3-3：自动拆装箱使用场景"><a href="#9-3-3：自动拆装箱使用场景" class="headerlink" title="9-3-3：自动拆装箱使用场景"></a>9-3-3：自动拆装箱使用场景</h3><ol><li>场景一、将基本数据类型放入集合类</li><li>场景二、包装类型和基本类型的大小比较</li><li>场景三、包装类型的运算 </li><li>场景四、三目运算符的使用如果i是包装类，j是null就会NPE报错</li><li>场景五、函数参数与返回值</li></ol><h3 id="9-3-4：自动拆装箱带来的问题"><a href="#9-3-4：自动拆装箱带来的问题" class="headerlink" title="9-3-4：自动拆装箱带来的问题"></a>9-3-4：自动拆装箱带来的问题</h3><ol><li>包装对象的数值比较，不能简单的使用==，虽然-128到127之间的数字可以，<br>但是这个范围之外还是需要使用equals比较~~。</li><li>如果包装类对象为null，<br>那么自动拆箱时就有可能抛出NPE（NullPointException）。</li><li>如果一个for循环中有大量拆装箱操作<br>会浪费很多资源。</li></ol><h2 id="9-4：Integer缓存机制"><a href="#9-4：Integer缓存机制" class="headerlink" title="9-4：Integer缓存机制"></a>9-4：Integer缓存机制</h2><p>Integer对小数据（-128~=127）具有缓存机制，<br>当jvm在初始化的时候，如果数据是小数据，<br>那么就会把数据存储在本地内存当中，<br>当下次使用的时候该数据的时候，<br>那么就可以直接从本地内存进行调用，就不需要再次创建对象来解决</p><ol><li>其中会有一个valueof函数，用来判断内存中是否有着这个数值，<ul><li>如果说有，那么直接从内存进行读取</li><li>如果说没有，那么就需要创建一个对象</li></ul></li><li>在jvm初始化的时候，低值是不能改变的，<br>但是高值是可以改变的，可以通过jvm进行参数设置，<br>但是只有Integer源码可以对高值、低值进行改变。</li></ol><h2 id="9-4-1：int与Integer区别"><a href="#9-4-1：int与Integer区别" class="headerlink" title="9-4-1：int与Integer区别"></a>9-4-1：int与Integer区别</h2><ol><li>Integer是int的包装类 ，int则是java的一种基本数据类型</li><li>Integer变量必须实例化后才能使用，而int变量不需要</li><li>Integer的默认值是null, int的默认值是0</li></ol><p>注：</p><ol><li>非new生成的Integer变量和new Integer生成的变量比较时，<br>结果为false。<br>因为非new生成的Integer变量指向的是java常量池中的对象，<br>而new Integer0生成的变量指向堆中新建的对象，两者在内存中的地址不同<pre class="line-numbers language-java" data-language="java"><code class="language-java">Integer i &#x3D; new Integer(100);Integer j &#x3D; 100;Syatem.out.print(i &#x3D;&#x3D; J); &#x2F;&#x2F;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true</li></ol><h2 id="9-5：String转出int型，-判断能不能转？-如何转？"><a href="#9-5：String转出int型，-判断能不能转？-如何转？" class="headerlink" title="9-5：String转出int型， 判断能不能转？ 如何转？"></a>9-5：String转出int型， 判断能不能转？ 如何转？</h2><p>可以转， 得处理异常 Integer.parseInt(s) 主要为 NumberFormatException： </p><h2 id="9-6：short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#9-6：short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="9-6：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?"></a>9-6：short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1+=1;有什么错?</h2><p>对于 short s1 = 1; s1 = s1 + 1;<br>由于 s1+1运算时会自动提升表达式的类型，<br>所以结果是 int型，<br>再赋值给 short 类型 s1时，<br>编译器将报告需要强制转换类型的错误。<br>对于 short s1 = 1; s1 += 1;<br>由于 +=是 java 语言规定的运算符，<br>java 编译器会对它进行特殊处理，因此可以正确编译</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 32 - II. 从上到下打印二叉树 II💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/</url>
      
        <content type="html"><![CDATA[<p>剑指 Offer 32 - II. 从上到下打印二叉树 II<br>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();        if(root&#x3D;&#x3D;null)&#123;            return ans;        &#125;        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();        queue.add(root);        while(!queue.isEmpty())&#123;            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();            int size &#x3D; queue.size();            for(int i &#x3D; 0 ;i &lt; size;i++)&#123;                TreeNode node &#x3D; queue.poll();                list.add(node.val);                if(node.left!&#x3D;null)&#123;                    queue.add(node.left);                &#125;                if(node.right!&#x3D;null)&#123;                    queue.add(node.right);                &#125;            &#125;            ans.add(list);        &#125;        return ans;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复杂度分析：<br>时间复杂度 O(N) ： NN 为二叉树的节点数量，即 BFS 需循环 N 次。<br>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，<strong>最多有 N/2 个树节点同时在 queue 中</strong>，使用 O(N) 大小的额外空间。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 32 - I. 从上到下打印二叉树💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/I.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>剑指 Offer 32 - I. 从上到下打印二叉树<br>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回：</p><p>[3,9,20,15,7]</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public int[] levelOrder(TreeNode root) &#123;        List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();        if(root&#x3D;&#x3D;null) return new int[]&#123;&#125;;        queue.add(root);        while(!queue.isEmpty())&#123;            TreeNode node &#x3D; queue.poll();            ans.add(node.val);            if(node.left!&#x3D;null)&#123;                queue.add(node.left);            &#125;            if(node.right!&#x3D;null)&#123;                queue.add(node.right);            &#125;        &#125;        int[] res &#x3D; new int[ans.size()];        for(int i &#x3D; 0 ; i &lt;res.length;i++)&#123;            res[i]&#x3D;ans.get(i);        &#125;        return res;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复杂度分析：<br>时间复杂度 O(N) ： NN 为二叉树的节点数量，即 BFS 需循环 N 次。<br>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，<strong>最多有 N/2 个树节点同时在 queue 中</strong>，使用 O(N) 大小的额外空间。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 32 - II. 从上到下打印二叉树 II💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20III/</url>
      
        <content type="html"><![CDATA[<p>剑指 Offer 32 - III. 从上到下打印二叉树 III<br>请实现一个函数按照<code>之字形</code>顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();        if(root&#x3D;&#x3D;null) return ans;        queue.add(root);        while(!queue.isEmpty())&#123;            LinkedList&lt;Integer&gt; list &#x3D; new LinkedList&lt;&gt;();            int size &#x3D; queue.size();            for(int i &#x3D; 0 ; i &lt;size;i++)&#123;                TreeNode node &#x3D; queue.poll();                if(ans.size()%2&#x3D;&#x3D;0)&#123;                    list.add(node.val);                &#125;else&#123;                    list.addFirst(node.val);                &#125;                if(node.left!&#x3D;null)&#123;                    queue.add(node.left);                &#125;                if(node.right!&#x3D;null)&#123;                    queue.add(node.right);                &#125;            &#125;            ans.add(list);        &#125;        return ans;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复杂度分析：<br>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N)；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1)O(1) 。<br>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 同时 在 deque 中，使用 O(N) 大小的额外空间。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 31. 栈的压入、弹出序列💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>考虑借用一个<strong>辅助栈 stackstack</strong> ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p><p>入栈操作： 按照压栈序列的顺序执行。<br>出栈操作： 每次入栈后，循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立，将<strong>符合弹出序列顺序的栈顶元素<code>全部</code>弹出。</strong></p><h1 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a>剑指 Offer 31. 栈的压入、弹出序列</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p>示例 1：</p><p>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例 2：</p><p>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();        int i &#x3D; 0;        for(int x: pushed)&#123;            stack.push(x);            while(!stack.isEmpty() &amp;&amp; stack.peek()&#x3D;&#x3D;popped[i])&#123;                stack.pop();                i++;            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 27. 二叉树的镜像💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>·两种方法·</strong></p><h2 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a>剑指 Offer 27. 二叉树的镜像</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code> 4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>镜像输出：</p><pre><code> 4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p><p><code>队列</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public TreeNode mirrorTree(TreeNode root) &#123;        if(root&#x3D;&#x3D;null) return root;        LinkedList&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();        queue.add(root);        while(!queue.isEmpty())&#123;            TreeNode node &#x3D; queue.poll();            TreeNode tmp &#x3D; node.left;            node.left &#x3D; node.right;            node.right &#x3D; tmp;            if(node.left!&#x3D;null) queue.add(node.left);            if(node.right!&#x3D;null) queue.add(node.right);        &#125;        return root;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>递归</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(root&#x3D;&#x3D;null) return null;        TreeNode tmp &#x3D; root.left;        root.left &#x3D; root.right;        root.right &#x3D; tmp;        mirrorTree(root.left);        mirrorTree(root.right);        return root;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 30. 包含min函数的栈💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5 align = 'center'><p>只需要设计一个数据结构，<strong>使得每个元素 a 与其相应的最小值 m 时刻保持一一对应</strong>。因此我们可以使用一个辅助栈，<strong>与元素栈同步插入与删除</strong>，用于存储与每个元素对应的最小值。<br>**<br>当一个元素要入栈时<strong>，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，</strong>将这个最小值插入辅助栈**中；</p><p>当一个元素要出栈时，<strong>我们把辅助栈的栈顶元素也一并弹出；</strong></p><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p></font >  <p>剑指 Offer 30. 包含min函数的栈<br>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p><img src =https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif /><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MinStack &#123;    private Stack&lt;Integer&gt; stack;    private Stack&lt;Integer&gt; minStack;    &#x2F;** initialize your data structure here. *&#x2F;    public MinStack() &#123;        stack &#x3D; new Stack&lt;&gt;();        minStack &#x3D; new Stack&lt;&gt;();        minStack.push(Integer.MAX_VALUE);    &#125;        public void push(int x) &#123;        stack.push(x);        minStack.push(Math.min(minStack.peek(),x));    &#125;        public void pop() &#123;        stack.pop();        minStack.pop();    &#125;        public int top() &#123;        return stack.peek();    &#125;        public int getMin() &#123;        return minStack.peek();    &#125;&#125;&#x2F;** * Your MinStack object will be instantiated and called as such: * MinStack obj &#x3D; new MinStack(); * obj.push(x); * obj.pop(); * int param_3 &#x3D; obj.top(); * int param_4 &#x3D; obj.getMin(); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 29. 顺时针打印矩阵💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h2><p><code>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</code></p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p><p>打印方向    1. 根据边界打印    2. 边界向内收缩    3. 是否打印完毕<br>从左向右    左边界l ，右边界 r    上边界 t 加 1    是否 t &gt; b<br>从上向下    上边界 t ，下边界b    右边界 r 减 1    是否 l &gt; r<br>从右向左    右边界 r ，左边界l    下边界 b 减 1    是否 t &gt; b<br>从下向上    下边界 b ，上边界t    左边界 l 加 1    是否 l &gt; r</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] spiralOrder(int[][] matrix) &#123;        if(matrix.length&#x3D;&#x3D;0||matrix&#x3D;&#x3D;null) return new int[]&#123;&#125;;        int[] ans &#x3D; new int[matrix.length*matrix[0].length];        int count &#x3D; 0 ;        int left &#x3D; 0 , right &#x3D; matrix[0].length-1,top&#x3D;0,bottom &#x3D; matrix.length-1;        while(true)&#123;            for(int i &#x3D; left ; i &lt;&#x3D; right;i++)&#123;                ans[count++] &#x3D; matrix[top][i];            &#125;            if(++top&gt;bottom) break;            for(int i&#x3D; top;i&lt;&#x3D;bottom;i++)&#123;                ans[count++] &#x3D; matrix[i][right];            &#125;            if(--right&lt;left) break;            for(int i &#x3D; right;i&gt;&#x3D;left;i--)&#123;                ans[count++] &#x3D; matrix[bottom][i];            &#125;            if(--bottom&lt;top) break;            for(int i &#x3D; bottom;i&gt;&#x3D;top;i--)&#123;                ans[count++] &#x3D; matrix[i][left];            &#125;            if(++left&gt;right) break;        &#125;        return ans;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 26. 树的子结构💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5 align = 'center'><p><strong>解题思路：</strong><br>若树 B 是树 A 的子结构，<code>则子结构的根节点可能为树 A 的任意一个节点</code>。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p><ol><li><code>先序遍历树 A 中的每个节点</code> （对应函数 isSubStructure(A, B)）</li><li>判断树 A 中 以 A为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）</font >  </li></ol><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isSubStructure(TreeNode A, TreeNode B) &#123;    &#x2F;&#x2F;由题可知，空树并不是任何树的子结构    if(A&#x3D;&#x3D;null||B&#x3D;&#x3D;null) return false;    &#x2F;&#x2F;判断B是否是A的子结构，则要判断B是不是A中任意一个节点的子结构；则遍历A    return recur(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B);&#125;&#x2F;&#x2F;判断A是否是B的子结构private boolean recur(TreeNode A, TreeNode B)&#123;    if(B&#x3D;&#x3D;null) return true;    if(A&#x3D;&#x3D;null||A.val!&#x3D;B.val) return false;    return  recur(A.left,B.left)&amp;&amp;recur(A.right,B.right);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 25. 合并两个排序的链表💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5 align = 'center'><p>哑节点思想的学习</p></font >  ---<h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h2><p><code>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</code></p><p>示例1：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        if(l1&#x3D;&#x3D;null) return l2;        if(l2&#x3D;&#x3D;null) return l1;        ListNode dummy &#x3D; new ListNode(-1);        ListNode cur &#x3D; dummy;        while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null)&#123;            if(l1.val&lt;&#x3D;l2.val)&#123;                cur.next &#x3D; l1;                l1 &#x3D; l1.next;            &#125;else&#123;                cur.next &#x3D; l2;                l2&#x3D; l2.next;            &#125;            cur&#x3D; cur.next;        &#125;        cur.next&#x3D;(l1&#x3D;&#x3D;null)?l2:l1;        return dummy.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度 O(M+N)： M, NM,N 分别为链表的长度，合并操作需遍历两链表。<br>空间复杂度 O(1) ： 节点引用 dum , cur 使用常数大小的额外空间。。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 24. 反转链表💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5 align = 'center'><p>双指针思想的学习</p></font >  ---<h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><p><code>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</code><br>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><img src=https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif  /><p>定义两个指针： pre 和 cur ；pre 在前 cur 在后。<br>每次让 pre 的 next 指向 cur ，实现一次局部反转<br>局部反转完成之后， pre 和 cur 同时往前移动一个位置<br>循环上述过程，直至 pre 到达链表尾部</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if(head&#x3D;&#x3D;null) return null;        ListNode pre&#x3D; null;        ListNode cur &#x3D; head;        while(cur!&#x3D;null)&#123;            ListNode tmp &#x3D; cur.next;            cur.next &#x3D; pre ;            pre &#x3D; cur;            cur &#x3D; tmp;        &#125;        return pre ;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 28. 对称的二叉树💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5 align = 'center'><p>判断二叉树是否是对称，需要从子节点开始比较，两个子节点的值必须相同，并且左子节点的右子节点（如果有）必须等于右子节点的左子节点，左子节点的左子节点必须等于右子节点的右子节点。</p><p>～～～<br></font >  </p><hr><h2 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a>剑指 Offer 28. 对称的二叉树</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>1</code></pre><p>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>1</code></pre><p>   / <br>  2   2<br>   \   <br>   3    3<br><strong>两种方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        if(root&#x3D;&#x3D; null) return true;        LinkedList&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;();        queue.add(root.left);        queue.add(root.right);        while(!queue.isEmpty())&#123;            TreeNode L &#x3D; queue.poll();            TreeNode R &#x3D; queue.poll();            if(L&#x3D;&#x3D;null&amp;&amp;R&#x3D;&#x3D;null) continue;            if(L&#x3D;&#x3D;null||R&#x3D;&#x3D;null||L.val!&#x3D;R.val) return false;            queue.add(L.left);            queue.add(R.right);            queue.add(L.right);            queue.add(R.left);        &#125;        return true;    &#x2F;&#x2F;     return root&#x3D;&#x3D;null? true: recur(root.left,root.right);    &#x2F;&#x2F; &#125;    &#x2F;&#x2F; boolean recur(TreeNode L, TreeNode R) &#123;    &#x2F;&#x2F;     if(L &#x3D;&#x3D; null &amp;&amp; R &#x3D;&#x3D; null) return true;    &#x2F;&#x2F;     if(L &#x3D;&#x3D; null || R &#x3D;&#x3D; null || L.val !&#x3D; R.val) return false;    &#x2F;&#x2F;     return recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);    &#x2F;&#x2F; &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 22. 链表中倒数第k个节点💗</title>
      <link href="2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>2021/02/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5 align = 'center'><p>  啦啦啦啦啦啦啦啦啦   </p><p>快慢指针思想的学习<br>学以致用</p><p>～～～<br></font >  </p><hr><h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h2><p><code>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</code></p><p><code>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 2 个节点是值为 4 的节点。</code></p><p><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5.</code><br><strong>算法流程：</strong><br>初始化： 前指针 former 、后指针 latter ，<strong>双指针都指向头节点 head​</strong> 。<br>构建双指针距离： 前指针 former 先向前走 k 步（结束后，<strong>双指针 former 和 latter 间相距 k 步</strong>）。<br><strong>双指针共同移动</strong>： 循环中，双指针 former 和 latter 每轮都向前走一步，直至 former 走过链表 尾节点时跳出（<strong>跳出后， latter 与尾节点距离为 k-1</strong>，即 latter 指向倒数第 k 个节点）。<br>返回值： <strong>返回 latter</strong> 即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode getKthFromEnd(ListNode head, int k) &#123;        ListNode former &#x3D; head, latter &#x3D; head;        for(int i &#x3D; 0; i &lt; k; i++)            former &#x3D; former.next;        while(former !&#x3D; null) &#123;            former &#x3D; former.next;            latter &#x3D; latter.next;        &#125;        return latter;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果有 k 大于链表长度的 case</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode getKthFromEnd(ListNode head, int k) &#123;        ListNode former &#x3D; head, latter &#x3D; head;        for(int i &#x3D; 0; i &lt; k; i++) &#123;            if(former &#x3D;&#x3D; null) return null;            former &#x3D; former.next;        &#125;        while(former !&#x3D; null) &#123;            former &#x3D; former.next;            latter &#x3D; latter.next;        &#125;        return latter;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数相加-双指针模拟加法</title>
      <link href="2021/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>2021/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p><code>牛客网 大数加法</code></p><p><code>415. 字符串相加</code><br>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><p>提示：</p><p>num1 和num2 的长度都小于 5100<br>num1 和num2 都只包含数字 0-9<br>num1 和num2 都不包含任何前导零<br>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式<br><code>只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 1010，则向高位进一位 </code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public String addStrings(String num1, String num2) &#123;        &#x2F;&#x2F;双指针        StringBuffer sb &#x3D; new StringBuffer();        int i &#x3D; num1.length()-1,j &#x3D;  num2.length()-1;        int carry&#x3D;0;        while(i&gt;&#x3D;0|| j &gt;&#x3D;0)&#123;            int a &#x3D; i&gt;&#x3D;0?num1.charAt(i)-&#39;0&#39;:0;            int b &#x3D; j&gt;&#x3D;0?num2.charAt(j)-&#39;0&#39;:0;            int tmp &#x3D; a+b+carry;            carry&#x3D;tmp&#x2F;10;            sb.append(tmp%10);            i--;            j--;        &#125;        if(carry&#x3D;&#x3D;1) sb.append(1);        return sb.reverse().toString();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复杂度分析：</p><p>时间复杂度 O(max(M,N))：其中 M，N 为 2 数字长度，按位遍历一遍数字（以较长的数字为准）；<br>空间复杂度 O(1)：指针与变量使用常数大小空间。</p>]]></content>
      
      
      <categories>
          
          <category> leedcode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leedcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理-页面置换算法"><a href="#内存管理-页面置换算法" class="headerlink" title="内存管理-页面置换算法"></a>内存管理-页面置换算法</h1><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ol><li><p>OPT ⻚⾯置换算法（最佳⻚⾯置换算法） ：<br>最佳(Optimal, OPT)置换算法所选择的<code>被淘汰⻚⾯将是以后永不使⽤的</code>，<br><code>或者是在最⻓时间内不再被访问的⻚⾯</code>,这样可以保证获得最低的缺⻚率。<br>但由于⼈们⽬前<code>⽆法预知进程在内存下的若千⻚⾯中哪个是未来最⻓时间内不再被访问的</code>，<br>因⽽该算法<code>⽆法实现</code>。⼀般作为衡量其他置换算法的⽅法。</p></li><li><p>FIFO（First In First Out） ⻚⾯置换算法（先进先出⻚⾯置换算法） : </p><p>总是淘汰最先进⼊内存的⻚⾯，即选择在内存中驻留时间最久的⻚⾯进⾏淘汰。</p></li><li><p>LRU （Least Currently Used）⻚⾯置换算法（最近最久未使⽤⻚⾯置换算法） ： </p><p>LRU算法赋予每个⻚⾯⼀个访问字段，⽤来记录⼀个⻚⾯⾃上次被访问以来所经历的时间 T，<br>当须淘汰⼀个⻚⾯时，选择现有⻚⾯中其 T 值最⼤的，即最近最久未使⽤的⻚⾯予以淘汰。</p></li><li><p>LFU （Least Frequently Used）⻚⾯置换算法（最少使⽤⻚⾯置换算法） : </p><p>该置换算法选择在之前时期使⽤最少的⻚⾯作为淘汰⻚。</p></li></ol><h2 id="⻚⾯置换算法的作⽤"><a href="#⻚⾯置换算法的作⽤" class="headerlink" title="⻚⾯置换算法的作⽤?"></a>⻚⾯置换算法的作⽤?</h2><p>地址映射过程中，<code>若在⻚⾯中发现所要访问的⻚⾯不在内存中</code>，则发⽣缺⻚中断。<br>缺⻚中断 就是要访问的⻚不在主存，需要操作系统将其调⼊主存后再进⾏访问。 在这个时候，被<br>内存映射的⽂件实际上成了⼀个分⻚交换⽂件。<br>当发⽣<code>缺⻚中断</code>时，<code>如果当前内存中并没有空闲的⻚⾯</code>，操作系统就必须在内存<code>选择⼀个⻚⾯将其移出 内存</code>，以便为即将调⼊的⻚⾯让出空间。⽤来选择<code>淘汰哪⼀⻚的规则</code>叫做⻚⾯置换算法，我们可以把⻚<br>⾯置换算法看成是淘汰⻚⾯的规则。</p><h2 id="手写LRU缓存"><a href="#手写LRU缓存" class="headerlink" title="手写LRU缓存"></a>手写LRU缓存</h2><p>主要思路就是</p><p>1.可以使用最基础的单向链表处理<br>2.使用双向链表,可以加入hash表做优化<br>3.最简单的实现是使用JDK中自带的LinkedHashMap,<br>  需要重写removeEldestEntry()方法,<br>  这是LinkedHashMap提供的一个删除最老条目的方法;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package 高频题;import java.util.*;public class LRUCache &#123;    private Map&lt;Integer, Node&gt; map;    private int capacity;    &#x2F;&#x2F; 虚拟头结点    private Node first;    &#x2F;&#x2F; 虚拟尾结点    private Node last;    public LRUCache(int capacity) &#123;        map &#x3D; new HashMap&lt;&gt;(capacity);        this.capacity &#x3D; capacity;        first &#x3D; new Node();        last &#x3D; new Node();        first.next &#x3D; last;        last.prev &#x3D; first;    &#125;    public int get(int key) &#123;        Node node &#x3D; map.get(key);        if (node &#x3D;&#x3D; null) return -1;        removeNode(node);        addAfterFirst(node);        return node.value;    &#125;    &#x2F;**     * @param node 将node节点插入到first节点的后面     *&#x2F;    private void addAfterFirst(Node node) &#123;        &#x2F;&#x2F; node与first.next        node.next &#x3D; first.next;        first.next.prev &#x3D; node;        &#x2F;&#x2F; node与first        first.next &#x3D; node;        node.prev &#x3D; first;    &#125;    &#x2F;**     * @param node 从双向链表中删除node节点     *&#x2F;    private void removeNode(Node node) &#123;        node.next.prev &#x3D; node.prev;        node.prev.next &#x3D; node.next;    &#125;    public void put(int key, int value) &#123;        Node node &#x3D; map.get(key);        if (node !&#x3D; null) &#123;            node.value &#x3D; value;            removeNode(node);        &#125; else &#123; &#x2F;&#x2F; 添加一对新的key-value            if (map.size() &#x3D;&#x3D; capacity) &#123;                &#x2F;&#x2F; 淘汰最近最少使用的node\                removeNode(map.remove(last.prev.key));&#x2F;&#x2F;                map.remove(last.prev.key);&#x2F;&#x2F;                removeNode(last.prev);            &#125;            map.put(key, node &#x3D; new Node(key, value));        &#125;        addAfterFirst(node);    &#125;    private static class Node &#123;        public int key;        public int value;        public Node prev;        public Node next;        public Node(int key, int value) &#123;            this.key &#x3D; key;            this.value &#x3D; value;        &#125;        public Node() &#123;&#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP粘包</title>
      <link href="2021/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%B2%98%E5%8C%85/"/>
      <url>2021/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%B2%98%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<font color = gold size =5><p>学习笔记：总结<br>看<a href="https://network.51cto.com/art/201910/604760.htm">https://network.51cto.com/art/201910/604760.htm</a><br></font></p><h2 id="什么是TCP粘包？"><a href="#什么是TCP粘包？" class="headerlink" title="什么是TCP粘包？"></a>什么是TCP粘包？</h2><p><code>TCP粘包</code>就是指发送方发送的若干包数据到达接收方时粘成了一包，<br><code>从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，</code><br>例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，<br>在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束<br><strong>所谓粘包问题主要还是</strong><code>因为接收方不知道消息之间的界限</code>，<code>不知道一次性提取多少字节的数据所造成</code>的。</p><h2 id="粘包的原因"><a href="#粘包的原因" class="headerlink" title="粘包的原因"></a>粘包的原因</h2><ol><li>发送方原因<br>TCP默认使用Nagle算法（主要作用：会将数据量小的，且时间间隔较短的数据一次性发给对方），<br>而Nagle算法主要做两件事：<br>只有上一个分组得到确认，才会发送下一个分组<br>收集多个小分组，在一个确认到来时一起发送<br>Nagle算法造成了发送方可能会出现粘包问题</li><li>接收方原因<br>TCP接收到数据包时，并不会马上交到应用层进行处理，<br>或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，<br>然后应用程序主动从缓存读取收到的分组。<br>这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，<br>多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li></ol><h2 id="粘包解决方案"><a href="#粘包解决方案" class="headerlink" title="粘包解决方案"></a>粘包解决方案</h2><p> <code>固定长度</code></p><p>这种方式下，消息边界也就是固定长度即可。</p><p>优点就是实现很简单，缺点就是<code>空间有极大的浪费</code>，如果传递的消息中大部分都比较<code>短</code>，这样就会有很多空间是浪费的。</p><p>因此，这种方式一般也是不推荐的。</p><p> <code>分隔符</code></p><p>这种方式下，消息边界也就是分隔符本身。</p><p>优点是空间不再浪费，实现也比较简单。缺点是当内容本身出现分割符时<code>需要转义</code>，所以无论是发送还是接受，都需要<code>进行整个内容的扫描</code>。</p><p>因此，这种方式效率也不是很高，但可以尝试使用。</p><p> <code>专门的 length 字段</code></p><p>这种方式，就有点类似<code> Http 请求中的 Content-Length</code>，有一个专门的字段存储消息的长度。作为<code>服务端</code>，接受消息时，<code>先解析固定长度的字段(length字段)获取消息总长度</code>，<code>然后读取后续内容</code>。</p><p>优点是精确定位用户数据，内容也不用转义。缺点是长度理论上有限制，需要提前限制可能的最大长度从而定义长度占用字节数。</p><p>因此，<code>十分推介用这种方式</code>。</p><h2 id="6-4：UDP会不会产生粘包问题呢？"><a href="#6-4：UDP会不会产生粘包问题呢？" class="headerlink" title="6-4：UDP会不会产生粘包问题呢？"></a>6-4：UDP会不会产生粘包问题呢？</h2><p><strong>UDP不会发生粘包拆包现象</strong><br><code>UDP则是面向消息传输的，是有保护消息边界的，</code><br><code>接收方一次只接受一条独立的信息</code>，所以不存在粘包问题。<br>保护消息边界：指传输协议把<code>数据当做一条独立的消息</code>在网上传输，<br><code>接收端一次只能接受一条独立的消息</code><br>比如说，有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，<br><code>不管接受方的接收缓存有多大</code>，我们必须要进行至少三次以上的发送才能把数据包发送完，<br>但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，<br>就可以一次把这3个数据包全部发送完毕。</p>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP基础知识</title>
      <link href="2021/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/"/>
      <url>2021/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/</url>
      
        <content type="html"><![CDATA[<font color = gold size =5 align = center><p>学习笔记：总结</p></font><h1 id="各种协议的端口号"><a href="#各种协议的端口号" class="headerlink" title="各种协议的端口号"></a>各种协议的端口号</h1><p><strong><code>TCP对应的协议：</code></strong></p><p><code>FTP</code>：定义了文件传输协议，使用<code>21端口</code>。<br><code>Telnet</code>：一种用于远程登陆的端口，使用<code>23端口</code>，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br><code>SMTP</code>：邮件传送协议，用于<code>发送邮件</code>。服务器开放的是<code>25号</code>端口。<br><code>POP3</code>：它是和SMTP对应，POP3用于<code>接收邮件</code>。POP3协议所用的是<code>110端口</code>。<br><code>HTTP</code>：是从Web服务器传输超文本到本地浏览器的传送协议，端口默认<code>80</code>。</p><p><strong><code>UDP对应的协议：</code></strong></p><p><code>DNS</code>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</p><p><code>IP地址</code>由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p>先回忆下A，B，C，D类地址吧：</p><p>　　A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(modified @2016.05.31)</p><p>　　B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>　　C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>　　D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>　　E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>　　注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p><code>A、B、C类私有地址</code></p><p>　　私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>　　A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p><p>　　B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>　　C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><p><code>子网掩码及网络划分</code><br>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p><p>　　这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p>　　什么是子网掩码？</p><p>　　子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</p>]]></content>
      
      
      <categories>
          
          <category> IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP缓存处理流程</title>
      <link href="2021/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BC%93%E5%AD%98/"/>
      <url>2021/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<font color=pink>https://www.bilibili.com/video/BV1Ba4y177Sj?from=search&seid=17312067645190647720https://www.bilibili.com/video/BV1js411g7Fw?p=7</font>  <p><a href="https://blog.csdn.net/weixin_39527768/article/details/112572691?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/weixin_39527768/article/details/112572691?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-3&amp;spm=1001.2101.3001.4242</a><br>看这篇文章</p><p>协商缓存<br>协商缓存一代：last-modified + if-modified-since。简要来说，就是服务器会检查文件的更新时间是否发生了变化来确定是否可以使用缓存在客户端的文件。<br>服务端给客户端响应的时候会带着last-modified（上次修改时间），当客户端再次发起请求的时候，会携带着if-modified-since，服务端会检查上一次修改时间与当前服务器的文件修改时间是否一致，如果一致表示文件没有被修改。所以直接返回304的http状态，304意思就是告知客户端文件没有变更，请直接使用缓存文件。<br>协商缓存二代： Etag + if-none-match. 文件摘要MD5的方式保证一致性。协商缓存一代可能存在文件时间发生变更并非意味着文件发生改变这种情况。而使用文件摘要的方式来保证只有在文件真正发生变更才会重新下载，否则仍然是返回304。<br><img src="expires.png"><br><img src="cache-control.png"><br><img src="cache.png"><br><img src="304.png"></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要使用HTTPS</title>
      <link href="2021/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/"/>
      <url>2021/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/</url>
      
        <content type="html"><![CDATA[<font color = gold size =5>接着上次做笔记学习笔记：总结看bilibili方老师的课程计算机网络以及小林公众号的总结</font><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h2><p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版</p><h2 id="HTTPS-解决了-HTTP-的哪些问题？（为什么要HTTPS）"><a href="#HTTPS-解决了-HTTP-的哪些问题？（为什么要HTTPS）" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？（为什么要HTTPS）"></a>HTTPS 解决了 HTTP 的哪些问题？（为什么要HTTPS）</h2><p>HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：</p><ol><li>窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没。</li><li>篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。</li><li>冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。<br>HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了上述的⻛险：</li><li>混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。<br>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：<br>在通信建立 前 采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密；<br>在通信过程中 全部使用对称加密的「会话秘钥」的方式加密明文数据。<br>采用「混合加密」的方式的原因：<br>   对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。<br>   非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li><li>摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，<br>指纹⽤于校验数据的完整性，解决了篡改的⻛险。<br>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，<br>发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，<br>服务器解密后，用相同的摘要算法算出发送过来的明文，<br>通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，<br>若「指纹」相同，说明数据是完整的。</li><li>将服务器公钥放⼊到数字证书中，解决了冒充的⻛险。</li></ol><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><ol><li><p>对称加密：密钥只有⼀个，加密解密为同⼀个密码，且加解密速度快，典型的对称加密，算法有DES、 AES等；</p><ul><li>优点：算法公开、计算量小、加密速度快、加密效率高，适合加密比较大的数据。</li><li>缺点：<pre><code> 交易双方需要使用相同的密钥，也就无法避免密钥的传输， 而密钥在传输过程中无法保证不被截获，因此对称加密的安全性得不到保证。 每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥， 这会使得发收信双方所拥有的钥匙数量急剧增长，密钥管理成为双方的负担。 对称加密算法在分布式网络系统上使用较为困难， 主要是因为密钥管理困难，使用成本较高。</code></pre></li></ul></li><li><p>⾮对称加密：密钥成对出现（且根据公钥⽆法推知私钥，根据私钥也⽆法推知公钥），</p><pre><code>        加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），        相对对称加密速度较慢，典型的⾮对称加密算法有RSA、 DSA等。</code></pre><ul><li>优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。</li><li>缺点：计算量比较大，加密和解密速度相比对称加密慢很多。</li></ul></li></ol><h4 id="Https对称加解密的过程"><a href="#Https对称加解密的过程" class="headerlink" title="Https对称加解密的过程"></a>Https对称加解密的过程</h4><p>发送端和接收端首先要共享相同的密钥k<br>即通信前双方都需要知道对应的密钥才能进行通信。<br>发送端用共享密钥k对明文p进行加密，得到密文c，<br>并将得到的密文发送给接收端，接收端收到密文后，<br>并用其相同的共享密钥k对密文进行解密，得出明文p。</p><h4 id="Https非对称加密过程"><a href="#Https非对称加密过程" class="headerlink" title="Https非对称加密过程"></a>Https非对称加密过程</h4><p>加密一方找到接收方的公钥e，<br>大部分的公钥查找工作实际上都是通过数字证书来实现的，<br>然后用公钥e对明文p进行加密后得到密文c，<br>并将得到的密文发送给接收方，接收方收到密文后，<br>用自己保留的私钥d进行解密，得到明文p，<br>用公钥加密的密文，只有拥有私钥的一方才能解密，<br>这样就可以解决加密的各方可以统一使用一个公钥即可。</p><h3 id="数字证书认证机构的流程"><a href="#数字证书认证机构的流程" class="headerlink" title="数字证书认证机构的流程"></a>数字证书认证机构的流程</h3><ol><li>服务器的运营人员向第三方机构CA提交<br>公钥、组织信息、个人信息(域名)等信息并申请认证;</li><li>CA通过线上、线下等多种手段验证申请者提供信息的真实性，<br>如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li><li>如信息审核通过，CA会向申请者签发认证文件-证书。<br>证书包含以下信息：申请者公钥、申请者的组织信息<br>和个人信息、签发机构 CA的信息、有效时间、证书序列号<br>等信息的明文，同时包含一个签名。<br>其中签名的产生算法：<br>首先，使用散列函数计算公开的明文信息的信息摘要，<br><strong>然后，采用 CA的私钥对信息摘要进行加密，密文即签名;</strong></li><li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li><li>客户端 Client 读取证书中的相关的明文信息，<br>采用相同的散列函数计算得到信息摘要，<br>然后，利用对应 CA的公钥解密签名数据，<br>对比证书的信息摘要，<br>如果一致，则可以确认证书的合法性，<br>即服务器的公开密钥是值得信赖的。</li><li>客户端还会验证证书相关的域名信息、有效时间等信息;<br>客户端会内置信任CA的证书信息(包含公钥)，<br>如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</li></ol><h2 id="HTTP与HTTPS建立请求过程"><a href="#HTTP与HTTPS建立请求过程" class="headerlink" title="HTTP与HTTPS建立请求过程"></a>HTTP与HTTPS建立请求过程</h2><h3 id="HTTP-请求过程"><a href="#HTTP-请求过程" class="headerlink" title="HTTP 请求过程"></a>HTTP 请求过程</h3><ol><li>建立连接完毕以后客户端会发送响应给服务端</li><li>服务端接受请求并且做出响应发送给客户端</li><li>客户端收到响应并且解析响应响应给客户</li></ol><h3 id="HTTPS-请求过程（加密过程）"><a href="#HTTPS-请求过程（加密过程）" class="headerlink" title="HTTPS 请求过程（加密过程）"></a>HTTPS 请求过程（加密过程）</h3><ol><li>Client发起一个HTTPS<br>比如一个https网址<br>的请求，根据相关规定，<br>Client知道需要连接Server的443（默认）端口。</li><li>Server把事先配置好的<br>公钥证书返回给客户端。</li><li>Client验证公钥证书：比如是否在有效期内，<br>证书的用途是不是匹配Client请求的站点，<br>是不是在CRL吊销列表里面，<br>它的上一级证书是否有效，<br>这是一个递归的过程，<br>直到验证到根证书<br>操作系统内置的Root证书或者Client内置的Root证书）<br>如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器<br>生成加密所使用的对称密钥，<br>然后用证书的公钥加密这个对称密钥，<br>发给Server。</li><li>Server使用自己的私钥解密这个消息，<br>得到对称密钥。<br>至此，Client和Server双方都持有了相同的对称密钥。</li><li>Server使用对称密钥加密“明文内容A”，发送给Client。</li><li>Client使用对称密钥解密响应的密文，得到“明文内容A”。</li><li>Client再次发起HTTPS的请求，<br>使用对称密钥加密请求的“明文内容B”，<br>然后Server使用对称密钥解密密文，得到“明文内容B”。</li></ol><h4 id="SSL-TLS握⼿"><a href="#SSL-TLS握⼿" class="headerlink" title="SSL/TLS握⼿"></a>SSL/TLS握⼿</h4><ol><li>ClientHello<br>ClientHello 请求。<br>在这⼀步，客户端主要向服务器发送以下信息：<br>（1）客户端⽀持的 SSL/TLS 协议版本。<br>（2）客户端⽣产用于「会话秘钥」的随机数。<br>（3）客户端⽀持的密码套件列表。</li><li>SeverHello<br>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：<br>（1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。<br>（2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br>（4）服务器的数字证书。</li><li>客户端回应<br>客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，<br>确认服务器的数字证书的真实性。<br>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，<br>然后使⽤它加密报⽂，向服务器发送如下信息：<br>（1）⼀个随机数（ pre-master key ）<br>（2）加密通信算法改变通知<br>（3）客户端握⼿结束通知</li><li>服务器的最后回应<br>服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，<br>计算出本次通信的「会话秘钥」。然后，向客户端发⽣最后的信息：<br>（1）加密通信算法改变通知。<br>（2）服务器握⼿结束通知。</li></ol><h3 id="HTTP与HTTPS区别"><a href="#HTTP与HTTPS区别" class="headerlink" title="HTTP与HTTPS区别"></a>HTTP与HTTPS区别</h3><ol><li>HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。<br>HTTPS 则解决 HTTP 不安全的缺陷，<br>在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。</li><li>HTTP 连接建⽴相对简单，TCP 三次握⼿之后便可进⾏HTTP的报⽂传输。<br>⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏SSL/TLS的握⼿过程，才可进⼊加密报⽂传输。</li><li>HTTP 的端⼝号是 80， HTTPS 的端⼝号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ol><h3 id="为何不所有的网站都使用HTTPS"><a href="#为何不所有的网站都使用HTTPS" class="headerlink" title="为何不所有的网站都使用HTTPS"></a>为何不所有的网站都使用HTTPS</h3><ol><li>首先，需要权威CA颁发的SSL证书。<br>从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。</li><li>其次，HTTPS普遍认为性能消耗要大于HTTP，<br>因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。<br>如果每次通信都加密，会消耗相当多的资源，<br>平摊到一台计算机上时，<br>能够处理的请求数量必定也会随之减少。<br>但事实并非如此，<br>用户可以通过性能优化、把证书部署在SLB或CDN，<br>来解决此问题。</li><li>除此之外，想要节约购买证书的开销也是原因之一。<br>要进行HTTPS通信，证书是必不可少的。<br>而使用的证书必须向认证机构（CA）购买。</li></ol>]]></content>
      
      
      <categories>
          
          <category> HTTPS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP可靠连接</title>
      <link href="2021/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8F%AF%E9%9D%A0/"/>
      <url>2021/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8F%AF%E9%9D%A0/</url>
      
        <content type="html"><![CDATA[<font color = gold size =5>接着上次做笔记学习笔记：总结看bilibili方老师的课程计算机网络以及小林公众号的总结</font><h1 id="如何做可靠传输"><a href="#如何做可靠传输" class="headerlink" title="如何做可靠传输"></a>如何做可靠传输</h1><p>1、超时重传</p><p>2、有序接受</p><p>3、应答确认</p><p>4、滑动窗口流量控制</p><h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><p> <code>解决在网络传输过程中数据包丢失的情况 </code></p><h2 id="常见的重传机制"><a href="#常见的重传机制" class="headerlink" title="常见的重传机制"></a>常见的重传机制</h2><pre><code>  1. 超时重传  2. 快速重传  3. SACK</code></pre><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>在发送数据时，设定一个定时器，当超过指定的时间后，<br>没有收到对方的 ACK 确认应答报文，就会重发该数据。</p><p><code>什么时候会发生超时重传</code></p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p><code>超时重传存在的问题</code></p><p>如果超时重发的数据，再次超时的时候，又需要重传的时候，<br>TCP 的策略是<code>超时间隔加倍</code>。这样超时周期可能相对较长</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>它不以时间为驱动，而是以数据驱动重传</p><p>比如说，发送方发出了 1，2，3，4，5 份数据：</p><p>第一份 Seq1 先送到了，于是就 Ack 回 2；<br>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；<br>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；<br>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。<br>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</p><p>所以说，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段<br><code>快速重传的问题</code></p><p>快速重传机制只解决了一个问题，就是超时时间的问题，<br>但是它依然面临着另外一个问题。就是重传的时候，<br>是重传之前的一个，还是重传所有的问题。</p><h2 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h2><p>这种方式需要在 <code>TCP 头部「选项」字段</code>里加一个<code>SACK</code>的东西，<br>它可以将缓存的地图发送给发送方，<code>这样发送方就可以知道哪些数据收到了</code>，<br><code>哪些数据没收到</code>，知道了这些信息，<code>就可以只重传丢失的数据。</code><br>比如说发送方收到了三次同样的 ACK 确认报文，<br>于是就会触发快速重发机制，<br>通过 SACK 信息发现只有某段数据丢失，<br>则重发时，就只选择了这个 TCP 段进行重复。</p><h1 id="滑动窗口与流量控制"><a href="#滑动窗口与流量控制" class="headerlink" title="滑动窗口与流量控制"></a>滑动窗口与流量控制</h1><h2 id="引入窗口概念的原因"><a href="#引入窗口概念的原因" class="headerlink" title="引入窗口概念的原因"></a>引入窗口概念的原因</h2><p>TCP 是每发送一个数据，都要进行一次确认应答。<br>当上一个数据包收到了应答了，<br>再发送下一个，效率比较低，如果数据包的往返时间越长，通信的效率就越低<br><code>什么是窗口</code></p><p>在往返时间较长的情况下，它也不会降低网络通信的效率，这个就是窗口<br>窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值<br>窗口的实现实际上是操作系统开辟的一个缓存空间，<br>发送方主机在等到确认应答返回之前，<br>必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据<br>就可以从缓存区清除。<br>比如说ACK 100 确认应答报文丢失，也没关系，<br>因为可以通过下一个确认应答进行确认，<br>只要发送方收到了 ACK 200 确认应答，<br>就意味着 200 之前的所有数据「接收方」都收到了。</p><p><code>窗口大小由哪一方决定？</code></p><p>通常窗口的大小是由接收方的窗口大小Window来决定的</p><p>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<br>于是发送端就可以根据这个接收端的处理能力来发送数据，<br>而不会导致接收端处理不过来。<br>发送方发送的数据大小不能超过接收方的窗口接收数据大小，<br>否则接收方就无法正常接收到数据。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>如果一直发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。为了解决这种现象发生，TCP 提供一种机制可以「发<br>送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p><h2 id="TCP-是如何解决窗口关闭时，潜在的死锁现象呢？"><a href="#TCP-是如何解决窗口关闭时，潜在的死锁现象呢？" class="headerlink" title="TCP 是如何解决窗口关闭时，潜在的死锁现象呢？"></a>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</h2><p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<br>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。<br>如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，<br>而对方在确认这个探测报文时，给出自己现在的接收窗口大小。<br>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；<br>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="为什么要有拥塞控制呀，不是有流量控制了吗？"><a href="#为什么要有拥塞控制呀，不是有流量控制了吗？" class="headerlink" title="为什么要有拥塞控制呀，不是有流量控制了吗？"></a>为什么要有拥塞控制呀，不是有流量控制了吗？</h2><p>流量控制是避免「发送方」的数据填满「接收方」的缓存，<br>但是并不知道网络的中发生了什么<br>在网络出现拥堵时，如果继续发送大量数据包，<br>可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，<br>但是一重传就会导致网络的负担更重，<br>于是会导致更大的延迟以及更多的丢包，<br>这个情况就会进入恶性循环被不断地放大<br>为了避免「发送方」的数据填满整个网络，有了拥塞控制</p><h2 id="23-2：什么是拥塞控制"><a href="#23-2：什么是拥塞控制" class="headerlink" title="23-2：什么是拥塞控制"></a>23-2：什么是拥塞控制</h2><p>在某段时间，若对⽹络中某⼀资源的需求超过了该资源所能提供的可⽤部分，<br>⽹络的性能就要变坏。这种情况就叫拥塞。<br>拥塞控制就是为了防⽌过多的数据注⼊到⽹络中，<br>这样就可以使⽹络中的路由器或链路不致过载。<br>拥塞控制所要做的都有⼀个前提，就是⽹络能够承受现有的⽹络负荷。</p><h2 id="23-3：什么是拥塞窗口？和发送窗口有什么关系呢？"><a href="#23-3：什么是拥塞窗口？和发送窗口有什么关系呢？" class="headerlink" title="23-3：什么是拥塞窗口？和发送窗口有什么关系呢？"></a>23-3：什么是拥塞窗口？和发送窗口有什么关系呢？</h2><p>拥塞窗口是发送方维护的一个的状态变量，<br>它会根据网络的拥塞程度动态变化的。<br>发送窗口和接收窗口是约等于的关系，<br>那么由于加入了拥塞窗口的概念后，<br>此时发送窗口的值是是拥塞窗口和接收窗口中的最小值。<br>拥塞窗口 cwnd 变化的规则：<br>只要网络中没有出现拥塞， cwnd 就会增大；<br>但网络中出现了拥塞， cwnd 就减少；</p><h2 id="23-4：那么怎么知道当前网络是否出现了拥塞呢？"><a href="#23-4：那么怎么知道当前网络是否出现了拥塞呢？" class="headerlink" title="23-4：那么怎么知道当前网络是否出现了拥塞呢？"></a>23-4：那么怎么知道当前网络是否出现了拥塞呢？</h2><p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了用拥塞。</p><h2 id="23-5：拥塞控制算法"><a href="#23-5：拥塞控制算法" class="headerlink" title="23-5：拥塞控制算法"></a>23-5：拥塞控制算法</h2><p>TCP的拥塞控制采⽤了四种算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><ol><li>慢开始： 当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1</li><li>拥塞避免： 每当收到一个 ACK 时，cwnd 增加 1/cwnd.</li><li>拥塞发生算法：</li><li>快重传与快恢复： 它能快速恢复丢失的数据包。<pre><code>             没有 FRR，如果数据包丢失了，              TCP 将会使⽤定时器来要求传输暂停。             在暂停的这段时间内，没有新的或复制的数据包被发送。             有了 FRR，如果接收机接收到⼀个不按顺序的数据段，             它会⽴即给发送机发送⼀个重复确认。             如果发送机接收到三个重复确认，             它会假定确认件指出的数据段丢失了，             并⽴即重传这些丢失的数据段。             有了FRR，就不会因为重传时要求的暂停被耽误。             当有单独的数据包丢失时，             快速重传和恢复（FRR）能最有效地⼯作。             当有多个数据信息包在某⼀段很短的时间内丢失时，             它则不能很有效地⼯作。</code></pre><code>那慢启动涨到什么时候是个头呢？</code></li></ol><p>有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢启动算法。</li><li>当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。</li></ul><h2 id="TCP如何保证稳定传输"><a href="#TCP如何保证稳定传输" class="headerlink" title="TCP如何保证稳定传输"></a>TCP如何保证稳定传输</h2><ol><li><p>确认应答+序列号：TCP给发送的每⼀个包进⾏编号，</p><pre><code>           接收⽅对数据包进⾏排序，把有序数据传送给应⽤层。</code></pre></li><li><p>校验和：TCP 将保持它⾸部和数据的检验和。</p><pre><code>   ⽬的是检测数据在传输过程中的任何变化。   如果收到段的检验和有差错，    TCP将丢弃这个报⽂段和不确认收到此报⽂段。</code></pre></li><li><p>流量控制：TCP 连接的每⼀⽅都有固定⼤⼩的缓冲空间， </p><pre><code>      TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。      当接收⽅来不及处理发送⽅的数据，能提示发送⽅降低发送的速率，      防⽌包丢失。       TCP 使⽤的流量控制协议是可变⼤⼩的滑动窗⼝协议。       （TCP 利⽤滑动窗⼝实现流量控制）</code></pre></li><li><p>拥塞控制：当⽹络拥塞时，减少数据的发送。</p></li><li><p>ARQ协议： 也是为了实现可靠传输的，</p><pre><code>      它的基本原理就是每发完⼀个分组就停⽌发送，      等待对⽅确认。在收到确认后再发下⼀个分组。</code></pre></li><li><p>超时重传： 当 TCP 发出⼀个段后，它启动⼀个定时器，</p><pre><code>       等待⽬的端确认收到这个报⽂段。       如果不能及时收到⼀个确认，将重发这个报⽂段。</code></pre></li></ol><p><code>TCP 数据包的编号</code>（SEQ）</p><p>一个包1400字节，那么一次性发送大量数据，<br>就必须分成多个包<br>发送的时候，TCP 协议为每个包编号，<br>以便接收的一方按照顺序还原。万一发生丢包，<br>也可以知道丢失的是哪一个包。<br>第一个包的编号是一个随机数。<br>假设为1号包。假定这个包的负载长度是100字节，<br>那么可以推算出下一个包的编号应该是101。<br>每个数据包都可以得到两个编号：<br>自身的编号，以及下一个包的编号。<br>接收方由此知道，应该按照什么顺序将它们还原成原始文件。</p>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hi.md</title>
      <link href="2021/01/07/hi-md/"/>
      <url>2021/01/07/hi-md/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;        ListNode l1 &#x3D; new ListNode(-1);        ListNode l2 &#x3D; new ListNode(-1);        ListNode cur &#x3D; head;        ListNode small &#x3D; l1;        ListNode large &#x3D; l2;        while(cur!&#x3D;null)&#123;            if(cur.val&lt;x)&#123;                small.next &#x3D;cur;                small &#x3D; small.next;            &#125;else&#123;                large.next &#x3D; cur;                large &#x3D; large.next;            &#125;            cur &#x3D; cur.next;        &#125;        large.next &#x3D; null;        small.next &#x3D; l2.next;        return l1.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>与链表的初相识💗</title>
      <link href="2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
      <url>2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5 align = 'center'><p>  啦啦啦啦啦啦啦啦啦   </p><p>实验室的小伙伴一直在实验室打电话<br>哎 生活不易 猪猪叹气  </p><p>既然不能专心刷题，  </p><p>那就来和链表这串串🚪，巩固巩固友情把 </p><p>～～～<br></font >  </p><hr><font color = 'pink' size = 3> <p>👇 先来一道简单的   </p><p>调整调整心态  </p></font>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️<!-- TOC --><pre><code>- [哑节点](#哑节点)    - [203. 移除链表元素](#203-移除链表元素)- [剑指 Offer 18. 删除链表的节点](#剑指-offer-18-删除链表的节点)    - [237. 删除链表中的节点](#237-删除链表中的节点)    - [2. 两数相加](#2-两数相加)    - [21. 合并两个有序链表](#21-合并两个有序链表)    - [86. 分隔链表(下一道题变形题)](#86-分隔链表下一道题变形题)- [双指针](#双指针)    - [面试题 02.04. 分割链表（类似下一道）](#面试题-0204-分割链表类似下一道)    - [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](#剑指-offer-21-调整数组顺序使奇数位于偶数前面)    - [剑指 Offer 24. 反转链表](#剑指-offer-24-反转链表)    - [234. 回文链表（面试题 02.06    回文链表  ）](#234-回文链表面试题-0206    回文链表--)- [快慢指针](#快慢指针)    - [141. 环形链表](#141-环形链表)    - [142. 环形链表 II](#142-环形链表-ii)    - [剑指 Offer 52. 两个链表的第一个公共节点](#剑指-offer-52-两个链表的第一个公共节点)    - [剑指 Offer 22. 链表中倒数第k个节点](#剑指-offer-22-链表中倒数第k个节点)</code></pre><ul><li><a href="#%E6%A0%88">栈</a></li></ul><!-- /TOC --><h2 id="哑节点"><a href="#哑节点" class="headerlink" title="哑节点"></a>哑节点</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p>删除链表中等于给定值 val 的<strong>所有节点</strong>。<br>示例:<br>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5<br><code>这道题太简单了就弄个哑节点  然后遍历链表  只要遇到相同的就把当前元素的pre指向cur的next即可.哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode removeElements(ListNode head, int val) &#123;        ListNode dummy &#x3D; new ListNode(-1);        dummy.next &#x3D; head;        ListNode cur &#x3D; head,pre &#x3D; dummy;        while(cur!&#x3D;null)&#123;            if(cur.val!&#x3D;val)&#123;                pre &#x3D; cur ;            &#125;else&#123;                pre.next &#x3D; cur.next ;            &#125;            cur &#x3D; cur.next;        &#125;        return dummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。<br>注意：此题对比原题有改动<br>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode deleteNode(ListNode head, int val) &#123;    ListNode dummy &#x3D; new ListNode(-1);    dummy.next &#x3D; head;    ListNode pre &#x3D; dummy,cur&#x3D; head;    while(cur !&#x3D;null &amp;&amp;cur.val!&#x3D;val)&#123;        pre&#x3D; cur;        cur&#x3D; cur.next;    &#125;    if(cur&#x3D;&#x3D;null) return head;    pre.next&#x3D;cur.next;    return dummy.next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h3><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点<br>现有一个链表 – head = [4,5,1,9]，它可以表示为:<br><img src=https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png  /><br>输入：head = [4,5,1,9], node = 5<br>输出：[4,1,9]<br>解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p><code>为了利用node.next=node.next.next;  </code><br><code>就把node.next节点替换node的val</code><br><code>删除的其实是node.next节点</code><br><img src=https://pic.leetcode-cn.com/ec23cc1b03e264cf28c84133699326b6f8f2479c0acfaa1d56efee876c43bb1f-image.png  /></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void deleteNode(ListNode node) &#123;    node.val &#x3D;node.next.val;    node.next&#x3D;node.next.next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️</p><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</p><p><code>将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00，比如 987 + 23 = 987 + 023 = 1010 每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值</code><br><code>如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1</code><br><code>**小技巧**：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode addTwoNumbers(ListNode head1, ListNode head2) &#123;        ListNode nummy &#x3D; new ListNode(0);        ListNode cur &#x3D; nummy,l1&#x3D;head1,l2&#x3D;head2;        int carry &#x3D; 0 ;        while(l1!&#x3D;null||l2!&#x3D;null)&#123;            int num1 &#x3D; l1!&#x3D;null?l1.val:0;            int num2 &#x3D; l2!&#x3D;null?l2.val:0;            int sum &#x3D; num1+num2+carry;            carry&#x3D;sum&#x2F;10;            cur.next&#x3D;new ListNode(sum%10);            cur&#x3D;cur.next;            if(l1!&#x3D;null) l1&#x3D;l1.next;            if(l2!&#x3D;null) l2&#x3D;l2.next;        &#125;        if(carry&gt;0)  cur.next &#x3D; new ListNode(carry);        return nummy.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        if(l1&#x3D;&#x3D;null) return l2;        if(l2&#x3D;&#x3D;null) return l1;        ListNode nummy &#x3D; new ListNode(-1);        ListNode p &#x3D; nummy;&#x2F;&#x2F;因为Nummy是亚节点 固定的，弄一个游标        while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null)&#123;            if(l1.val&lt;&#x3D;l2.val)&#123;                p.next&#x3D;l1;                l1&#x3D;l1.next;            &#125;else&#123;                p.next&#x3D;l2;                l2&#x3D;l2.next;            &#125;            p&#x3D;p.next;        &#125;        p.next&#x3D;(l1&#x3D;&#x3D;null)?l2:l1;        return nummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️</p><hr><font color = 'pink' size = 3> <p>👇 小的串一串，大的串一串，最后两串连一串……</p></font>---<p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️</p><h3 id="86-分隔链表-下一道题变形题"><a href="#86-分隔链表-下一道题变形题" class="headerlink" title="86. 分隔链表(下一道题变形题)"></a>86. 分隔链表(下一道题变形题)</h3><p>给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。<br><strong>你应当保留两个分区中每个节点的初始相对位置。</strong><br>输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5<br><code>遍历结束后，我们将large的next 指针置空，</code><br><code>这是因为当前节点复用的是原链表的节点，而其next 指针可能指向一个小于 x 的节点，我们需要切断这个引用</code><br><font color = 'MediumSlateBlue' size = 3><br>large最后是合并链表的最后一个元素，最后一个元素的next指向null<br>如果最后一个large刚好指向一个small的节点，就会有环了<br></font></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;        ListNode l1 &#x3D; new ListNode(-1);        ListNode l2 &#x3D; new ListNode(-1);        ListNode cur &#x3D; head;        ListNode small &#x3D; l1;        ListNode large &#x3D; l2;        while(cur!&#x3D;null)&#123;            if(cur.val&lt;x)&#123;                small.next &#x3D;cur;                small &#x3D; small.next;            &#125;else&#123;                large.next &#x3D; cur;                large &#x3D; large.next;            &#125;            cur &#x3D; cur.next;        &#125;        large.next &#x3D; null;        small.next &#x3D; l2.next;        return l1.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️<br><strong>嘟嘟嘟嘟嘟嘟，还有和他相似的一道题</strong></p><hr><h3 id="面试题-02-04-分割链表（类似下一道）"><a href="#面试题-02-04-分割链表（类似下一道）" class="headerlink" title="面试题 02.04. 分割链表（类似下一道）"></a>面试题 02.04. 分割链表（类似下一道）</h3><p>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。<br><code>题目要求是只要把小于x的数移动到所有x的左方就行,没有顺序要求，而且等于x,大于x这些元素没有要求！</code></p><p><strong>所以运用双指针</strong>,<br>    <code>第一个指针落在不小于x的节点上,第二个向前移动。如果第二个指针遇到小于x的节点,交换二者的值,然后第一个指针指向next。第二个指针肯定走得更快,所以第一个指针一直处于不小于x的节点的位置，或者就是两个指针重叠,这时候还是礼貌性地交换一下罢了。</code></p><p> // [1, 4, 3, 2, 5, 2]. prev = 1, cur = 1<br> // [1, 4, 3, 2, 5, 2]. prev = 1, cur = 1 小于,交换二者,没有变化<br> // [1, 4, 3, 2, 5, 2]. prev = 4, cur = 4 继续往后next<br> // [1, 4, 3, 2, 5, 2]. prev = 4, cur = 3 无序交换, 只修改cur指针<br> // [1, 4, 3, 2, 5, 2]. prev = 4, cur = 2 同上<br> // [1, 2, 3, 4, 5, 2]. prev = 2, cur = 4 2 &lt; 3,交换二者<br> // [1, 2, 3, 4, 5, 2]. prev = 3, cur = 5 二者同时往后next<br> // [1, 2, 3, 4, 5, 2]. prev = 3, cur = 2<br> // [1, 2, 2, 4, 5, 3] over</p><p>`</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;        ListNode cur &#x3D; head, prev &#x3D; head;        while (cur !&#x3D; null) &#123;            if (cur.val &lt; x) &#123;                int tmp &#x3D; prev.val;                prev.val &#x3D; cur.val;                cur.val &#x3D; tmp;                prev &#x3D; prev.next;            &#125;            cur &#x3D; cur.next;        &#125;        return head;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><font color = 'MediumSlateBlue' size = 3> 其实有没有感觉这两道题思路挺相像的，都是双指针然后用一个指针表示小于的数或者奇数的位置，当满足条件是做处理然后移动该指针和遍历的指针，如果不满足条件仅仅只是移动遍历的指针；</font><h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] exchange(int[] nums) &#123;        int i &#x3D; 0 ;         for(int j &#x3D; 0 ; j &lt; nums.length;j++)&#123;             if(nums[j]%2!&#x3D;0)&#123;                 int tmp &#x3D; nums[j];                 nums[j]&#x3D;nums[i];                 nums[i]&#x3D;tmp;                 i++;             &#125;         &#125;         return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️</p><h3 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode reverseList(ListNode head) &#123;        if(head&#x3D;&#x3D;null) return null;        ListNode pre&#x3D; null;        ListNode cur &#x3D; head;        while(cur!&#x3D;null)&#123;            ListNode tmp &#x3D; cur.next;            cur.next &#x3D; pre ;            pre &#x3D; cur;            cur &#x3D; tmp;        &#125;        return pre ;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="234-回文链表（面试题-02-06-回文链表-）"><a href="#234-回文链表（面试题-02-06-回文链表-）" class="headerlink" title="234. 回文链表（面试题 02.06    回文链表  ）"></a>234. 回文链表（面试题 02.06    回文链表  ）</h3><p>请判断一个链表是否为回文链表。<br>输入: 1-&gt;2<br>输出: false<br>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br><code>整个流程可以分为以下五个步骤</code>：<br><code>找到前半部分链表的尾节点。</code><br><code>反转后半部分链表。</code><br><code>判断是否回文。</code><br><code>恢复链表</code>。<br><code>返回结果。</code></p><p><code>我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</code></p><p><code>若链表有奇数个节点，则中间的节点应该看作是前半部分。</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return true;       &#x2F;&#x2F;找到第一个链表的末尾节点        ListNode last&#x3D;findMid(head);       &#x2F;&#x2F;反转第二个链表,start是第二个链表的首节点        ListNode start&#x3D;reverse(last.next);        ListNode l1 &#x3D; head;        ListNode l2 &#x3D; start;        boolean ans &#x3D; true;        while(ans&amp;&amp;l2!&#x3D;null)&#123;            if(l1.val!&#x3D;l2.val) ans &#x3D; false;            l1&#x3D;l1.next;            l2&#x3D;l2.next;        &#125;        &#x2F;&#x2F;回复链表        last.next &#x3D; reverse(start);        return ans;    &#125;    &#x2F;&#x2F;快慢指针    &#x2F;&#x2F;如果是奇数的话正好是中间的节点    &#x2F;&#x2F;如果是偶数的话-左中位数 比如1234 返回2    public ListNode findMid(ListNode head)&#123;        ListNode slow &#x3D; head;        ListNode fast &#x3D; head;        while(fast.next!&#x3D;null&amp;&amp;fast.next.next!&#x3D;null)&#123;            slow &#x3D; slow.next;            fast &#x3D; fast.next.next;        &#125;        return slow;    &#125;    &#x2F;&#x2F;反转链表 返回首节点    public ListNode reverse(ListNode head)&#123;        ListNode cur &#x3D; head,pre &#x3D; null;        while(cur!&#x3D;null)&#123;            ListNode next &#x3D; cur.next;            cur.next &#x3D; pre;            pre &#x3D; cur;            cur &#x3D; next;        &#125;        return pre;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><hr><p><code>下面两道题参考大佬的图解很明白 </code><br><code>https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-by-ac_fun-zshd/</code><br>💗💗💗💗💗💗💗💗</p><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><p>给定一个链表，判断链表中是否有环。</p><p><code>经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</code><br><code>因为快指针移动速度是慢指针的2倍，那么当链表中有环时，则快指针会在环中与慢指针相遇。</code><br><code>第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）</code><br><img src =https://pic.leetcode-cn.com/1609224521-roALTq-image.png /></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean hasCycle(ListNode head) &#123;        ListNode slow &#x3D; head,fast &#x3D; head;        while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null)&#123;            slow&#x3D;slow.next;            fast&#x3D;fast.next.next;            if(slow&#x3D;&#x3D;fast) return true;        &#125;        return false;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><img src=https://pic.leetcode-cn.com/1609224575-xrjBjO-image.png /><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode detectCycle(ListNode head) &#123;        ListNode slow &#x3D; head,fast &#x3D; head;        while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null)&#123;            fast&#x3D;fast.next.next;            slow&#x3D;slow.next;            if(fast&#x3D;&#x3D;slow) break;        &#125;        if(fast&#x3D;&#x3D;null||fast.next&#x3D;&#x3D;null) return null;        fast &#x3D; head;        while(fast!&#x3D;slow)&#123;            fast&#x3D;fast.next;            slow&#x3D;slow.next;        &#125;        return fast;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p><code>pA走过的路径为A链+B链,pB走过的路径为B链+A链</code><br><code>pA和pB走过的长度都相同，都是A链和B链的长度之和，</code><br><code>相当于将两条链从尾端对齐，</code><br><code>如果相交，则会提前在相交点相遇，如果没有相交点，</code><br><code>则会在最后相遇</code></p><p><img src="1.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        &#x2F;&#x2F;两个链表相交，相交后的长度是相同的。此时需要消除链表的长度差        if(headA&#x3D;&#x3D;null||headB&#x3D;&#x3D;null) return null;        ListNode ha&#x3D;headA,hb&#x3D;headB;        while(ha!&#x3D;hb)&#123;            ha&#x3D;(ha&#x3D;&#x3D;null)?headB:ha.next;            hb&#x3D;(hb&#x3D;&#x3D;null)?headA:hb.next;        &#125;        return ha;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.<br><code>使用快慢指针的思路</code><br><code>一开始快指针和慢指针都指向链表头</code><br><code>然后让快指针先走k步，走完k步之后让快指针和慢指针一起走</code><br><code>最后慢指针所指向的位置就是n-k的位置，即倒数第k个节点</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode getKthFromEnd(ListNode head, int k) &#123;        ListNode fast &#x3D; head;        ListNode slow &#x3D; head;        for(int i &#x3D; 0;i&lt;&#x3D;k-1;i++)&#123;            fast&#x3D;fast.next;        &#125;        while(fast!&#x3D;null)&#123;            fast&#x3D;fast.next;            slow&#x3D;slow.next;        &#125;        return slow;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><font color = 'Red' size = 5 align = 'center'><p>到现在为止呢 ，上面的十三道题目算是入门了叭～～～  </p><p>给自己鼓个掌👏  </p></font><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>剑指 Offer 06. 从尾到头打印链表<br>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。<br>输入：head = [1,3,2]<br>输出：[2,3,1]</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int[] reversePrint(ListNode head) &#123;        LinkedList&lt;Integer&gt; stack &#x3D; new LinkedList&lt;&gt;();        ListNode cur &#x3D; head;        while(cur!&#x3D;null)&#123;            stack.addLast(cur.val);            cur&#x3D;cur.next;        &#125;        int[] ans &#x3D;new int[stack.size()];        for(int i &#x3D; 0 ; i &lt; ans.length;i++)&#123;            ans[i]&#x3D;stack.removeLast();        &#125;        return ans;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与链表的再相识💗</title>
      <link href="2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A81/"/>
      <url>2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A81/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5 align = 'center'><p>  啦啦啦啦啦啦啦啦啦   </p><p>前面都是比较基础的题目<br>根据上面这些知识再来几道把～<br>学以致用</p><p>～～～<br></font >  </p><hr><p>本文的图参考<br><code>https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/</code><br>–</p><h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h3><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，<strong>这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</strong><br>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p><hr><h4 id="解法1-哑节点的设置"><a href="#解法1-哑节点的设置" class="headerlink" title="解法1: 哑节点的设置"></a>解法1: 哑节点的设置</h4><p><code>类似前面的分割链表  设置哑节点的值  但是注意这里的话需要设置一个evenflag 来判断当前节点是奇数节点还是偶数节点</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode oddEvenList(ListNode head) &#123;        if(head&#x3D;&#x3D;null) return head;        ListNode odddummy &#x3D; new ListNode(-1);        ListNode evendummy &#x3D; new ListNode(-1);        ListNode cur  &#x3D; head;        ListNode odd &#x3D; odddummy;        ListNode even &#x3D; evendummy;        boolean evenflag &#x3D; true;        while(cur!&#x3D;null)&#123;            if(evenflag)&#123;                odd.next &#x3D; cur;                odd&#x3D;odd.next;                evenflag &#x3D; false;            &#125;else&#123;                even.next &#x3D; cur;                even &#x3D; even.next;                evenflag &#x3D; true;            &#125;            cur&#x3D;cur.next;        &#125;        even.next&#x3D;null;        odd.next&#x3D; evendummy.next;        return odddummy.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法2-双指针"><a href="#解法2-双指针" class="headerlink" title="解法2: 双指针"></a>解法2: 双指针</h4><img src = https://pic.leetcode-cn.com/1605227711-BsDKjR-image.png /><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode oddEvenList(ListNode head) &#123;        if(head&#x3D;&#x3D;null) return head;        ListNode odd &#x3D; head;        ListNode even &#x3D; head.next;        ListNode evenHead &#x3D; head.next;        while(even!&#x3D;null&amp;&amp;even.next!&#x3D;null)&#123;            odd.next &#x3D; even.next;            odd &#x3D; even.next;            even.next &#x3D; odd.next;            even &#x3D; odd.next;        &#125;        odd.next &#x3D; evenHead;        return head;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="876-链表的中间结点-快慢指针"><a href="#876-链表的中间结点-快慢指针" class="headerlink" title="876. 链表的中间结点 快慢指针"></a>876. 链表的中间结点 快慢指针</h3><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p><hr><p><code>快指针能继续走的时候继续走就行,区别左中间节点的条件是fast.next!=null&amp;&amp;fast.next.next!=null</code><br><img  src =https://pic.leetcode-cn.com/1606462980-RIpDUY-file_1606462980633 /><br> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode middleNode(ListNode head) &#123;        ListNode slow &#x3D; head,fast&#x3D;head;        while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null)&#123;            slow&#x3D;slow.next;            fast&#x3D;fast.next.next;        &#125;        return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><hr><h3 id="24-两两交换链表中的节点-哑节点"><a href="#24-两两交换链表中的节点-哑节点" class="headerlink" title="24. 两两交换链表中的节点 哑节点"></a>24. 两两交换链表中的节点 哑节点</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]<br><img   src= https://pic.leetcode-cn.com/42c91b69e3f38d63a0d0153c440724e69bd2d24b95091b4dcc5c68172f8f4e1e-%E8%BF%AD%E4%BB%A3.gif    /></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode dummy &#x3D; new ListNode(-1);        dummy.next &#x3D; head;        ListNode cur &#x3D; head;        ListNode pre &#x3D; dummy;        while(cur!&#x3D;null&amp;&amp;cur.next!&#x3D;null)&#123;            ListNode first &#x3D; cur;            ListNode second &#x3D; cur.next;            pre.next &#x3D; second;            first.next &#x3D; second.next;            second.next &#x3D; first;            pre &#x3D; first;            cur &#x3D; first.next;&#x2F;&#x2F;为下一轮作准备        &#125;        return dummy.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表的倒数第N个节点-剑指-Offer-22-链表中倒数第k个节点-快慢指针-哑节点"><a href="#19-删除链表的倒数第N个节点-剑指-Offer-22-链表中倒数第k个节点-快慢指针-哑节点" class="headerlink" title="19. 删除链表的倒数第N个节点(剑指 Offer 22. 链表中倒数第k个节点) 快慢指针 哑节点"></a>19. 删除链表的倒数第N个节点(剑指 Offer 22. 链表中倒数第k个节点) 快慢指针 哑节点</h3><p>给定一个链表，<strong>删除链表的倒数第 n 个节点，</strong>并且返回链表的头结点。<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy &#x3D; new ListNode(-1);        dummy.next &#x3D; head;        ListNode fast &#x3D; dummy;        ListNode slow &#x3D; dummy;        for(int i &#x3D; 0 ; i&lt; n;i++)&#123;            fast &#x3D; fast.next;        &#125;        &#x2F;&#x2F;这里fast.next!&#x3D;null走完的话就找到了倒数第k个节点的前一个节点        while(fast.next!&#x3D;null)&#123;            slow&#x3D;slow.next;            fast&#x3D;fast.next;        &#125;        slow.next&#x3D;slow.next.next;        return dummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><p><strong>反转从位置 m 到 n 的链表</strong>。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。<br><code>第一步：找到待反转节点的前一个节点</code>。<br><code>第二步：反转m到n这部分。</code><br><code>第三步：将反转的起点的next指向反转的后面一部分。</code><br><code>第四步：将第一步找到的节点指向反转以后的头节点。</code><br><img src = https://pic.leetcode-cn.com/3158b23f7e6919d47a11a2f57e921b5645fceb84212450336f2256f5659fa9e7.jpg /><br>参考链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/ji-bai-liao-100de-javayong-hu-by-reedfan-6/">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/ji-bai-liao-100de-javayong-hu-by-reedfan-6/</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode reverseBetween(ListNode head, int m, int n) &#123;        ListNode dummy &#x3D; new ListNode(-1);        dummy.next &#x3D; head;        ListNode node &#x3D; dummy;        for(int i &#x3D; 0 ;i&lt;m-1;i++)&#123;            node&#x3D;node.next;        &#125;        ListNode reverseHead &#x3D; node.next;        ListNode pre &#x3D; null;        ListNode cur &#x3D; reverseHead;        for(int i &#x3D; m ;i &lt;&#x3D;n;i++)&#123;            ListNode next &#x3D; cur.next;            cur.next &#x3D; pre;            pre &#x3D; cur;            cur &#x3D; next;        &#125;         reverseHead.next &#x3D; cur;        node.next &#x3D; pre;        return dummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="83-删除排序链表中的重复元素-双指针"><a href="#83-删除排序链表中的重复元素-双指针" class="headerlink" title="83. 删除排序链表中的重复元素 双指针"></a>83. 删除排序链表中的重复元素 双指针</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode deleteDuplicates(ListNode head) &#123;        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return head;        ListNode cur &#x3D; head;        while(cur!&#x3D;null&amp;&amp;cur.next!&#x3D;null)&#123;            if(cur.val&#x3D;&#x3D;cur.next.val)&#123;                cur.next&#x3D;cur.next.next;            &#125;else&#123;                cur &#x3D; cur.next;            &#125;        &#125;        return head;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h3><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br>示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3<br><code>这道题是自己想的解法  艾码  这段代码调了得有一个多小时  记录一下</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode deleteDuplicates(ListNode head) &#123;        ListNode dummy &#x3D;new ListNode(-1);        ListNode pre &#x3D;dummy;        ListNode cur &#x3D;head;        while(cur!&#x3D;null)&#123;            if(cur.next!&#x3D;null&amp;&amp;cur.val!&#x3D;cur.next.val)&#123;                pre.next &#x3D; new ListNode(cur.val);                pre &#x3D; pre.next;            &#125;            &#x2F;&#x2F;当条件成立是说明当前cur是最后一个值，且和前面的都不相等            if(cur.next&#x3D;&#x3D;null)&#123;                pre.next &#x3D; new ListNode(cur.val);                            &#125;            int val &#x3D; cur.val;            &#x2F;&#x2F;把所有相同的值都跳过去            while(cur!&#x3D;null&amp;&amp;val&#x3D;&#x3D;cur.val)&#123;                cur&#x3D;cur.next;            &#125;                    &#125;        return dummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p><hr><p><code>参考https://leetcode-cn.com/problems/rotate-list/solution/dong-tu-suan-fa-xuan-zhuan-lian-biao-si-chong-ji-3/</code><br>    <code>当然也可以直接把链表转成环，然后在环中找到k的位置将其打断～</code></p><img src=https://pic.leetcode-cn.com/221a9b004ce8b55e7e190789711850154408609d1af11881e48680c65f5e32f1-file_1597038479852 /><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode rotateRight(ListNode head, int k) &#123;        &#x2F;&#x2F; 思路：先将链表连成一个环，在找断点        &#x2F;&#x2F; 先考虑边界情况        if(head &#x3D;&#x3D; null)&#123;            return null;        &#125;        ListNode tmp &#x3D; head;        &#x2F;&#x2F; 找到链表最后一个节点        int length &#x3D; 1;        while(tmp.next !&#x3D; null)&#123;            tmp &#x3D; tmp.next;            length ++;        &#125;        tmp.next &#x3D; head;  &#x2F;&#x2F; 构成一个环        ListNode c_list &#x3D; head;  &#x2F;&#x2F; 头结点        ListNode prev &#x3D; tmp; &#x2F;&#x2F; 设置尾结点        &#x2F;&#x2F; 通过循环找到新的头结点，向右转n次则需要next length-k%length 次        for(int i&#x3D;1; i&lt;&#x3D;length - k%length; i++)&#123;            c_list &#x3D; c_list.next;            prev &#x3D; prev.next;        &#125;        prev.next &#x3D; null;        return c_list;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h3><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:<br>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.  </p><hr><p><code>寻找链表中点 + 链表逆序 + 合并链表</code><br><code>注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。</code></p><p><code>这样我们的任务即可划分为三步： 找到原链表的中点（参考「876. 链表的中间结点」）。 我们可以使用快慢指针来 O(N)地找到链表的中间节点。 将原链表的右半端反转（参考「206. 反转链表」）。 将原链表的两端合并。 因为两链表长度相差不超过 1，因此直接合并即可。</code><br>`</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public void reorderList(ListNode head) &#123;        if(head&#x3D;&#x3D;null) return ;        ListNode left &#x3D; head;        ListNode mid &#x3D; findMid(head);        ListNode right &#x3D; mid.next;        mid.next&#x3D;null;&#x2F;&#x2F;很重要 别忘了        right &#x3D; reverse(right);        merge(left,right);    &#125;    &#x2F;&#x2F;返回左中节点    public ListNode findMid(ListNode head)&#123;        ListNode fast &#x3D; head;        ListNode slow &#x3D; head;        while(fast.next!&#x3D;null&amp;&amp;fast.next.next!&#x3D;null)&#123;            fast&#x3D;fast.next.next;            slow&#x3D;slow.next;        &#125;        return slow;    &#125;    public ListNode reverse(ListNode head)&#123;        if(head&#x3D;&#x3D;null) return null;        ListNode pre &#x3D; null;        ListNode cur &#x3D; head;        while(cur!&#x3D;null)&#123;            ListNode next &#x3D; cur.next;            cur.next&#x3D; pre;            pre &#x3D;cur;            cur&#x3D;next;        &#125;        return pre;    &#125;    public void merge(ListNode left,ListNode right)&#123;        ListNode l1 &#x3D;left;        ListNode l2&#x3D; right;        while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null)&#123;            ListNode l1next &#x3D; l1.next;            ListNode l2next &#x3D; l2.next;            l1.next &#x3D; l2;            l2.next&#x3D;l1next;            l1 &#x3D; l1next;            l2&#x3D;l2next;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>递归版本</strong> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode sortList(ListNode head) &#123;        &#x2F;&#x2F;归并排序        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return head;        ListNode slow &#x3D; head;        ListNode fast &#x3D; head;        ListNode first &#x3D; head;        while(fast.next!&#x3D;null&amp;&amp;fast.next.next!&#x3D;null)&#123;            fast &#x3D; fast.next.next;            slow &#x3D; slow.next;        &#125;        ListNode second &#x3D; slow.next;        slow.next&#x3D;null;        first &#x3D; sortList(first);        second &#x3D; sortList(second);        ListNode node &#x3D; merge(first,second);        return node;    &#125;    public ListNode merge(ListNode first,ListNode second)&#123;        ListNode l1&#x3D;first;        ListNode l2 &#x3D; second;        ListNode dummy &#x3D; new ListNode(-1);        ListNode cur &#x3D; dummy;        while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null)&#123;            if(l1.val&lt;l2.val)&#123;                cur.next &#x3D; l1;                l1&#x3D;l1.next;            &#125;else&#123;                cur.next&#x3D;l2;                l2&#x3D;l2.next;            &#125;            cur &#x3D; cur.next;        &#125;        cur.next &#x3D; (l1&#x3D;&#x3D;null)?l2:l1;        return dummy.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组刷题笔记</title>
      <link href="2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
      <url>2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 4>今天想复习一下以前刷过的数组题目    <p>练练手感  </p><p>找找数组的感觉  </p><p>和数组成为好朋友的第一天，哈哈哈哈<br>～～～<br></font >  </p><hr><!-- TOC --><ul><li><a href="#font"></font></a></li><li><a href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9">977. 有序数组的平方</a></li><li><a href="#%E6%8E%92%E5%BA%8F%E5%90%8E%E6%95%B0%E7%BB%84%E5%8F%98%E4%B8%BA-01916100">排序后，数组变为 [0,1,9,16,100]</a></li><li><a href="#-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">## 88. 合并两个有序数组</a></li><li><a href="#%E8%BE%93%E5%87%BA122356">输出：[1,2,2,3,5,6]</a></li><li><a href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB">75. 颜色分类</a></li><li><a href="#%E8%BE%93%E5%87%BA001122">输出：[0,0,1,1,2,2]</a></li><li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98-1616-%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F">面试题 16.16. 部分排序</a></li><li><a href="#%E8%BE%93%E5%87%BA-39">输出： [3,9]</a></li></ul><!-- /TOC --><font color = 'pink' size = 3>双指针  💗  <p>👇<br></font></p><hr><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。<br>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p><hr><p><strong>思路</strong><br><code>数组其实是有序的， 只不过负数平方之后可能成为最大数了。 那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。 此时可以考虑双指针法了，i指向其实位置，j指向终止位置。 定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。 </code><br>参考大佬动图<br>–原链接<br><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/977-you-xu-shu-zu-de-ping-fang-pai-xu-shuang-zhi-z/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/977-you-xu-shu-zu-de-ping-fang-pai-xu-shuang-zhi-z/</a></p><img src=https://pic.leetcode-cn.com/1602811839-xiaxXW-977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif  /><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int[] sortedSquares(int[] nums) &#123;        int i &#x3D; 0 ,j &#x3D; nums.length -1;        int k &#x3D; nums.length-1;        int[] arr &#x3D; new int[nums.length];        while(i&lt;&#x3D;j)&#123;            if(nums[i]+nums[j]&lt;0)&#123;                arr[k--]&#x3D;nums[i]*nums[i++];            &#125;else&#123;                arr[k--]&#x3D;nums[j]*nums[j--];            &#125;        &#125;        return arr;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><font color = 'pink' size = 3>双指针  💗  <p>👇<br></font></p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><hr><p><code>top题库</code><br>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>输入：<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出：[1,2,2,3,5,6]</p><hr><p><strong>思路</strong><br><code>从后往前遍历数组：</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void merge(int[] nums1, int m, int[] nums2, int n) &#123;       int i &#x3D; nums1.length-1;       m--;n--;       while(m&gt;&#x3D;0&amp;&amp;n&gt;&#x3D;0)&#123;           nums1[i--]&#x3D;nums1[m]&gt;&#x3D;nums2[n]?nums1[m--]:nums2[n--];       &#125;       while(n&gt;&#x3D;0)&#123;           nums1[i--]&#x3D;nums2[n--];       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>思路</strong><br>    <code>参考快速排序 partition过程</code></p><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><p><code>top题库</code><br>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>你能想出一个仅使用<strong>常数空间</strong>的一趟扫描算法吗？<br>示例 1：<br>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]</p><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public void sortColors(int[] nums) &#123;        partition(nums,0,nums.length-1,1);    &#125;    public void partition(int[] nums,int l , int r, int pivot)&#123;        int start &#x3D; l-1;        int end &#x3D; r+1;        int i &#x3D; 0;        while(i&lt;end)&#123;            if(nums[i]&lt;pivot)&#123;                swap(nums,++start,i++);            &#125;else if(nums[i]&#x3D;&#x3D;pivot)&#123;                i++;            &#125;else&#123;                swap(nums,--end,i);            &#125;        &#125;    &#125;    public void swap(int[] nums , int i , int j )&#123;        int tmp &#x3D; nums[i];        nums[i] &#x3D; nums[j];        nums[j] &#x3D; tmp;     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="面试题-16-16-部分排序"><a href="#面试题-16-16-部分排序" class="headerlink" title="面试题 16.16. 部分排序"></a>面试题 16.16. 部分排序</h2><p>给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。<br>输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]<br>输出： [3,9]</p><hr><p><strong>思路</strong><br>    <code>    也是双指针，     l的值就是从后往前遍历数组，找到比min大的元素就更新l的值，找到和min小的元素就更新min的值     r的值就是从左往➡️遍历数组，找到比max大的元素就更新max的值，找到和min小的元素就更新r的值    </code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] subSort(int[] array) &#123;        if(array.length&#x3D;&#x3D;0) return new int[]&#123;-1,-1&#125;;        int l &#x3D; -1;        int r &#x3D; -1;        &#x2F;&#x2F;从左往后找r的值         int max &#x3D; array[0];        for(int i &#x3D; 1; i &lt; array.length ; i ++ )&#123;            if(array[i]&gt;&#x3D;max)&#123;                max &#x3D; array[i];            &#125;else&#123;                r &#x3D; i;            &#125;        &#125;        if(r&#x3D;&#x3D;-1) return new int[]&#123;-1,-1&#125;;        &#x2F;&#x2F;从后往左找l的值         int min &#x3D; array[array.length-1];        for(int j &#x3D; array.length -2;j&gt;&#x3D;0;j--)&#123;            if(array[j]&lt;&#x3D;min)&#123;                min&#x3D;array[j];            &#125;else&#123;                l &#x3D; j;            &#125;        &#125;        return new int[]&#123;l,r&#125;;    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP工作原理以及HTTP1.0-HTTP3版本的改进</title>
      <link href="2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"/>
      <url>2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP-1.0"></a>HTTP-1.0</h2><h3 id="HTTP-1-0优缺点"><a href="#HTTP-1-0优缺点" class="headerlink" title="HTTP-1.0优缺点"></a>HTTP-1.0优缺点</h3><p><font color=pink size='3'>I.优点</font></p><ol><li>HTTP基本的报⽂格式就是header + body，头部信息也是key-value简单⽂本的形式。</li><li>HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，<br>都允许开发⼈员⾃定义和扩充。</li><li>HTTP由于是⼯作在应⽤层，则它下层可以随意变化。</li><li>应⽤⼴泛和跨平台</li></ol><p><font color=pink size='3'>II.缺点</font></p><ol><li>⽆状态<br>由于⽆状态，它在完成有关联性的操作时会⾮常麻烦。<br>例如登录-&gt;添加购物⻋-&gt;下单-&gt;结算-&gt;⽀付，这系列操作都要知道⽤户的身份才⾏。<br>但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息。</li><li>明⽂传输<br>明⽂意味着在传输过程中的信息，是可⽅便阅读的，<br>通过浏览器的控制台或抓包软件都可以直接⾁眼查看，<br>信息的内容都毫⽆隐私可⾔，很容易就能被窃取。<h3 id="Http为什么是无连接和无状态的"><a href="#Http为什么是无连接和无状态的" class="headerlink" title="Http为什么是无连接和无状态的"></a>Http为什么是无连接和无状态的</h3></li></ol><p>一.无连接<br>每一个访问都是无连接，<br>服务器挨个处理访问队列里的访问，<br>处理完一个就关闭连接，就结束了，<br>然后处理下一个新的<br>无连接的含义是限制每次连接只处理一个请求。<br>服务器处理完客户的请求，并收到客户的应答后，即断开连接</p><p>二.无状态<br>1.协议对于事务处理没有记忆能力<br>2.对同一个url请求没有上下文关系<br>3.每次的请求都是独立的，<br>  它的执行情况和结果与<br>  前面的请求和之后的请求<br>  是无直接关系的，<br>  它不会受前面的请求应答情况<br>  直接影响，<br>  也不会直接影响后面的请求应答情况</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP-1.1"></a>HTTP-1.1</h2><h3 id="HTTP-1-1相对于HTTP1-0改善"><a href="#HTTP-1-1相对于HTTP1-0改善" class="headerlink" title="HTTP/1.1相对于HTTP1.0改善"></a>HTTP/1.1相对于HTTP1.0改善</h3><ol><li>因为早期HTTP/1.0，那就是每发起⼀个请求需要三次握手四次挥手等等操作，<br>增加了通信开销。为了解决这些问题，<br>HTTP/1.1提出了<code>⻓连接</code>的通信⽅式只要任意⼀端没有明确提出断开连接，<br>则保持 TCP 连接状态。</li><li>HTTP/1.1 采⽤了<code>管道传输</code> 的⽅式，<br>可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，<br>只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，<br>可以减少整体的响应时间。</li><li>HTTP1.0中，存在⼀些浪费带宽的现象，<br>例如客户端只是需要某个对象的⼀部分，⽽服务器却将整个对象送过来了，<br>并且不⽀持断点续传功能，HTTP1.1则在请求头引⼊了range头域，<br>它允许只请求资源的某个部分</li></ol><h3 id="HTTP1-1缺点"><a href="#HTTP1-1缺点" class="headerlink" title="HTTP1.1缺点"></a>HTTP1.1缺点</h3><ol><li>服务器是按请求的顺序响应的，如果服务器响应慢，<br>会招致客户端⼀直请求不到数据，也就是<code>队头阻塞</code>；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ol><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP-2"></a>HTTP-2</h2><h3 id="HTTP-2-做了什么优化"><a href="#HTTP-2-做了什么优化" class="headerlink" title="HTTP/2 做了什么优化"></a>HTTP/2 做了什么优化</h3><p><code>HTTP/2是基于HTTPS的，所以说HTTP2的安全性也是有保障的</code></p><ol><li>HTTP/2 会压缩头如果你同时发出多个请求，<br>他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。<br>使用HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，<br>⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。</li><li>HTTP/2全⾯采⽤了<code>⼆进制格式</code>，头信息和数据体都是⼆进制，<pre><code>  计算机收到报⽂后，直接解析⼆进制报⽂，这增加了数据传输的效率。</code></pre></li><li>HTTP/2的数据包不是按顺序发送的</li><li>HTTP/2是可以在⼀个连接中并发多个请求或回应。</li><li>HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，<pre><code>   服务不再是被动地响应，也可以`主动向客户端发送消息`。</code></pre></li></ol><h3 id="HTTP-2有哪些缺陷"><a href="#HTTP-2有哪些缺陷" class="headerlink" title="HTTP/2有哪些缺陷"></a>HTTP/2有哪些缺陷</h3><p><code>多个HTTP请求在复⽤⼀个TCP连接</code>，<code>下层的TCP协议是不知道有多少个HTTP请求的</code>。<br>所以⼀旦发⽣了<code>丢包</code>现象，就会触发<code>TCP的重传机制，</code><br>这样在⼀个TCP连接中的<code>所有的 HTTP请求都必须等待这个丢了的包被重传回来</code>。</p><h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP-3"></a>HTTP-3</h2><h3 id="HTTP-3做了哪些优化"><a href="#HTTP-3做了哪些优化" class="headerlink" title="HTTP/3做了哪些优化"></a>HTTP/3做了哪些优化</h3><p>HTTP/3使用基于<code>UDP协议</code>的QUIC协议来实现的</p><p>HTTP/3把HTTP下层的TCP协议改成了UDP</p><p> <code>因为UDP发⽣是不管顺序，也不管丢包的，所以不会出现HTTP/1.1的队头阻塞和HTTP/2的⼀个丢包全部重传问题。</code></p><p>但是由于UDP是不可靠传输的，而基于UDP的QUIC协议可以实现类似TCP的可靠性传输。主要是依赖</p><ol><li>当某个流发⽣丢包时，只会阻塞这个流， 其他流不会受到影响。</li><li>更改了头部压缩算法，升级成了 QPack 。</li><li>QUIC 直接把以往的TCP和TLS/1.3的6次交互合并成了3次，减少了交互次数。</li></ol><h2 id="HTTP基本知识"><a href="#HTTP基本知识" class="headerlink" title="HTTP基本知识"></a>HTTP基本知识</h2><h3 id="HTTP请求组成"><a href="#HTTP请求组成" class="headerlink" title="HTTP请求组成"></a>HTTP请求组成</h3><p><code>一个HTTP请求报文由四个部分组成：请求行、请求头、空行、请求数据。</code></p><ol><li><p>请求行<br>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，<br>它们用空格分隔。比如 GET /data/info.html HTTP/1.1</p></li><li><p>请求头部<br>HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。<br>如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，。<br>常见的请求头字段以及他的含义：</p><ol><li><code>Accept</code>：浏览器可接受的MIME类型。</li><li><code>Accept-Charset</code>：浏览器可接受的字符集。</li><li><code>Accept-Encoding</code>：浏览器能够进行解码的数据编码方式，<pre><code>             比如gzip。Servlet能够向支持gzip的浏览器             返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。</code></pre></li><li><code>Accept-Languag</code>e：浏览器语言种类，</li><li>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头应答</li><li><code>Content-Length</code>：表示请求消息正文的长度。</li><li><code>Host</code>： 客户机告诉服务器，想访问的主机名。</li><li>If-Modified-Since：客户机告诉服务器，资源的缓存时间。</li><li><code>Referer</code>：客户机告诉服务器，它是从哪个资源来访问服务器的(防盗链)。</li><li><code>User-Agent</code>：User-Agent头域的内容包含发出请求的用户信息。</li><li>Cookie：客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一。</li></ol></li><li><p>空行<br>它的作用是通过一个空行，<code>告诉服务器请求头部到此为止</code>。</p></li><li><p>请求数据</p><p>若方法字段是<code>POST</code>,则通常来说此处放置的就是要<code>提交的数据</code></p></li></ol><h3 id="Get与Post"><a href="#Get与Post" class="headerlink" title="Get与Post"></a>Get与Post</h3><ol><li>Get是请求从服务器获取资源，Post用于<code>传输实体本体</code></li><li>get和post请求都能使用额外的<code>参数</code>，<br>get参数是以查询字符串出现在URL中，post参数存储在实体主体中</li><li>Http方法不会改变服务器状态，get方法是<code>安全</code>的，<br>而post由于是传送实体主体内容，这个内容可能是用户上传的表单数据，<br>上传成功后，服务器可能把这个数据存储到数据库中，因此状态也就发生了变化</li><li>get在调用多次时，客户端收到的结果是一样的，所以是幂等；<br>post调用多次，会增加多行记录，不是<code>幂等</code></li></ol><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>2xx （3种）</p><ol><li>200 ：表示从客户端发送给服务器的请求被正常处理并返回；</li><li>204 ：表示客户端发送给客户端的请求得到了成功处理，</li><li>206 ：表示客户端进行了范围请求。<br>3xx （5种）</li><li>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</li><li>302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；<br>   301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）</li><li>303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；<br>   302与303的区别：后者明确表示客户端应当采用GET方式获取资源</li><li>304 Not Modified：表示客户端发送附带条件<pre><code>             （是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、               If-None-Match、If-Range、If-Unmodified-Since中任一首部）               的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；</code></pre></li><li>307 Temporary Redirect：临时重定向，与303有着相同的含义，<br>307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；<br>4xx （4种）</li><li>400 Bad Request：表示请求报文中存在语法错误；</li><li>401 Unauthorized：未经许可，需要通过HTTP认证；</li><li>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）</li><li>404 Not Found：表示服务器上无法找到请求的资源，除此之外，<pre><code>           也可以在服务器拒绝请求但不想给拒绝原因时使用；</code></pre>5xx （2种）</li><li>500 Inter Server Error：表示服务器在执行请求时发生了错误，<pre><code>                    也有可能是web应用存在的bug或某些临时的错误时；</code></pre></li><li>503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，<pre><code>                    无法处理请求；</code></pre></li></ol><h2 id="一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？"><a href="#一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？" class="headerlink" title="一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？"></a>一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h2><p>在 HTTP/1.0 中，<code>一个服务器在发送完一个 HTTP 响应后</code>，会断开 TCP 链接。<br>但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，<br>某些服务器对 <code>Connection: keep-alive 的 Header </code>进行了支持。<br>意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。<br>这样的好处是连接可以被重新使用   ， <code>之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，</code><br>以及如果维持连接，那么 SSL 的开销也可以避免</p><h2 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么?"></a>URI和URL的区别是什么?</h2><p><strong>URI(Uniform Resource Identifier) 是<code>统⼀资源标志符</code>，可以唯⼀标识⼀个资源。<br>URL(Uniform Resource Location) 是统⼀资源定位.URL是URI的一个子集。它是⼀种具体的URI，即 URL 可以⽤来标识⼀个资源，<code>⽽且还指明了如何 locate 这个资源</code>。<br>URL一般由三部组成<br>①<code>协议(</code>或称为服务方式)<br>②<code>存有该资源的主机IP地址</code>(有时也包括端口号)<br>③<code>主机资源的具体地址。如目录和文件名等。</code><br>例如：<a href="http://www.jianshu.com/u/606fd5f5448c">http://www.jianshu.com/u/606fd5f5448c</a><br>URL是URI的子集，所有的URL都是URI，但不是每个URI都是URL，还有可能是URN.</strong></p><h2 id="http工作流程-输入网址过程"><a href="#http工作流程-输入网址过程" class="headerlink" title="http工作流程-输入网址过程"></a>http工作流程-输入网址过程</h2><p>域名解析 -&gt; 三次握手 -&gt; 发起HTTP请求 -&gt; 响应HTTP请求并得到HTML代码<br>-&gt; 浏览器解析HTML代码  -&gt; 浏览器对页面进行渲染呈现给用户</p><ol><li>输入地址,对URL进⾏解析，从⽽⽣成发送给Web服务器的请求信息。</li><li>浏览器查找域名的IP地址,因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。　<ol><li>浏览器会首先查看本地硬盘的hosts文件，看看其中有没有和这个域名对应的规则，<br>如果有的话就直接使用hosts文件里面的ip地址。</li><li>如果在本地的hosts文件没有能够找到对应的ip地址，<br>浏览器会发出一个DNS请求到<code>本地DNS服务器</code></li><li>查询你输入的网址的DNS请求到达本地DNS服务器之后，<br>本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，<br>就可以直接返回结果，此过程是递归的方式进行查询。<br>如果没有，本地DNS服务器还要向DNS根服务器进行查询。</li><li>根DNS服务器没有记录具体的域名和IP地址的对应关系，<br>而是告诉本地DNS服务器，你可以到<code>域服务器上</code>去继续查询，<br>并给出域服务器的地址。这种过程是迭代的过程。</li><li>本地DNS服务器继续向域服务器发出请求，比如说请求的对象是.com域服务器。<br>.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，<br>而是告诉本地DNS服务器，<code>你的域名的解析服务器</code>的地址</li><li>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，<br><code>本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，</code><br>以备下次别的用户查询时，可以直接返回结果，<code>加快网络访问。</code></li></ol></li><li>浏览器向web服务器发送一个HTTP请求<br>   通过DNS获取到IP后，就可以把HTTP的传输⼯作交给操作系统中的协议栈。<br>   协议栈的内部分为⼏个部分，分别承担不同的⼯作。<br>   上下关系是有⼀定的规则的，上⾯的部分会向下⾯的部分委托⼯作，<br>   下⾯的部分收到委托的⼯作并执⾏。<br>   应⽤程序也就是浏览器通过调⽤ Socket 库，来委托协议栈⼯作。<br>   协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，<br>   它们两会接受应⽤层的委托执⾏收发数据的操作。<br>   协议栈的下⼀半是⽤IP协议控制⽹络包收发操作，<br>   在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，<br>   ⽽将⽹络包发送给对⽅的操作就是由 IP 负责的。<br>   IP 下⾯的⽹卡驱动程序负责控制⽹卡硬件，<br>   ⽽最下⾯的⽹卡则负责完成实际的收发操作，<br>   也就是对⽹线中的信号执⾏发送和接收操作。<br>   拿到域名对应的IP地址之后，<br>   浏览器会以一个随机端口向服务器的WEB程序80端口发起TCP的连接请求。<br>   这个连接请求到达服务器端后，进入到网卡，然后是进入到内核的TCP/IP协议栈，<br>   还有可能要经过防火墙的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</li><li>服务器处理请求<br>   http请求发送到了服务器，后端从在固定的端口接收到TCP报文开始，<br>   它会对TCP连接进行处理，对HTTP协议进行解析，<br>   并按照报文格式进一步封装成HTTP Request对象，供上层使用。</li><li>服务器返回一个HTTP响应　<br>   服务器收到了我们的请求，也处理我们的请求，<br>   到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。</li><li>浏览器显示 HTML,并请求获取嵌入在HTML的资源</li></ol><h3 id="为什么域名要分级设计"><a href="#为什么域名要分级设计" class="headerlink" title="为什么域名要分级设计"></a>为什么域名要分级设计</h3><p>DNS 中的域名都是⽤句点来分隔的，代表了不同层次之间的界限。</p><p>域名的层级关系类似⼀个树状结构：<br>根 DNS 服务器<br>顶级域 DNS 服务器（com）<br>权威 DNS 服务器（server.com）</p><p>因此，客户端只要能够找到任意⼀台 DNS 服务器，<br>就可以通过它找到根域 DNS 服务器，然后再⼀路顺<br>藤摸⽠找到位于下层的某台⽬标 DNS 服务器。</p><h3 id="重定向原因"><a href="#重定向原因" class="headerlink" title="重定向原因"></a>重定向原因</h3><ol><li>网站调整（如改变网页目录结构）；</li><li>网页被移到一个新地址；</li><li>网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</li></ol><p>这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中<br>旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；<br>还有就是某些注册了多个域名的网站，<br>也需要通过重定向让访问这些域名的用户自动跳转到主站点等</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP是什么怎么建立断开连接，与UDP区别</title>
      <link href="2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/"/>
      <url>2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/</url>
      
        <content type="html"><![CDATA[<font color = gold size =5>学习笔记：总结看bilibili方老师的课程计算机网络以及小林公众号的总结</font><h1 id="TCP与UDP比较"><a href="#TCP与UDP比较" class="headerlink" title="TCP与UDP比较"></a>TCP与UDP比较</h1><ol><li><code>连接方面来看</code><br>TCP 是面向连接的传输层协议，传输数据前先要建立连接。<br>UDP 是不需要连接，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时间延迟。</li><li><code>服务对象</code><br>TCP 是一对一的两点服务，即一条连接只有两个端点。TCP提供全双工的通信。<br>UDP 支持一对一、一对多、多对多的交互通信</li><li><code>可靠性</code><br>TCP 是可靠交付数据的，数据可以不丢失、不重复、按序到达。<br>UDP 是尽最大努力交付，不保证可靠交付数据。所以不用维护复杂的连接状态表。</li><li><code>拥塞控制、流量控制</code><br>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。<br>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。这对某些实时应用很重要，符合多媒体通信的要求</li><li><code>首部开销</code><br>TCP 首部长度较长，会有一定的开销，<br>   首部在没有使用「选项」字段时是 20 个字节，<br>   如果使用了「选项」字段则会变长的。<br>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ol><p>6.UDP是面向报文的。<br>发送方UDP对于应用层交下来的报文，在添加首部之后就向下交付给ip层，既不合并，也不拆分，而是保留这些报文的边界。<br>接收方UDP对IP层交上来的UDP用户数据报，在去除首部之后就向上交付给应用进程，UDP一次交付一个完整的报文。<br>7.TCP是面向字节流的。<br>TCP里面的“流”指的是流入进程或者流出进程的是字节序列。<br>面向字节流指的就是：虽然应用程序和TCP的交互是一次一个数据块，但是TCP把应用程序浇下来的数据堪称仅仅是一次一个数据块，但是TCP把应用程序浇下来的数据看成仅仅是一连串无结构的字节流。<br>TCP不保证接收方应用程序收到的数据块和发送方发出的数据块具有相应大小的关系。<br>但是接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。<br>TCP 和 UDP 应用场景<br>由于TCP是面向连接，能保证<code>数据的可靠性交付</code>，因此经常用于：</p><ul><li>FTP 文件传输</li><li>HTTP / HTTPS<br>接受邮件、远程登录<br>由于 UDP 面向无连接，它可以<code>随时发送数据</code>，再加上UDP本身的处理既简单又高效，因此经常用于：</li><li>包总量较少的通信，如 DNS 、SNMP 等<br><code>QQ聊天、在线视频、网络语音电话</code></li></ul><h1 id="TCP与IP的区别"><a href="#TCP与IP的区别" class="headerlink" title="TCP与IP的区别"></a>TCP与IP的区别</h1><p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP层；<br>IP层也把从TCP接收来的数据包传送到更低层。<br>我认为TCP和IP的关系是：IP提供基本的数据传送，而高层的TCP对这些数据包做进一步加工，如提供端口号等等。 –&gt;</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>一种面向连接(连接导向)的、可靠的、 基于字节流的传输层协议</p><p>TCP是基于字节流的，<code>虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，</code><br>但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；<br><strong>另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段</strong></p><h2 id="TCP作用"><a href="#TCP作用" class="headerlink" title="TCP作用"></a>TCP作用</h2><p>保证数据通信的完整性和可靠性，防止丢包</p><p><code>因为IP 协议只是一个地址协议，并不保证数据包的完整。</code><br><code>如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），</code><br><code>就需要发现丢了哪一个包，以及如何重新发送这个包。</code><br>这就要依靠 TCP 协议。</p><h1 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h1><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><h3 id="TCP三次握手流程"><a href="#TCP三次握手流程" class="headerlink" title="TCP三次握手流程"></a>TCP三次握手流程</h3><p>客户端–发送带有SYN标志的数据包–一次握手–服务端<br>服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端<br>客户端–发送带有带有ACK标志的数据包–三次握手–服务端</p><h3 id="TCP为什么要三次握⼿"><a href="#TCP为什么要三次握⼿" class="headerlink" title="TCP为什么要三次握⼿"></a>TCP为什么要三次握⼿</h3><ol><li>三次握⼿才可以 阻⽌ 重复 历史连接的初始化（主要原因）</li></ol><ul><li><p>比如说，客户端连续发送多次SYN建⽴连接的报⽂，在⽹络拥堵情况下：</p><ul><li>⼀个「旧 SYN 报⽂」⽐「最新的 SYN报⽂」早到达了服务端；</li><li>那么此时服务端就会回⼀个SYN+ACK报⽂给客户端；</li><li>客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接，<br>  比如说序列号过期或超时，那么客户端就会发送 RST 报<pre><code> ⽂给服务端，表示中⽌这⼀次连接。</code></pre></li></ul></li><li><p>如果是两次握⼿连接，就不能判断当前连接是否是历史连接</p></li></ul><ol start="2"><li><p>三次握⼿才可以 同步 双⽅的 初始 序列号</p><p>序列号是作为TCP可靠传输的⼀个关键因素，它的作⽤其实是：</p><ul><li>接收⽅可以去除重复的数据；</li><li>接收⽅可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中，哪些是已经被对⽅收到的；</li></ul><ul><li>四次握⼿其实也能够同步双⽅的初始化序号，<pre><code>但由于客户端传输ACK和SYN可以优化成⼀步，所以就成了「三次握⼿」</code></pre></li><li>两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接收。</li></ul></li><li><p>三次握⼿才可以避免资源浪费</p><p>如果只有「两次握⼿」，当客户端的 SYN 请求连接在⽹络中阻塞，<br>客户端没有接收到 ACK 报⽂，重复发送多次 SYN 报⽂，<br>那么服务器在收到请求后就会建⽴多个冗余的⽆效链接，造成不必要的资源浪费。</p></li></ol><h4 id="TCP为什么SYN"><a href="#TCP为什么SYN" class="headerlink" title="TCP为什么SYN"></a>TCP为什么SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><h4 id="TCP除了SYN，为什么还要-ACK"><a href="#TCP除了SYN，为什么还要-ACK" class="headerlink" title="TCP除了SYN，为什么还要 ACK"></a>TCP除了SYN，为什么还要 ACK</h4><p>双⽅通信⽆误必须是两者互相发送信息都⽆误。传了 SYN，证明发送⽅到接收⽅的通道没有问题，但是<br>接收⽅到发送⽅的通道还需要 ACK 信号来进⾏验证。</p><h3 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h3><p>TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，<br>服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，<br>但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，<br>久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。</p><ol><li>避免 SYN 攻击方式一</li></ol><p>通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p><p>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值</p><ol start="2"><li>避免 SYN 攻击方式二</li></ol><p>正常流程下,</p><p>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</p><p>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</p><p>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</p><p>应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。</p><p>但是</p><p>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</p><p>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。</p><p>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</p><p>计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，</p><p>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</p><p>最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。</p><p>为什么需要 TCP 协议？</p><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。</p><p>因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。</p><h3 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h3><p>这个我还真不太清楚，但是我看到过关于传输控制协议的定义</p><p>简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，</p><h2 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h2><p>TCP 四元组可以唯一的确定一个连接，四元组包括：</p><p>源地址</p><p>源端口</p><p>目的地址</p><p>目的端口</p><p>源地址和目的地址的字段是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p><h4 id="有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？"></a>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</h4><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p><p>因此，客户端 IP 和 端口是可变的，其理论值计算公式应该是:</p><p>客户端的IP数X客户端的端口数</p><p><strong>服务端最大并发 TCP 连接数远不能达到理论上限</strong></p><p>首先主要是文件描述符限制，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数目；</p><p>另一个是内存限制，每个 TCP 连接都要占用一定内存，操作系统是有限的。</p><h4 id="为什么客户端和服务端的初始序列号-ISN-是不相同的？"><a href="#为什么客户端和服务端的初始序列号-ISN-是不相同的？" class="headerlink" title="为什么客户端和服务端的初始序列号 ISN 是不相同的？"></a>为什么客户端和服务端的初始序列号 ISN 是不相同的？</h4><p>因为网络中的报文会延迟、会复制重发、也有可能丢失，</p><p>这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</p><h2 id="什么是Mss"><a href="#什么是Mss" class="headerlink" title="什么是Mss"></a>什么是Mss</h2><p>除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</p><p>MTU：一个网络包的最大长度，以太网中一般为 1500 字节；</p><h2 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h2><p>当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，</p><p>把数据分片成若干片，保证每一个分片都小于 MTU。</p><p>把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，在交给上一层 TCP 传输层。</p><p>但这存在隐患的，那么当如果一<strong>个 IP 分片丢失，整个 IP 报文的所有分片都得重传。</strong></p><p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p><p>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，<strong>则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整TCP 报文（头部 + 数据）」。</strong></p><p>所以 IP 层进行分片传输，是非常没有效率的。</p><p>所以，为了达到最佳的传输效率， TCP 协议在建立连接的时候通常要协商双方的 MSS 值，</p><p>当 TCP 层发现数据超过 MSS 时，则就先会进行分片，<strong>当然由它形成的 IP 包的长度也就不会大于 MTU</strong>，自然也就不用 IP 分片了。</p><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><h2 id="TCP四次挥手流程"><a href="#TCP四次挥手流程" class="headerlink" title="TCP四次挥手流程"></a>TCP四次挥手流程</h2><p>客户端-发送一个FIN，用来关闭客户端到服务器的数据传送<br>服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号<br>服务器-关闭与客户端的连接，发送一个FIN给客户端<br>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</p><p>四次挥手主要是从FIN过程进行分析：</p><ol><li><p>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</p></li><li><p>服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数<br>据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。</p></li></ol><p>服务端通常需要等待完成数据的发送和处理，所以服务端的ACK和FIN⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次</p><h2 id="为什么TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么TIME_WAIT 等待的时间是 2MSL？"></a>为什么TIME_WAIT 等待的时间是 2MSL？</h2><p>⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待2<br>倍的时间。</p><h2 id="为什么需要TIME-WAIT状态？"><a href="#为什么需要TIME-WAIT状态？" class="headerlink" title="为什么需要TIME_WAIT状态？"></a>为什么需要TIME_WAIT状态？</h2><ol><li><p>防⽌具有相同端口的的「旧」数据包被收到；</p><p>比如说服务端在关闭连接之前发送一个报⽂，但是被⽹络延迟了。这时有相同端⼝的TCP连接被复⽤后，被延迟的报文抵达<br>了客户端，那么客户端是有可能正常接收这个过期的报⽂，这就会产⽣数据错乱等严重的问题。而使用TIME_WAIT这个时<br>间，⾜以让两个⽅向上的数据包都被丢弃</p></li><li><p>保证连接正确关闭</p><p>比如客户端四次挥⼿的最后⼀个ACK报⽂如果在⽹络中被丢失了，此时如果客户端TIME-WAIT 过短或没有，则就直接进⼊<br>了 CLOSED 状态了，那么服务端则会⼀直处在 LASE_ACK状态。当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送<br>RST 报⽂给客户端，连接建⽴的过程就会被终⽌。如果有这个时间，就会正常关闭，即使没有收到ACK报文，我也有时间重发<br>并关闭</p></li></ol><p>TIME_WAIT 过多有什么危害？</p><ol><li><p>内存资源占⽤；</p></li><li><p>对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；被占满就会导致⽆法创建新的连接。</p></li></ol><h2 id="16-8：如果已经建⽴了连接，但是客户端突然出现故障了怎么办？"><a href="#16-8：如果已经建⽴了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="16-8：如果已经建⽴了连接，但是客户端突然出现故障了怎么办？"></a>16-8：如果已经建⽴了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP 有⼀个机制是<code>保活机制</code>。</p><p>定义在一个时间段内，如果没有任何连接相关的活动， TCP 保活机制会开始作⽤，每隔⼀个时间间隔，发送⼀个 <code>探测报⽂</code>，该</p><p>探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息</p><p>通知给上层应⽤程序。</p><h2 id="TCP-应该如何-Socket-编程？"><a href="#TCP-应该如何-Socket-编程？" class="headerlink" title="TCP 应该如何 Socket 编程？"></a>TCP 应该如何 Socket 编程？</h2><p>服务端和客户端初始化 socket，得到文件描述符；<br>服务端调用 bind，将绑定在 IP 地址和端口;<br>服务端调用 listen，进行监听；<br>服务端调用 accept，等待客户端连接；<br>客户端调用 connect，向服务器端的地址和端口发起连接请求；<br>服务端 accept 返回用于传输的 socket 的文件描述符；<br>客户端调用 write 写入数据；服务端调用 read 读取数据；<br>客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，<br>就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 close，表示连接关闭。</p><h3 id="服务器程序处于CLOSE-WAIT状态原因"><a href="#服务器程序处于CLOSE-WAIT状态原因" class="headerlink" title="服务器程序处于CLOSE_WAIT状态原因"></a>服务器程序处于CLOSE_WAIT状态原因</h3><p>如果我们的服务器程序处于CLOSE_WAIT状态的话，说明套接字是被动关闭的！<br>因为如果是CLIENT端主动断掉当前连接的话，那么双方关闭这个TCP连接共需要四个packet： </p><p>1.Client -&gt; FIN  -&gt; Server<br>2.Client &lt;- ACK  &lt;- Server   这时候Client端处于FIN_WAIT_2状态；而Server 程序处于CLOSE_WAIT状态。<br>3.Client &lt;- FIN  &lt;- Server   这时Server 发送FIN给Client，Server 就置为LAST_ACK状态。<br>4.Client -&gt; ACK  -&gt; Server   Client回应了ACK，那么Server 的套接字才会真正置为CLOSED状态。    </p><p>Server 程序处于CLOSE_WAIT状态，而不是LAST_ACK状态，说明还没有发FIN给Client，那么可能是在关闭连接之前还有许多数据要发送或者其他事要做，<br>导致没有发这个FIN packet。 </p><p>通过命令 <code>netstat -an|grep CLOSE_WAIT|wc -l</code> 查看当前服务器上处于 CLOSE_WAIT 状态的连接数，根据服务器上的业务量来判断 CLOSE_WAIT 数量是否超出了正常的范`<br><strong>解决方法</strong><br>建议从业务层面及时判断某个连接是否已经被对端关闭，即在程序逻辑中对连接及时进行关闭检查。</p><p>Java 中 IO 可以通过 read 方法来判断，当 read 方法返回 -1 时则表示流已经到达末尾，可以使用 close 方法关闭该链接。</p>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
      <url>2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>class Solution {<br>    public int[] getLeastNumbers(int[] nums, int k) {<br>        int[] arr = new int[k];<br>        if(k==0) return arr;<br>        PriorityQueue<Integer> queue= new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1);</p><pre><code>    for(int num :nums)&#123;        queue.add(num);        if(queue.size()&gt;k)&#123;            queue.poll();        &#125;    &#125;    for(int i = 0 ; i &lt; arr.length;i++)&#123;        arr[i]=queue.poll();    &#125;    return arr;&#125;</code></pre><p>}<br>时间复杂度：O(nlogk)，其中 nn 是数组 arr 的长度。由于大根堆实时维护前 kk 小值，所以插入删除都是 O(\log k)O(logk) 的时间复杂度，最坏情况下数组里 nn 个数都会插入，所以一共需要 O(nlogk) 的时间复杂度。</p><p>空间复杂度：O(k)，因为大根堆里最多 k 个数。</p><h2 id="quickselect"><a href="#quickselect" class="headerlink" title="quickselect"></a>quickselect</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
      <url>2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>调整数组顺序使奇数位于偶数前面</p><p>类比快速排序paitition</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] exchange(int[] nums) &#123;        int cur &#x3D; 0;        for(int i &#x3D; 0 ; i &lt;nums.length;i++)&#123;            if(nums[i]%2&#x3D;&#x3D;1)&#123;                int tmp &#x3D; nums[cur];nums[cur] &#x3D; nums[i];nums[i]&#x3D;tmp;                cur++;            &#125;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序--颜色分类问题(荷兰国旗),数组中的第K个最大元素,</title>
      <link href="2020/12/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2020/12/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><hr><p><code>示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5</code></p><hr><h3 id="先排序再查找"><a href="#先排序再查找" class="headerlink" title="先排序再查找"></a>先排序再查找</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;        Arrays.sort(nums);        return nums[nums.length-k];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用最小堆"><a href="#使用最小堆" class="headerlink" title="使用最小堆"></a>使用最小堆</h3><p>我们可以使用最小堆来解决，一个个遍历原数组的值，添加到堆中，如果堆中元素的个数小于等于k的时候，我们就往堆中添加，添加之后如果堆中元素个数大于k的时候，我们就把最顶端的元素给移除掉，因为是最小堆，所以移除的就是堆中最小的值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;       &#x2F;&#x2F;最小堆       PriorityQueue&lt;Integer&gt; queue &#x3D; new PriorityQueue&lt;&gt;();       for(int num : nums)&#123;           queue.add(num);           if(queue.size()&gt;k)&#123;               queue.poll();           &#125;       &#125;       return queue.peek();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>快速排序是先选择一个中枢（一般我们选第一个），然后遍历后面的元素，最终会把数组分为两部分，前面部分比中枢值小，后面部分大于或等于中枢值，如果交换之后中枢值所在的位置就是从后面数第k个，我们直接返回中枢值即可，如果从后面数大于第k个，我们只需按照同样的方式从后面部分开始找即可。如果从后面数小于第k个，我们同样从前面部分开始查找，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;       &#x2F;&#x2F;快速选择       int lo &#x3D; 0;       int hi &#x3D; nums.length-1;       int target &#x3D; nums.length-k;       while(lo &lt;&#x3D; hi)&#123;           int pivot &#x3D; partition(nums,lo,hi);           if(target&lt;pivot)&#123;               hi &#x3D; pivot-1;           &#125;else if(target &gt; pivot)&#123;               lo &#x3D; pivot+1;           &#125;else &#123;               return nums[pivot];           &#125;       &#125;       return -1;    &#125;    public int partition(int[] nums,int l,int r)&#123;        int cur &#x3D; l;        int end &#x3D; r;        for(int i &#x3D; l;i&lt;end;i++)&#123;            if(nums[i]&lt;nums[end])&#123;                swap(nums,i,cur);                cur++;            &#125;        &#125;        swap(nums,cur,end);        return cur;    &#125;    public void swap(int[] nums, int i, int j)&#123;        int tmp &#x3D; nums[i];        nums[i]&#x3D;nums[j];        nums[j]&#x3D;tmp;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="颜色分类-荷兰国旗问题"><a href="#颜色分类-荷兰国旗问题" class="headerlink" title="颜色分类 荷兰国旗问题"></a>颜色分类 荷兰国旗问题</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。</p><p><code>要求额外空间复杂度O(1)，时间复杂度O(N)</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public void sortColors(int[] nums) &#123;        &#x2F;&#x2F;partition        partition(nums,0,nums.length-1,1);    &#125;    public void partition(int[] nums,int l, int r,int pivot)&#123;        int start &#x3D; l-1;        int end &#x3D; r+1;        while(l&lt;end)&#123;            if(nums[l]&lt;pivot)&#123;                swap(nums,++start,l++);            &#125;else if(nums[l]&gt;pivot)&#123;                swap(nums,--end,l);            &#125;else &#123;                l++;            &#125;        &#125;    &#125;    public void swap(int[] nums,int i, int j)&#123;        int tmp &#x3D; nums[i];        nums[i]&#x3D;nums[j];        nums[j]&#x3D;tmp;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] exchange(int[] nums) &#123;        int cur &#x3D; 0;        for(int i &#x3D; 0 ; i &lt;nums.length;i++)&#123;            if(nums[i]%2&#x3D;&#x3D;1)&#123;                int tmp &#x3D; nums[cur];nums[cur] &#x3D; nums[i];nums[i]&#x3D;tmp;                cur++;            &#125;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leedcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> leedcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/24/%E9%9B%86%E5%90%88/hashmap/"/>
      <url>2020/12/24/%E9%9B%86%E5%90%88/hashmap/</url>
      
        <content type="html"><![CDATA[<p>而<code>加载因子就是表示Hash表中元素的填满程度。</code></p><p><code>加载因子 = 填入表中的元素个数 / 散列表的长度</code></p><p><code>如果负载因子设置过大或过小会有什么问题？</code></p><p>首先知道负载因子的大小是主要就是决定了HashMap的数据密度的嘛<br>如果负载因子越大数据密度越大，<br><strong>加载因子越大</strong>，填满的元素越多，空间利用率越高，但发生冲突的机会变大了；<br>就会可能发生碰撞的几率越高，数组中的链表也会越容易长， 这样的话造成查询和插入时的比较次数增多，性能会下降。（可能又引出一个面试题：如何解决Hash碰撞问题？）</p><p><strong>加载因子越小，</strong>填满的元素越少，冲突发生的机会减小，但空间浪费了更多了，而且还会提高扩容rehash操作的次数。<br>如果负载因子越小，就会越容易触发扩容，虽然数据密度也越小，发生碰撞几率小，数组中链表越短对于查询和插入时比较次数也会少一些，性能也会提高。<br>但是扩容会影响性能，<br>HashMap 初始容量大小默认是16，这是为了减少冲突发生的概率，当HashMap的数组长度到达一个临界值的时候，就会触发扩容，把所有元素rehash之后再放在扩容后的容器中，这是一个相当耗时的操作，所以扩容是件影响性能的。</p><p>冲突的机会越大，说明需要查找的数据还需要通过另一个途径查找，这样查找的成本就越高。因此，必须在“冲突的机会”与“空间利用率”之间，寻找一种平衡与折衷。</p><p>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少扩容rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，以便减少扩容操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="2020/12/23/test/"/>
      <url>2020/12/23/test/</url>
      
        <content type="html"><![CDATA[<p><img src="a.png" alt=" 这里输入图片描述"></p><p><img src="1.png" alt=" 这里输入图片描述"></p><!-- ![](/img/a.png) --><p><img src="a.png" alt=" 这里输入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/01/redis/LRU%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>2020/12/01/redis/LRU%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/01/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>2020/12/01/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>命令不区分大小写<br>Key区分大小写</p><p>help @命令 帮助文档</p><p><code>string</code> ：<br>set mset get mget incr incrby decr decrby strlen<br>setnx – 分布式锁</p><p>set key value [EX seconds] [PX milliseconds]  [NX |XX]</p><p>EX多少秒过期<br>PX多少毫秒过期<br>NX–setnx等价<br>XX  key存在的时候覆盖<br><code>应用场景：</code><br>订单号码，商品编号用incr生成<br>喜欢的文章数<br>incr items:001</p><p><code>hash</code>:    对应Java MAP&lt;String,Map(Object,Object)&gt;<br>hset  hget hmset hmget<br>hset person id 1<br>hgetall person<br>hlen hdel<br><code>应用场景购物车早期</code><br><code>购物车加几个</code> hincrby </p><p>hset shopcar:uid  33222 1 新增<br>hincrby shopcar:uid  33222 1 增加数量<br>商品总数 hlen shopcar:uid<br>全选 hgetall shopcar:uid</p><p><code>list</code><br>lpush  rpush lrange llen<br>    <code>微信文章订阅公众号码</code></p><p>lpush likeauthor:uid1024 11 22</p><p>lrange likeauthor:uid1024 0 -1</p><p><code>set</code> sadd srem smembers scard sismember srandmember spop<br>sdiff sinter  sunion<br><code>微信抽奖小程序</code>：spop（删除元素）/srandmember（不删除元素）<br>sadd choujiang:1001 1 2 3<br>显示有多少人参加了：scard choujiang:1001<br>任意抽奖N个：spop choujiang:1001 N<br><code>微信朋友圈点赞</code><br>新增点赞  sadd pub:msgID 点赞用户id<br>取消点赞  srem pub:msgID 点赞用户id<br>展现所有点赞过的用户：smembers pub:msgID<br>点赞用户数目统计 ：  scard pub:msgID<br>判断是否点赞过    sismembers pub:msgID 点赞用户id</p><p><code>好友关注社交关系</code>：<br>    <code>共同关注</code>  sinter s1 s2<br>    <code>我关注的人也关注了他</code>：<br><code>可能认识的人</code> sdiff s1 s2<br>            sdiff s2 s1</p><p><code>zset</code>:<br>zadd zrem zrange zrevrange zincrby zcars zrank从小到大 zrevrank 从大到小获取元素的排名<br><code>根据商品的销售对商品进行排序显示</code><br>商品销量zadd goods:sellsort 9 1001 15 1002<br>1011商品又增加了两件zincrby goods:sellsort 2 1001<br>商品销量的前十名：zrange goods:sellsort 0 10 withscores<br><code>抖音热搜</code> ：<br>点击视频 zincrby hot:20201009 1 易洋千玺<br>展示前10    zrevrange hot:20201009 0 10 withscores</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/"/>
      <url>2020/12/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃 自己需要的同步资源，就形成了线程的死锁<br>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于`阻塞状态</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/29/spring/"/>
      <url>2020/11/29/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1.Spring概述"></a>1.Spring概述</h1><h2 id="1-1：什么是spring"><a href="#1-1：什么是spring" class="headerlink" title="1-1：什么是spring?"></a>1-1：什么是spring?</h2><p>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。<br>Spring使你能够编写更干净、更可管理、并且更易于测试的代码。</p><h2 id="1-2：Spring的优缺点是什么？"><a href="#1-2：Spring的优缺点是什么？" class="headerlink" title="1-2：Spring的优缺点是什么？"></a>1-2：Spring的优缺点是什么？</h2><p><code>优点：</code><br>   整个 Spring 优势，传达出⼀个信号，Spring 是⼀个综合性，且有很强的思想性框架，每学习⼀ 天，就能体会到它的⼀些优势。</p><h3>⽅便解耦，简化开发</h3>通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进⾏控制，避免硬编码所造成的 过度程序耦合。⽤户也不必再为单例模式类、属性⽂件解析等这些很底层的需求编写代码，可以更 专注于上层的应⽤。<h3>AOP编程的⽀持</h3>通过Spring的AOP功能，⽅便进⾏⾯向切⾯的编程，许多不容易⽤传统OOP实现的功能可以通过 AOP轻松应付。<h3>声明式事务的⽀持</h3>@Transactional可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式⽅式灵活的进⾏事务的管理，提⾼ 开发效率和质量。<h3>⽅便程序的测试</h3>可以⽤⾮容器依赖的编程⽅式进⾏⼏乎所有的测试⼯作，测试不再是昂贵的操作，⽽是随⼿可做的 事情。<h3>⽅便集成各种优秀框架</h3>Spring可以降低各种框架的使⽤难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、 Quartz等）的直接⽀持。<h3>降低JavaEE API的使⽤难度</h3>Spring对JavaEE API（如JDBC、JavaMail、远程调⽤等）进⾏了薄薄的封装层，使这些API的使⽤ 难度⼤为降低。<h3>源码是经典的 Java 学习范例</h3>Spring的源代码设计精妙、结构清晰、匠⼼独⽤，处处体现着⼤师对Java设计模式灵活运⽤以及对 Java技术的⾼深造诣。它的源代码⽆意是Java技术的最佳实践的范例。<p><code>缺点</code><br>   使用了大量的反射机制，反射机制非常占用内存。</p><h2 id="1-3：Spring-有哪些配置方式"><a href="#1-3：Spring-有哪些配置方式" class="headerlink" title="1-3：Spring 有哪些配置方式"></a>1-3：Spring 有哪些配置方式</h2><p><code>1、XML 配置文件。</code></p><p>Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。<br>这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。<br>它们通常以 bean 标签开头。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>2、注解配置。</code></p><p>可以通过在相关的类，方法或字段声明上使用注解，<br>将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。<br>默认情况下，Spring 容器中未打开注解装配。<br>因此，需要在使用它之前在 Spring 配置文件中启用它。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;beans&gt;&lt;context:annotation-config&#x2F;&gt;&lt;!-- bean definitions go here --&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>3、Java Config 配置。</code></p><p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<br>@Bean 注解扮演与 <bean /> 元素相同的角色。<br>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 Bean 间依赖关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class StudentConfig &#123;        @Bean    public StudentBean myStudent() &#123;        return new StudentBean();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-Spring用到的设计模式有哪些"><a href="#2-Spring用到的设计模式有哪些" class="headerlink" title="2.Spring用到的设计模式有哪些"></a>2.Spring用到的设计模式有哪些</h1><ol><li>工厂模式:通过 BeanFactory 或 ApplicationContext 创建 bean 对象。</li><li>单例模式:Bean默认为单例模式。<br> xml : <bean id="userService" class="top.snailclimb.UserService" scope="singleton"/><br> 注解：@Scope(value = “singleton”)</li><li>代理模式:Spring 的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术;</li><li>模板模式:<br>Spring 中 jdbcTemplate、hibernateTemplate 等<br>以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。<br>一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，<br>而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</li><li>观察者模式:<br>Spring 事件驱动模型就是观察者模式，<br>比如我们每次添加商品的时候都需要重新更新商品索引，<br>这个时候就可以利用观察者模式来解决这个问题。</li><li>适配器模式<ul><li>在SpringAOP和SpringMVC中都有适配器模式<br>虽然Spring AOP 的实现是基于代理模式，<br>但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，<br>比如说Spring预定义要通过对应的适配器，<br>适配成 MethodInterceptor接口(方法拦截器)类型的对象<br>如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice</li></ul></li></ol><ul><li>spring MVC中的适配器模式<br>在Spring MVC中，DispatcherServlet根据请求信息<br>调用HandlerMapping，<br>解析请求对应的Handler。<br>解析到对应的 Handler,也就是我们平常说的 Controller 控制器后，<br>开始由HandlerAdapter 适配器处理。<br>HandlerAdapter 作为期望接口，<br>具体的适配器实现类用于对目标类进行适配，<br>Controller 作为需要适配的类。<br>因为Spring MVC 中的 Controller 种类众多，<br>不同类型的 Controller 通过不同的方法来对请求进行处理。<br>如果不利用适配器模式的话，<br>DispatcherServlet 直接获取对应类型的 Controller，<br>需要的自行来判断</li></ul><ol start="7"><li>装饰者模式<br>当我们需要修改原有的功能，<br>但我们又不愿直接去修改原有的代码时，<br>设计一个Decorator套在原有代码外面<br>Spring 中配置 DataSource 的时候，<br>DataSource 可能是不同的数据库和数据源。<br>我们能否根据客户的需求在少<br>修改原有类的代码下动态切换不同的数据源<br>这个时候就要用到装饰者模式。<br>Spring 中用到的包装器模式<br>在类名上含有 Wrapper或者 Decorator。<br>这些类基本上都是动态地给一个对象添加一些额外的职责</li></ol><h1 id="3-循环依赖"><a href="#3-循环依赖" class="headerlink" title="3. 循环依赖"></a>3. 循环依赖</h1><h2 id="3-1：什么是Spring的循环依赖"><a href="#3-1：什么是Spring的循环依赖" class="headerlink" title="3-1：什么是Spring的循环依赖"></a>3-1：什么是Spring的循环依赖</h2><p>就是有一个 A 对象，创建 A 的时候发现 A 对象依赖 B，<br>然后去创建 B 对象的时候，又发现 B 对象依赖 C，<br>然后去创建 C 对象的时候，又发现 C 对象依赖 A。</p><h2 id="3-2：什么是三级缓存"><a href="#3-2：什么是三级缓存" class="headerlink" title="3-2：什么是三级缓存"></a>3-2：什么是三级缓存</h2><ol><li>第一级缓存：单例缓存池 singletonObjects。</li><li>第二级缓存：早期提前暴露的对象缓存 earlySingletonObjects。</li><li>第三级缓存：singletonFactories 单例对象工厂缓存</li></ol><p>先从一级缓存singletonObjects中去获取，<br>如果获取到 Bean 就直接返回。<br>如果获取不到或者对象正在创建中，<br>那就再从二级缓存earlySingletonObjects中获取，<br>如果获取到就直接返回。<br>如果前两级缓存都没成功返回，<br>且允许 singletonFactories(allowEarlyReference=true)<br>通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。<br>如果获取到了就从singletonFactories中移除，<br>并且放进earlySingletonObjects。<br>其实也就是从三级缓存移动到了二级缓存。是剪切、不是复制。</p><h2 id="3-3：什么是早期暴露的对象"><a href="#3-3：什么是早期暴露的对象" class="headerlink" title="3-3：什么是早期暴露的对象"></a>3-3：什么是早期暴露的对象</h2><p>你是一个不完整的对象，你的属性还没有值，<br>你的对象也没有被初始化。这就是早期暴露的对象，<br>只是提前拿出来给你认识认识。但他非常重要。<br>这是多级缓存解决循环依赖问题的一个巧妙的地方。</p><h2 id="3-4：如何解决循环依赖"><a href="#3-4：如何解决循环依赖" class="headerlink" title="3-4：如何解决循环依赖"></a>3-4：如何解决循环依赖</h2><p>主要是用三级缓存来解决循环依赖问题</p><p>比如说A、B类的互相依赖注入，使用属性field注入循环依赖来解决</p><ol><li>使用context.getBean(A.class)，<br>旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，<br>显然初次获取A是不存在的，因此走A的创建之路~</li><li>实例化A（注意此处仅仅是实例化），<br>并将它放进缓存（此时A已经实例化完成，已经可以被引用了）</li><li>初始化A：@Autowired依赖注入B（此时需要去容器内获取B）</li><li>为了完成依赖注入B，会通过getBean(B)去容器内找B。<br>但此时B在容器内不存在，就走向B的创建之路~</li><li>实例化B，并将其放入缓存。（此时B也能够被引用了）</li><li>初始化B，@Autowired依赖注入A（此时需要去容器内获取A）</li><li>此处重要：初始化B时会调用getBean(A)去容器内找到A，<br>因为A已经实例化完成了并且放进了缓存里，<br>所以这个时候去看缓存里是已经存在A的引用了的，<br>所以getBean(A)能够正常返回</li><li>B初始化成功（此时已经注入A成功了，已成功持有A的引用了），<br>return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中</li><li> 因为B实例已经成功返回了，因此最终A也初始化成功</li><li>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，</li></ol><h1 id="4-IOC"><a href="#4-IOC" class="headerlink" title="4.IOC"></a>4.IOC</h1><h2 id="4-1：IOC原理"><a href="#4-1：IOC原理" class="headerlink" title="4-1：IOC原理"></a>4-1：IOC原理</h2><p>ioc也叫控制反转，是一种设计思想。<br>就是将对象的创建和管理交由spring管理。<br>ioc容器本质上是一个map，存放着各种bean对象，<br>key是bean对象名，value是bean配置信息。<br>bean对象的创建、依赖关系都交由ioc容器完成，<br>使用时不需要关心bean对象什么时候创建<br>也不需要手动维护对象间的关系。<br>ioc容器相当于一个第三方的容器，<br>关联着使用资源的双方。<br>比如一个user类和userinfo类，<br>user类要使用userinfo类的属性，<br>需要调用时创建user类和userinfo类的的对象，<br>然后进行属性注入。<br>但是如果将user和userinfo都交由ioc容器管理，<br>调用时只需要从ioc容器中取出user对象，<br>那么user对象需要的userinfo属性会在ioc容器中进行注入，<br>取出的user对象是已经完成依赖注入的对象。</p><h3 id="4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）"><a href="#4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）" class="headerlink" title="4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）"></a>4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）</h3><p>首先初始化上下文，<br>生成ClassPathXmlApplicationContext对象，<br>在获取resourcePatternResolver对象将xml解析成Resource对象。<br>利用生成的 context、resource 初始化工厂，<br>并将 resource 解析成 beandefinition,<br>再将 beandefinition 注册到 beanfactory 中。</p><h3 id="4-1-2：IOC好处"><a href="#4-1-2：IOC好处" class="headerlink" title="4-1-2：IOC好处"></a>4-1-2：IOC好处</h3><p>它将最小化应用程序中的代码量。<br>它以最小的影响和最少的侵入机制促进松耦合。<br>它支持即时的实例化和延迟加载 Bean 对象。<br>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</p><h2 id="4-2：IOC的实现机制（继续扩产—芋头）"><a href="#4-2：IOC的实现机制（继续扩产—芋头）" class="headerlink" title="4-2：IOC的实现机制（继续扩产—芋头）"></a>4-2：IOC的实现机制（继续扩产—芋头）</h2><p>Spring 中的 IoC 的实现原理，就是工厂模式加反射机制</p><p>a. 加载配置文件，解析成 BeanDefinition 放在 Map 里。<br>b. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，<br>   拿出 Class 对象进行实例化，同时，如果有依赖关系，<br>   将递归调用 getBean 方法 —— 完成依赖注入。</p><h2 id="4-2：IOC容器种类"><a href="#4-2：IOC容器种类" class="headerlink" title="4-2：IOC容器种类"></a>4-2：IOC容器种类</h2><p>一共是两种</p><h3 id="4-2-1：BeanFactory与ApplicationContext区别"><a href="#4-2-1：BeanFactory与ApplicationContext区别" class="headerlink" title="4-2-1：BeanFactory与ApplicationContext区别"></a>4-2-1：BeanFactory与ApplicationContext区别</h3><p>ApplicationContext和BeanFactory是Spring的两大核心接口。<br>都可以当做Spring的容器<br>其中ApplicationContext是 BeanFactory的子接口。<br>(1）BeanFactory:是Spring里面最底层的接口，包含了各种Bean的定义，读取bean<br>配置文档，管理 bean 的加载、实例化，控制 bean的生命周期，维护 bean之间的依赖关系。<br>ApplicationContext 接口作为 BeanFactory的派生，除了提供BeanFactory所具有的功能外，<br>还提供了更完整的框架功能:继承MessageSource，因此支持国际化。统一的资源文件访问<br>方式。提供在监听器中注册bean的事件。同时加载多个配置文件。载入多个(有继承关系）<br>上下文，使得每个上下文都专注于一个特定的层次，比如应用web层<br>(2）BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时<br>(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring<br>的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用<br>getBean方法才会抛出异常。<br>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动<br>时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注<br>入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当<br>你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的 BeanFactory，<br>ApplicationContext唯一的不足是占用内存空间。当应用程序配置Bean较多时，<br>程序启动较慢。<br>(3)BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，<br>如使用 ContextLoader。<br>（4） BeanFactory和 ApplicationContext 都支持 BeanPostProcessor、<br>BeanFactoryPostProcessor的使用，但两者之间的区别是: BeanFactory需要手动注册，而<br>ApplicationContext则是自动注册。</p><h4 id="4-2-1-1：请介绍下常用的-BeanFactory-容器？"><a href="#4-2-1-1：请介绍下常用的-BeanFactory-容器？" class="headerlink" title="4-2-1-1：请介绍下常用的 BeanFactory 容器？"></a>4-2-1-1：请介绍下常用的 BeanFactory 容器？</h4><p>BeanFactory 最常用的是 XmlBeanFactory 。<br>它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p><h4 id="4-2-1-2：请介绍下常用的-ApplicationContext-容器？"><a href="#4-2-1-2：请介绍下常用的-ApplicationContext-容器？" class="headerlink" title="4-2-1-2：请介绍下常用的 ApplicationContext 容器？"></a>4-2-1-2：请介绍下常用的 ApplicationContext 容器？</h4><p>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，<br>                                    并生成上下文定义。应用程序上下文从程序环境变量中取得。<br>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。示<br>3、XmlWebApplicationContext ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</p><p>第四种 ApplicationContext 容器，ConfigServletWebServerApplicationContext 。</p><h3 id="4-2-2：BeanFactory和FactoryBean的区别（51期）"><a href="#4-2-2：BeanFactory和FactoryBean的区别（51期）" class="headerlink" title="4-2-2：BeanFactory和FactoryBean的区别（51期）"></a>4-2-2：BeanFactory和FactoryBean的区别（51期）</h3><p>BeanFactory是个Factory，也就是IOC容器或对象工厂，<br>FactoryBean是个Bean。在Spring中，<br>所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。<br>但对FactoryBean而言，这个Bean不是简单的Bean，<br>而是一个能生产或者修饰对象生成的工厂Bean,<br>它的实现与设计模式中的工厂模式和修饰器模式类似</p><h4 id="4-2-2-1：BeanFactory"><a href="#4-2-2-1：BeanFactory" class="headerlink" title="4-2-2-1：BeanFactory"></a>4-2-2-1：BeanFactory</h4><p>以Factory结尾，表示它是一个工厂类(接口)，<br>它负责生产和管理bean的一个工厂。<br>在Spring中，BeanFactory是IOC容器的核心接口，<br>它的职责包括：实例化、定位、配置<br>应用程序中的对象及建立这些对象间的依赖。</p><h4 id="4-2-2-2：FactoryBean"><a href="#4-2-2-2：FactoryBean" class="headerlink" title="4-2-2-2：FactoryBean"></a>4-2-2-2：FactoryBean</h4><p>一般情况下，Spring通过反射机制利用<bean><br>的class属性指定实现类实例化Bean，<br>在某些情况下，实例化Bean过程比较复杂，<br>如果按照传统的方式，<br>则需要在<bean>中提供大量的配置信息。<br>配置方式的灵活性是受限的，<br>这时采用编码的方式可能会得到一个简单的方案。</p><h2 id="4-3：依赖注入"><a href="#4-3：依赖注入" class="headerlink" title="4-3：依赖注入"></a>4-3：依赖注入</h2><h3 id="4-3-1：依赖注入概念"><a href="#4-3-1：依赖注入概念" class="headerlink" title="4-3-1：依赖注入概念"></a>4-3-1：依赖注入概念</h3><p>在依赖注入中，不必主动、手动创建对象，但必须描述如何创建它们。<br>不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。<br>然后，再由 IoC 容器将它们装配在一起。</p><h3 id="4-3-2：有哪些不同类型的IOC（依赖注入）方式？"><a href="#4-3-2：有哪些不同类型的IOC（依赖注入）方式？" class="headerlink" title="4-3-2：有哪些不同类型的IOC（依赖注入）方式？"></a>4-3-2：有哪些不同类型的IOC（依赖注入）方式？</h3><p><code>构造器依赖注入</code>： 构造器依赖注入通过容器触发一个类的构造器来实现的，<br>                  该类有一系列参数，每个参数代表一个对其他类的依赖。<br><code>Setter方法注入</code>： Setter方法注入是容器通过调用无参构造器或无参static工厂<br>                  方法实例化bean之后，调用该bean的setter方法，<br>                  即实现了基于setter的依赖注入。<br><code>接口注入</code>：       定义接口</p><h4 id="4-3-2-1：三种方式的区别小结"><a href="#4-3-2-1：三种方式的区别小结" class="headerlink" title="4-3-2-1：三种方式的区别小结"></a>4-3-2-1：三种方式的区别小结</h4><ol><li>基于构造器的注入，会固定依赖注入的顺序；<br>该方式不允许我们创建bean对象之间的循环依赖关系，<br>这种限制其实是一种利用构造器来注入的益处<br>没有注意到使用setter注入的时候，Spring能解决循环依赖的问题；</li><li>基于setter的注入，只有当对象是需要被注入的时候它才会帮助我们注入依赖，<br>而不是在初始化的时候就注入；另一方面如果你使用基于constructor注入，<br>CGLIB不能创建一个代理，迫使你使用基于接口的代理或虚拟的无参数构造函数。</li><li>使用直接在成员变量上写上注解来注入这种方式<br>看起来非常好，精短，可读性高，不需要多余的代码，也方便维护；</li></ol><h2 id="4-4：IOC与DI的的区别（修改）"><a href="#4-4：IOC与DI的的区别（修改）" class="headerlink" title="4-4：IOC与DI的的区别（修改）"></a>4-4：IOC与DI的的区别（修改）</h2><p>IOC:  控制反转,将类的对象的创建交给Spring类管理创建.<br>DI:   依赖注入,将类里面的属性在创建类的过程中给属性赋值. </p><h2 id="4-5：Spring-框架中有哪些不同类型的事件？"><a href="#4-5：Spring-框架中有哪些不同类型的事件？" class="headerlink" title="4-5：Spring 框架中有哪些不同类型的事件？"></a>4-5：Spring 框架中有哪些不同类型的事件？</h2><ol><li>上下文更新事件（ContextRefreshedEvent）：<br>该事件会在ApplicationContext 被初始化或者更新时发布。<br>也可以在调用ConfigurableApplicationContext 接口中的 #refresh() 方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：<br>当容器调用ConfigurableApplicationContext 的 #start()<br>方法开始/重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：<br>当容器调用 ConfigurableApplicationContext 的<br>#stop() 方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：<br>当ApplicationContext 被关闭时触发该事件。<br>容器被关闭时，其管理的所有单例 Bean 都被销毁。</li><li>请求处理事件（RequestHandledEvent）：<br>在 We b应用中，当一个HTTP 请求（request）结束触发该事件。</li><li>通过扩展 ApplicationEvent 类来开发自定义的事件</li></ol><h1 id="5-AOP"><a href="#5-AOP" class="headerlink" title="5.AOP"></a>5.AOP</h1><h2 id="5-1：什么是aop"><a href="#5-1：什么是aop" class="headerlink" title="5-1：什么是aop"></a>5-1：什么是aop</h2><p>AOP面向切面编程, 它与OOP我认为是共同作用的，<br>他所提供了与 OOP 不同的抽象软件结构的视角。<br>   在 OOP 中，以类( Class )作为基本单元<br>   在 AOP 中，以切面( Aspect )作为基本单元。<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:<br>   如何通过 PointCut 和 Advice 定位到特定的 JoinPoint 上。<br>   如何在 Advice 中编写切面代码。</p><h3 id="5-1-1：什么是-Aspect"><a href="#5-1-1：什么是-Aspect" class="headerlink" title="5-1-1：什么是 Aspect"></a>5-1-1：什么是 Aspect</h3><p>@Aspect 注解的类就是切面<br>Aspect 由 PointCut 和 Advice 组成。<br>   它既包含了横切逻辑的定义，也包括了连接点的定义。<br>   Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</p><h3 id="5-1-2：什么是-JoinPoint"><a href="#5-1-2：什么是-JoinPoint" class="headerlink" title="5-1-2：什么是 JoinPoint"></a>5-1-2：什么是 JoinPoint</h3><p>JoinPoint ，切点，程序运行中的一些时间点, 例如：<br>一个方法的执行。<br>或者是一个异常的处理。<br>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p><h3 id="5-1-3：什么是-PointCut"><a href="#5-1-3：什么是-PointCut" class="headerlink" title="5-1-3：什么是 PointCut"></a>5-1-3：什么是 PointCut</h3><p>PointCut 是匹配 JoinPoint 的条件。</p><p>Advice 是和特定的 PointCut 关联的，<br>并且在 PointCut 相匹配的 JoinPoint 中执行。<br>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，<br>但是我们并不希望在所有的方法上都添加 Advice 。<br>而 PointCut 的作用，就是提供一组规则 来匹配 JoinPoint ，<br>给满足规则的 JoinPoint 添加 Advice 。</p><h3 id="5-1-3-4：关于-JoinPoint-和-PointCut-的区别"><a href="#5-1-3-4：关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="5-1-3~4：关于 JoinPoint 和 PointCut 的区别"></a>5-1-3~4：关于 JoinPoint 和 PointCut 的区别</h3><ol><li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。<br>而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，<br>通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li><li>Advice 是在 JoinPoint 上执行的，<br>而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li></ol><p>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。<br>然后，Advice 在查询到 JoinPoint 上执行逻辑。</p><h3 id="5-1-5：什么是-Advice-？"><a href="#5-1-5：什么是-Advice-？" class="headerlink" title="5-1-5：什么是 Advice ？"></a>5-1-5：什么是 Advice ？</h3><p>通知。<br>比如说特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。<br>Spring AOP 使用一个 Advice 作为拦截器，<br>在 JoinPoint “周围”维护一系列的拦截器。</p><h4 id="5-1-5-1：有哪些类型的-Advice？"><a href="#5-1-5-1：有哪些类型的-Advice？" class="headerlink" title="5-1-5-1：有哪些类型的 Advice？"></a>5-1-5-1：有哪些类型的 Advice？</h4><ol><li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，<pre><code>     并使用 @Before 注解标记进行配置。</code></pre></li><li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，<pre><code>              并使用 @AfterReturning 注解标记进行配置。</code></pre></li><li>After Throwing - 这些类型的 Advice 仅在 JoinPoint <pre><code>             方法通过抛出异常退出并使用              @AfterThrowing 注解标记配置时执行。</code></pre></li><li>After Finally - 这些类型的 Advice 在连接点方法之后执行，<pre><code>            无论方法退出是正常还是异常返回，            并使用 @After 注解标记进行配置。</code></pre></li><li>Around - 这些类型的 Advice 在连接点之前和之后执行，<pre><code>     并使用 @Around 注解标记进行配置。</code></pre></li></ol><h3 id="5-1-6：什么是-Target"><a href="#5-1-6：什么是-Target" class="headerlink" title="5-1-6：什么是 Target"></a>5-1-6：什么是 Target</h3><p>Target ，织入 Advice 的目标对象。目标对象也被称为 Advised Object 。</p><p>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，<br>因此 Advised Object 总是一个代理对象(Proxied Object) 。<br>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象。<br>Advice + Target Object = Advised Object = Proxy 。</p><h3 id="5-1-7：什么是编织（Weaving）"><a href="#5-1-7：什么是编织（Weaving）" class="headerlink" title="5-1-7：什么是编织（Weaving）"></a>5-1-7：什么是编织（Weaving）</h3><p>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，叫做编织。<br>在 Spring AOP 中，编织在运行时执行，即动态代理</p><h3 id="5-1-8：AOP中的切面、切点、连接点、通知，四者的关系"><a href="#5-1-8：AOP中的切面、切点、连接点、通知，四者的关系" class="headerlink" title="5-1-8：AOP中的切面、切点、连接点、通知，四者的关系"></a>5-1-8：AOP中的切面、切点、连接点、通知，四者的关系</h3><p>切面，一定要给spring 管理<br>切点，目的是为了将注解写在上面而已<br>pointcut是连接点的集合<br>通知—》配置切点</p><h2 id="5-2：aop有哪些实现方式"><a href="#5-2：aop有哪些实现方式" class="headerlink" title="5-2：aop有哪些实现方式"></a>5-2：aop有哪些实现方式</h2><p>实现 AOP 的技术，主要分为两大类：</p><ol><li>静态代理 - 指使用 AOP 框架提供的命令进行编译，<pre><code>      从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</code></pre>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，<br>  实现类加载时编织时增强，从而实现链路追踪的透明埋点。</li><li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，<pre><code>     因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：     JDK 动态代理     CGLIB</code></pre></li></ol><h3 id="5-2-1：Spring-什么时候使用-JDK-动态代理，什么时候使用-CGLIB-呢"><a href="#5-2-1：Spring-什么时候使用-JDK-动态代理，什么时候使用-CGLIB-呢" class="headerlink" title="5-2-1：Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢"></a>5-2-1：Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢</h3><ol><li>JDK 动态代理<br>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。<br>JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</li><li>CGLIB 动态代理<br>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。<br>当然，Spring 也支持配置，强制使用CGLIB动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，<br>可以在运行时动态的生成某个类的子类，CGLIB 是通过继承的方式做的动态代理，<br>因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的。</li></ol><h3 id="5-2-2：是编译时期进行织入，还是运行期进行织入"><a href="#5-2-2：是编译时期进行织入，还是运行期进行织入" class="headerlink" title="5-2-2：是编译时期进行织入，还是运行期进行织入"></a>5-2-2：是编译时期进行织入，还是运行期进行织入</h3><p>运行期，生成字节码，再加载到虚拟机中，<br>JDK是利用反射原理，CGLIB使用了ASM原理。</p><h3 id="5-2-3：初始化时期织入还是获取对象时织入"><a href="#5-2-3：初始化时期织入还是获取对象时织入" class="headerlink" title="5-2-3：初始化时期织入还是获取对象时织入"></a>5-2-3：初始化时期织入还是获取对象时织入</h3><p>初始化的时候，已经将目标对象进行代理，放入到spring 容器中</p><h3 id="5-2-4：spring-AOP-默认使用jdk动态代理还是cglib"><a href="#5-2-4：spring-AOP-默认使用jdk动态代理还是cglib" class="headerlink" title="5-2-4：spring AOP 默认使用jdk动态代理还是cglib"></a>5-2-4：spring AOP 默认使用jdk动态代理还是cglib</h3><p>要看条件，如果实现了接口的类，是使用jdk。<br>如果没实现接口，就使用cglib。</p><h3 id="5-2-5：动态代理步骤"><a href="#5-2-5：动态代理步骤" class="headerlink" title="5-2-5：动态代理步骤"></a>5-2-5：动态代理步骤</h3><h4 id="5-2-5-1：JDK动态代理的步骤"><a href="#5-2-5-1：JDK动态代理的步骤" class="headerlink" title="5-2-5-1：JDK动态代理的步骤"></a>5-2-5-1：JDK动态代理的步骤</h4><ol><li>先检查委托类是否实现了相应接口，保证被访问方法在接口中也要有定义</li><li>创建一个实现InvocationHandler接口的类</li><li>在类中定义一个被代理对象的成员属性，为了扩展方便可以直接使用Object类，<br>也可以根据需求定义相应的接口</li><li>在invoke方法中实现对委托对象的调用，根据需求对方法进行增强</li><li>使用Proxy.newProxyInstance(…)方法创建代理对象，并提供要给获取代理对象的方法</li></ol><h4 id="5-2-5-2：cglib动态代理实现步骤"><a href="#5-2-5-2：cglib动态代理实现步骤" class="headerlink" title="5-2-5-2：cglib动态代理实现步骤"></a>5-2-5-2：cglib动态代理实现步骤</h4><ol><li>创建一个实现MethodInterceptor接口的类</li><li>在类中定义一个被代理对象的成员属性，<br>为了扩展方便可以直接使用Object类，也可以根据需求定义相应的接口</li><li>在invoke方法中实现对委托对象的调用，根据需求对方法进行增强</li><li>使用Enhancer创建生成代理对象，并提供要给获取代理对象的方法</li></ol><h3 id="5-2-6：jdk动态代理-VS-cglib"><a href="#5-2-6：jdk动态代理-VS-cglib" class="headerlink" title="5-2-6：jdk动态代理 VS cglib"></a>5-2-6：jdk动态代理 VS cglib</h3><h4 id="5-2-6-1：两种代理模式的比较"><a href="#5-2-6-1：两种代理模式的比较" class="headerlink" title="5-2-6-1：两种代理模式的比较"></a>5-2-6-1：两种代理模式的比较</h4><ol><li>JDK Proxy 的优势：<ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，<br>JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，<br>而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul></li><li>cglib 优势：<ul><li>有的时候调用目标可能不便实现额外接口，<br>从某种角度看，限定调用者实现接口是有些侵入性的实践，<br>类似 cglib 动态代理就没有这种限制。</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li></ul></li></ol><h4 id="5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？"><a href="#5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？" class="headerlink" title="5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？"></a>5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？</h4><p>JDK有一个限制，就是它只能为接口创建代理实例，<br>而对于没有通过接口定义业务方法的类,需要通过CGLib创建动态代理实例  </p><h4 id="5-2-6-3：JDK的动态代理为什么需要接口"><a href="#5-2-6-3：JDK的动态代理为什么需要接口" class="headerlink" title="5-2-6-3：JDK的动态代理为什么需要接口"></a>5-2-6-3：JDK的动态代理为什么需要接口</h4><ol><li>在需要继承proxy类获得有关方法和InvocationHandler构造方法传参的同时,<br>java不能同时继承两个类，我们需要和想要代理的类建立联系，只能实现一个接口   </li><li>需要反射获得代理类的有关参数，必须要通过某个类，<br>反射获取有关方法，</li><li>成功返回的是object类型，要获取原类，<br>只能继承/实现，或者就是那个代理类</li><li>对具体实现的方法内部并不关心，<br>这个交给InvocationHandler.invoke那个方法里去处理就好了，<br>我只想根据你给我的接口反射出对我有用的东西。</li><li>考虑到设计模式，以及proxy编者编写代码的逻辑</li></ol><h2 id="5-3：Spring-AOP-and-AspectJ-AOP-有什么区别"><a href="#5-3：Spring-AOP-and-AspectJ-AOP-有什么区别" class="headerlink" title="5-3：Spring AOP and AspectJ AOP 有什么区别"></a>5-3：Spring AOP and AspectJ AOP 有什么区别</h2><ol><li>代理方式不同<br>   Spring AOP 基于动态代理方式实现。<br>   AspectJ AOP 基于静态代理方式实现。</li><li>PointCut 支持力度不同<br>   Spring AOP 仅支持方法级别的 PointCut 。<br>   AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li></ol><h2 id="5-4：Spring-如何使用-AOP-切面"><a href="#5-4：Spring-如何使用-AOP-切面" class="headerlink" title="5-4：Spring 如何使用 AOP 切面"></a>5-4：Spring 如何使用 AOP 切面</h2><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p><p>基于 XML 方式的切面实现。<br>基于 注解 方式的切面实现。<br>目前，主流喜欢使用 注解 方式。</p><h2 id="5-5：aop的应用场景有哪些"><a href="#5-5：aop的应用场景有哪些" class="headerlink" title="5-5：aop的应用场景有哪些"></a>5-5：aop的应用场景有哪些</h2><p>1、日志记录<br>2、权限验证<br>3、效率检查<br>4、事务管理</p><h1 id="6-Spring-Bean"><a href="#6-Spring-Bean" class="headerlink" title="6.Spring Bean"></a>6.Spring Bean</h1><h2 id="6-1：什么是SpringBean"><a href="#6-1：什么是SpringBean" class="headerlink" title="6-1：什么是SpringBean"></a>6-1：什么是SpringBean</h2><p>Bean 由 Spring IoC 容器实例化，配置，装配和管理。</p><h2 id="6-1：Bean的五种作用域"><a href="#6-1：Bean的五种作用域" class="headerlink" title="6-1：Bean的五种作用域"></a>6-1：Bean的五种作用域</h2><p>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。<br>prototype : 每次请求都会创建一个新的 bean 实例。<br>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。<br>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。<br>global-session： 全局session作用域，<br>                 仅仅在基于portlet的web应用中才有意义，</p><h3 id="6-1-2：Spring中的单例bean的线程安全问题了解吗？"><a href="#6-1-2：Spring中的单例bean的线程安全问题了解吗？" class="headerlink" title="6-1-2：Spring中的单例bean的线程安全问题了解吗？"></a>6-1-2：Spring中的单例bean的线程安全问题了解吗？</h3><p>单例 bean 存在线程问题，<br>主要是因为当多个线程操作同一个对象的时候，<br>对这个对象的非静态成员变量的写操作会存在线程安全问题。</p><h4 id="6-1-2-1：常见的有两种解决办法"><a href="#6-1-2-1：常见的有两种解决办法" class="headerlink" title="6-1-2-1：常见的有两种解决办法"></a>6-1-2-1：常见的有两种解决办法</h4><ol><li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中定义一个ThreadLocal成员变量，<br>将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li></ol><h2 id="6-2：Bean的生命周期"><a href="#6-2：Bean的生命周期" class="headerlink" title="6-2：Bean的生命周期"></a>6-2：Bean的生命周期</h2><p>（1）实例化（必须的）构造函数构造对象<br>（2）装配（可选的）为属性赋值<br>（3）回调（可选的）（容器-控制类和组件-回调类）<br>（4）初始化(init-method=” “)<br>（5）就绪<br>（6）销毁（destroy-method=” “） </p><p>（1）实例化Bean：<br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，<br>或初始化bean的时候需要注入<br>另一个尚未初始化的依赖时，<br>容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，<br>当容器启动结束后，<br>通过获取BeanDefinition对象中的信息，实例化所有的bean。<br>（2）设置对象属性（依赖注入）：<br>实例化后的对象被封装在BeanWrapper对象中，紧接着，<br>Spring根据BeanDefinition中的信息<br>以及通过BeanWrapper提供的设置属性的接口完成依赖注入。<br>（3）处理Aware接口：<br>接着，Spring会检测该对象是否实现了xxxAware接口，<br>并将相关的xxxAware实例注入给Bean：<br>①如果这个Bean已经实现了BeanNameAware接口，<br>会调用它实现的setBeanName(String beanId)方法，<br>此处传递的就是Spring配置文件中Bean的id值；<br>②如果这个Bean已经实现了BeanFactoryAware接口，<br>会调用它实现的setBeanFactory()方法，<br>传递的是Spring工厂自身。<br>③如果这个Bean已经实现了ApplicationContextAware接口，<br>会调用setApplicationContext(ApplicationContext)方法，<br>传入Spring上下文；<br>（4）BeanPostProcessor：<br>如果想对Bean进行一些自定义的处理，<br>那么可以让Bean实现了BeanPostProcessor接口，<br>那将会调用postProcessBeforeInitialization(Object obj, String s)方法。<br>（5）InitializingBean 与 init-method：<br>如果Bean在Spring配置文件中配置了 init-method 属性，<br>则会自动调用其配置的初始化方法。<br>（6）如果这个Bean实现了BeanPostProcessor接口，<br>将会调用postProcessAfterInitialization(Object<br>obj, String s)方法；由于这个方法是在Bean初始化结束时使用的，<br>所以可以被应用于内存或缓存技术；<br>以上几个步骤完成后，Bean就已经被正确创建了，<br>之后就可以使用这个Bean了。<br>（7）DisposableBean：<br>当Bean不再需要时，会经过清理阶段，<br>如果Bean实现了DisposableBean这个接口，会调用其实现的<br>destroy()方法；<br>（8）destroy-method：<br>最后，如果这个Bean的Spring配置中<br>配置了destroy-method属性，<br>会自动调用其配置的销毁方法。<br>方法二：实现org.springframework.beans.factory.DisposableBean接口。<br>执行它的destroy()方法。<br>如果一个Bean实现了org.springframework.beans.factory.DisposableBean接口，<br>则会自动装配</p><h2 id="6-3：Spring的Bean注入方式"><a href="#6-3：Spring的Bean注入方式" class="headerlink" title="6-3：Spring的Bean注入方式"></a>6-3：Spring的Bean注入方式</h2><ol><li>set方法注入</li><li>构造器注入</li><li>静态工厂注入</li><li>实例工厂注入 </li><li><code>set注入</code><br>如果我们需要使用set注入，那么必须要为属性提供set方法，<br>Spring容器就是通过调用bean的set方法为属性注入值的。<br>而在xml文件中，使用set注入的方式就是通过property标签，</li><li><code>构造器注入</code><br>   就是通过调用bean所属类的带参构造器为bean的属性注入值。<br>我们如果需要使用构造器注入，就得为类提供包含参数的构造方法。<br>构造器注入，实际上有多种匹配属性值的方式，比如说<br>（一）匹配构造器的参数名称<br>  我们需要通过constructor-arg标签为构造器传入参数值，<br>每个constructor-arg标签对应直接匹配参数名<br>（二）匹配构造器的参数下标<br>  通过参数在参数列表中的下标进行匹配的方式。<br>通过参数的下标为构造器的参数赋值，<br>参实的下标从0开始。使用第一种方式配置，若赋值的类型与参数的类型不一致，<br>将会在容器初始化bean的时候抛出异常。<br>如果bean存在多个参数数量一样的构造器，<br>Spring容器会自动找到类型匹配的那个进行调用。<br>比如说，Car有如下两个构造器，Spring容器将会调用第二个，<br>因为上面的配置中，index = 1对应的value是double类型，<br>与第二个构造器匹配，而第一个不匹配：<br>（三）匹配构造器的参数类型<br>  直接通过匹配构造器的参数类型，<br>从而选择一个能够完全匹配的构造器，调用这个构造器完成bean的创建和属性注入。<br>类型并不需要按构造器中声明的顺序编写，Spring也能进行匹配。</li><li><code>静态工厂注入</code><br>  静态工厂注入就是我们编写一个静态的工厂方法，<br>这个工厂方法会返回一个我们需要的值，然后在配置文件中，<br>我们指定使用这个工厂方法创建bean。首先我们需要一个静态工厂，</li><li> <code>实例工厂</code>与静态工厂类似，不同的是，<br>静态工厂调用工厂方法不需要先创建工厂类的对象，<br>因为静态方法可以直接通过类调用，<br>所以在上面的配置文件中，并没有声明工厂类的bean。<br>但是，实例工厂，需要有一个实例对象，才能调用它的工厂方法。</li></ol><h2 id="6-4：接口与bean"><a href="#6-4：接口与bean" class="headerlink" title="6-4：接口与bean"></a>6-4：接口与bean</h2><h3 id="6-4-1：没有注入接口，使用时怎么能获取的接口"><a href="#6-4-1：没有注入接口，使用时怎么能获取的接口" class="headerlink" title="6-4-1：没有注入接口，使用时怎么能获取的接口"></a>6-4-1：没有注入接口，使用时怎么能获取的接口</h3><p>@Autowired是Spring的注解，Autowired默认先按byType，<br>如果发现找到多个bean，则，又按照byName方式比对，<br>如果还有多个，则报出异常；@Resource<br>默认按照名称(Byname)进行装配, 如果没有指定name属性，<br>当注解写在字段上时，默认取字段名，按照名称查找，<br>如果注解写在setter方法上默认取属性名进行装配。<br>当找不到与名称匹配的bean时才按照类型进行装配。<br>如果name属性一旦指定，就只会按照名称进行装配。<br>对于Controller获取实例的过程，使用@Autowired，<br>程序在spring的容器中查找类型是TestService的bean，<br>刚好找到有且只有一个此类型的bean，即testServiceImpl，<br>所以就把testServiceImpl自动装配到了controller<br>的实例testService中，testService其实就是TestServiceImpl实现类；<br>如果使用的是@Resource，<br>则是先在容器中查找名字为testService的bean，<br>但并没有找到，因为容器中的bean名字是TestServiceImpl<br>如果@Service没指定bean的value属性，<br>则注入bean的名字就是类名，如果指定了则是指定的名字，<br>然后再通过类型查找TestService类型的bean，<br>找到唯一的了个TestService类型bean（即TestServiceImpl），<br>所以就自动装配实例成功了。</p><h3 id="6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？"><a href="#6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？" class="headerlink" title="6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？"></a>6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？</h3><p>1、 通过指定bean的名字来明确到底要实例哪一个类<br>2、 通过在实现类上添加@Primary注解来指定默认加载类</p><h3 id="6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？"><a href="#6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？" class="headerlink" title="6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？"></a>6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？</h3><p>1、 直接获取实现类serviceImpl的bean也是可以的；<br>2、 至于加一层接口的原因：一是AOP程序设置思想指导，<br>    给别人调用的接口，调用者只想知道方法和功能，<br>    而对于这个方法内部逻辑怎么实现的并不关心；<br>    二是可以降低各个模块间的关联，<br>    实现松耦合、程序分层、高扩展性，使程序更加灵活，<br>    他除了在规范上有卓越贡献外，最精髓的是在多态上的运用；<br>    继承只能单一继承，接口却可以多实现<br>3、 当业务逻辑简单，变更较少，项目自用时，<br>    省略掉接口直接使用实现类更简单明了；反之则推荐使用接口;</p><h2 id="6-5：什么是-Spring-的内部-bean？"><a href="#6-5：什么是-Spring-的内部-bean？" class="headerlink" title="6-5：什么是 Spring 的内部 bean？"></a>6-5：什么是 Spring 的内部 bean？</h2><p>只有将 Bean 仅用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。</p><p>为了定义Bean，Spring 提供基于 XML 的配置元数据在<br><property>或 <constructor-arg> 中提供了 <bean>元素的使用。<br>内部 Bean 总是匿名的，并且它们总是作为原型 Prototype 。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。<br>这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;!-- bean.xml --&gt;&lt;bean id&#x3D;“StudentBean&quot; class&#x3D;&quot;com.edureka.Student&quot;&gt;    &lt;property name&#x3D;&quot;person&quot;&gt;        &lt;!--This is inner bean --&gt;        &lt;bean class&#x3D;&quot;com.edureka.Person&quot;&gt;            &lt;property name&#x3D;&quot;name&quot; value&#x3D;“Scott&quot;&gt;&lt;&#x2F;property&gt;            &lt;property name&#x3D;&quot;address&quot; value&#x3D;“Bangalore&quot;&gt;&lt;&#x2F;property&gt;        &lt;&#x2F;bean&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-Spring事务"><a href="#7-Spring事务" class="headerlink" title="7.Spring事务"></a>7.Spring事务</h1><h2 id="7-1：spring事务种类"><a href="#7-1：spring事务种类" class="headerlink" title="7-1：spring事务种类"></a>7-1：spring事务种类</h2><p>spring支持编程式事务管理和声明式事务管理两种方式<br>①编程式事务管理使用TransactionTemplate.<br>②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，<br>将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完<br>目标方法之后根据执行情况提交或者回滚事务。</p><h3 id="7-1-1：-Transactional原理"><a href="#7-1-1：-Transactional原理" class="headerlink" title="7-1-1：@Transactional原理"></a>7-1-1：@Transactional原理</h3><p>@Transactional 的工作机制是基于 AOP 实现的，<br>AOP 又是使用动态代理实现的。如果目标对象实现了接口，<br>默认情况下会采用 JDK 的动态代理，<br>如果目标对象没有实现了接口,会使用 CGLIB 动态代理。<br>通过createAopProxy() 方法决定了是使用 JDK 还是 Cglib 来做动态代理<br>如果一个类或者一个类中的 public 方法上<br>被标注@Transactional 注解的话，<br>Spring 容器就会在启动的时候为其创建一个代理类，<br>在调用被@Transactional 注解的 public 方法的时候，<br>实际调用的是，TransactionInterceptor 类中的 invoke()方法。<br>这个方法的作用就是在目标方法之前开启事务方法<br>执行过程中如果遇到异常的时候回滚事务，<br>方法调用完成之后提交事务。</p><h4 id="7-1-1-1：注解使用详解"><a href="#7-1-1-1：注解使用详解" class="headerlink" title="7-1-1-1：注解使用详解"></a>7-1-1-1：注解使用详解</h4><p>方法 ：将注解使用于方法上，不过需要注意的是：<br>      该注解只能应用到 public 方法上，否则不生效。<br>类 ：如果这个注解使用在类上的话，<br>     表明该注解对该类中所有的 public 方法都生效。<br>接口 ：不推荐在接口上使用。</p><h4 id="7-1-1-2：注解常用属性"><a href="#7-1-1-2：注解常用属性" class="headerlink" title="7-1-1-2：注解常用属性"></a>7-1-1-2：注解常用属性</h4><ol><li>propagation    事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过</li><li>isolation    事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过</li><li>timeout        事务的超时时间，默认值为-1（不会超时）。<pre><code>         如果超过该时间限制但事务还没有完成，则自动回滚事务。</code></pre></li><li>readOnly        指定事务是否为只读事务，默认值为 false。</li><li>rollbackFor    用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</li></ol><h3 id="7-1-2：Spring两种事务区别"><a href="#7-1-2：Spring两种事务区别" class="headerlink" title="7-1-2：Spring两种事务区别"></a>7-1-2：Spring两种事务区别</h3><p>1）声明式事务最大的优点就是不需要<br>   在业务逻辑代码中掺杂事务管理的代码，<br>   只需在配置文件中做相关的事务<br>   规则声明或通过@Transactional注解的方式，<br>   便可以将事务规则应用到业务逻辑中。<br>2）声明式事务管理要优于编程式事务管理，<br>   这正是 spring倡导的非侵入式的开发方式，<br>   使业务代码不受污染，<br>   只要加上注解就可以获得完全的事务支持。<br>   唯一不足地方是，最细粒度只能作用到方法级别，<br>   无法做到像编程式事务那样可以作用到代码块级别。</p><h2 id="7-2：事务管理接口"><a href="#7-2：事务管理接口" class="headerlink" title="7-2：事务管理接口"></a>7-2：事务管理接口</h2><ol><li>PlatformTransactionManager： （平台）事务管理器，Spring 事务策略的核心。</li><li>TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li><li>TransactionStatus： 事务运行状态。</li></ol><p>我们可以把 PlatformTransactionManager 接口可以被看作是事务上层的管理者，<br>而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事物的描述。<br>PlatformTransactionManager 会根据 TransactionDefinition<br>的定义比如事务超时时间、隔离界别、传播行为等来进行事务管理 ，<br>而 TransactionStatus 接口则提供了<br>一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p><h2 id="7-3：事务属性详解"><a href="#7-3：事务属性详解" class="headerlink" title="7-3：事务属性详解"></a>7-3：事务属性详解</h2><p>事务属性主要包括五部分：隔离级别、传播行为、回滚规则、是否只读、事务超时</p><h3 id="7-3-1：事务隔离级别"><a href="#7-3-1：事务隔离级别" class="headerlink" title="7-3-1：事务隔离级别"></a>7-3-1：事务隔离级别</h3><p>ISOLATION_DEFAULT:这是个PlatfromTransactionManager默认的隔离级别，<br>                   使用数据库默认的事务隔离级别。<br>ISOLATION_READ_UNCOMMITTED:读未提交，<br>                           允许另外一个事务可以看到这个事务未提交的数据。<br>ISOLATION_READ_COMMITTED:读已提交，<br>                         保证一个事务修改的数据提交后<br>                         才能被另一事务读取，<br>                         而且能看到该事务对已有记录的更新。<br>ISOLATION_REPEATABLE_READ:可重复读，<br>                          保证一个事务修改的数据提交后<br>                          才能另一事务读取，<br>                          但是不能看到该事务对已有记录的更新。<br>ISOLATION_SERIALIZABLE:一个事务在执行的过程中<br>                       完全看不到其他事务对数据库所</p><h3 id="7-3-2：事务传播行为（为什么要有）"><a href="#7-3-2：事务传播行为（为什么要有）" class="headerlink" title="7-3-2：事务传播行为（为什么要有）"></a>7-3-2：事务传播行为（为什么要有）</h3><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如<br>我们在 A 类的aMethod（）方法中调用了 B 类的 bMethod() 方法。<br>这个时候就涉及到业务层方法之间互相调用的事务问题。<br>如果我们的 bMethod()如果发生异常需要回滚，<br>如何配置事务传播行为才能让 aMethod()也跟着回滚呢<br>这个时候就需要事务传播行为的知识了，</p><h4 id="7-3-2-1：传播行为级别"><a href="#7-3-2-1：传播行为级别" class="headerlink" title="7-3-2-1：传播行为级别"></a>7-3-2-1：传播行为级别</h4><p><code>PROPAGATION_REQUIRED</code>:如果当前没有事务，<br>                     就创建一个新事务，<br>                     如果当前存在事务，<br>                     就加入该事务，<br>                     该设置是最常用的设置。<br><code>PROPAGATION_SUPPORTS</code>:支持当前事务，<br>                     如果当前存在事务，<br>                     就加入该事务，<br>                     如果当前不存在事务，<br>                     就以非事务执行。<br><code>PROPAGATION_MANDATORY</code>:支持当前事务，<br>                      如果当前仔在事分，<br>                      影果当前不存在事务，<br>                      就抛出异常。<br><code>PROPAGATION_REOUIRES NEW</code>:创建新事务，<br>                         无论当前存不存在事务，<br>                         都创建新事务。<br><code>PROPAGATION_NOT_SUPPORTED</code>:以非事务方式执行操作，<br>                          如果当前存在事务，<br>                          就把当前事务挂起。<br><code>PROPAGATION_NEVER</code>:以非事务方式执行，<br>                  如果当前存在事务，<br>                  则抛出异常。<br><code>PROPAGATION_NESTED</code>:如果当前存在事务，<br>                   则在嵌套事务内执行。<br>                   如果当前没有事务，<br>                   则按 REQUIRED属性执行。</p><h3 id="7-3-3：事务的回滚规则"><a href="#7-3-3：事务的回滚规则" class="headerlink" title="7-3-3：事务的回滚规则"></a>7-3-3：事务的回滚规则</h3><p>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</p><p>默认情况下，事务只有遇到运行期异常时才会回滚，<br>而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。<br>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。<br>同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p><h3 id="7-3-4：事务的只读属性"><a href="#7-3-4：事务的只读属性" class="headerlink" title="7-3-4：事务的只读属性"></a>7-3-4：事务的只读属性</h3><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</p><h5 id="7-3-4-1：什么是事务性资源"><a href="#7-3-4-1：什么是事务性资源" class="headerlink" title="7-3-4-1：什么是事务性资源"></a>7-3-4-1：什么是事务性资源</h5><p>事务性资源就是指那些被事务管理的资源，<br>比如数据源、JMS 资源，以及自定义的事务性资源等等。<br>如果确定只对事务性资源进行只读操作，<br>那么我们可以将事务标志为只读的，<br>以提高事务处理的性能。</p><h3 id="7-3-5：事务的超时属性"><a href="#7-3-5：事务的超时属性" class="headerlink" title="7-3-5：事务的超时属性"></a>7-3-5：事务的超时属性</h3><p>就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。<br>在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。<br>当然，这个属性，貌似我们基本也没用过。</p><h2 id="7-4：Spring的事务和数据库的事务隔离是一个概念么？"><a href="#7-4：Spring的事务和数据库的事务隔离是一个概念么？" class="headerlink" title="7-4：Spring的事务和数据库的事务隔离是一个概念么？"></a>7-4：Spring的事务和数据库的事务隔离是一个概念么？</h2><p>Spring 并不直接管理事务，而是提供了多种事务管理器 。<br>Spring 事务管理器的接口是： PlatformTransactionManager 。<br>通过这个接口，Spring 为各个平台如<br>JDBC(DataSourceTransactionManager)、<br>Hibernate(HibernateTransactionManager)、<br>JPA(JpaTransactionManager)等都提供了<br>对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><h2 id="7-5：Spring事务底层原理"><a href="#7-5：Spring事务底层原理" class="headerlink" title="7-5：Spring事务底层原理"></a>7-5：Spring事务底层原理</h2><ol><li>划分处理单元 IOC<br> 之前在看源码，发现Spring 解决的问题是对单个数据库进行局部事务处理的，<br> 具体的实现首先使用 Spring 中的 IOC 划分了事务处理单元。<br> 并且将对事务的各种配置放到了 IOC 容器中<br> （设置事务管理器，设置事务的传播特性及隔离机制）。</li><li>AOP 拦截需要进行事务处理的类<br> Spring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，<br> 具体操作（比如事务实行的配置和读取，事务对象的抽象），<br> 用 TransactionProxyFactoryBean 接口来使用 AOP 功能，<br> 生成 proxy 代理对象，通过 TransactionInterceptor 完成对代理方法的拦截，<br> 将事务处理的功能编织到拦截的方法中。读取 IOC 容器事务配置属性，<br> 转化为 Spring 事务处理需要的内部数据结构<br> （TransactionAttributeSourceAdvisor），<br> 转化为 TransactionAttribute 表示的数据对象。</li><li>对事物处理实现（事务的生成、提交、回滚、挂起）<br> Spring 委托给具体的事务处理器实现。实现了一个抽象和适配。<br> 适配的具体事务处理器：DataSource 数据源支持、<br> Hibernate 数据源事务处理支持、JDO 数据源事务处理支持，<br> JPA、JTA 数据源事务处理支持。<br> 这些支持都是通过设计 PlatformTransactionManager、<br> AbstractPlatforTransaction 一系列事务处理的支持。<br> 为常用数据源支持提供了一系列的 TransactionManager。</li></ol><h2 id="7-6：为什么在-Spring-事务中不能切换数据源？"><a href="#7-6：为什么在-Spring-事务中不能切换数据源？" class="headerlink" title="7-6：为什么在 Spring 事务中不能切换数据源？"></a>7-6：为什么在 Spring 事务中不能切换数据源？</h2><p>因为，在 Spring 的事务管理中，<br>所使用的数据库连接会和当前线程所绑定，<br>即使我们设置了另外一个数据源，使用的还是当前的数据源连接。<br>另外，多个数据源且需要事务的场景，<br>本身会带来多事务一致性的问题，暂时的话，可能没有太好的解决方案<br>所以一般一个应用，推荐除非了读写分离所带来的多数据源，<br>其它情况下，建议只有一个数据源。</p><h1 id="8-Spring的装配"><a href="#8-Spring的装配" class="headerlink" title="8.Spring的装配"></a>8.Spring的装配</h1><h2 id="8-1：什么是Spring装配"><a href="#8-1：什么是Spring装配" class="headerlink" title="8-1：什么是Spring装配"></a>8-1：什么是Spring装配</h2><p>当 Bean 在 Spring 容器中组合在一起时，它被称为装配或 Bean 装配</p><h2 id="8-2：自动装配有哪些方式"><a href="#8-2：自动装配有哪些方式" class="headerlink" title="8-2：自动装配有哪些方式"></a>8-2：自动装配有哪些方式</h2><p>Spring 容器能够自动装配 Bean 。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 Bean 的协作者。<br>自动装配的不同模式：</p><p>no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。<br>byName - 它根据 Bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。<br>【最常用】byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。<br>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。<br>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="2020/11/28/%E5%8F%8D%E5%B0%84/"/>
      <url>2020/11/28/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<font color = gold ><p>都说框架=反射+注解+设计模式<br>那么今天就来总结一下关于反射的知识把～～</p></font><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><hr><h2 id="反射是什么"><a href="#反射是什么" class="headerlink" title="反射是什么"></a>反射是什么</h2><p>加载完类之后，在运行时数据取区就产生了一个Class类型的对象，Class对象包含了完整的类的结构信息。<br>我们可以通过这个Class对象可以看到类的结构，我们形象的称之为<code>反射</code>；</p><p>JAVA 反射机制被看作是<code>动态语言</code>的关键（<strong>运行期间可以改变其结构的语言</strong>）</p><p>Java不是动态语言 ，但Java可以称之为“准动态语言”。即Java有一定的动 态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。 Java的动态性让编程的时候更加灵活！<br><strong>允许程序在执行期间<br>获取任何类的内部信息<br>并且能直接操作任意对象的内部属性和方法</strong><br>正常情况下 是通过引入包类的名称–new–取得实例化对象<br>反射 ： 实例化对象-getClass()–得到完整的包类名称</p><hr><h2 id="反射优缺点"><a href="#反射优缺点" class="headerlink" title="反射优缺点"></a>反射优缺点</h2><p>优点： 运行期间可以改变其结构的语言<br>      解耦以及提高代码的灵活性。  —反射 AOP</p><p>缺点： 1、性能瓶颈：反射相当于一系列解释操作，<br>          通知 JVM 要做的事情，<br>          性能比直接的 java 代码要慢很多。<br>      2、安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</p><hr><h2 id="反射能做什么"><a href="#反射能做什么" class="headerlink" title="反射能做什么"></a>反射能做什么</h2><p>在运行时判断一个对象所属的类<br>在运行的时候构造一个类的对象<br>在运行时候调用任意一个类所拥有的成员变量和方法<br>在运行时候获取泛型信息<br>在运行时候调用任意一个对象的成员变量和方法<br>在运行时处理注解<br>生成动态代理<br><code> java.lang.Class 代表一个类  java.lang.reflect.Method 代表类的方法  java.lang.reflect.Field 代表类的成员变量  java.lang.reflect.Constructor 代表类的构造器</code></p><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="java-lang-Class类–反射的源头"><a href="#java-lang-Class类–反射的源头" class="headerlink" title="java.lang.Class类–反射的源头"></a>java.lang.Class类–反射的源头</h3><h3 id="java-lang-Class类的理解"><a href="#java-lang-Class类的理解" class="headerlink" title="java.lang.Class类的理解"></a>java.lang.Class类的理解</h3><p><code>加载</code>完类之后，在运行时数据取区就产生了一个Class类型的对象，Class对象包含了完整的类的结构信息。可以通过Class类的方法进行对象的实例化操作，调用任意一个类所拥有的成员变量和方法</p><p>Class主要是`反射的源头``，<br>一个加载的类在 JVM 中只会有一个Class实例<br>一个Class对象对应的是一个加载到JVM中的一个.class文件</p><h3 id="如何获取Class对象"><a href="#如何获取Class对象" class="headerlink" title="如何获取Class对象"></a>如何获取Class对象</h3><ol><li>Object类的getClass();</li><li>任何数据类型（包括基本数据类型）都有一个“静态”的class属性</li><li>通过Class类的静态方法：forName(常用)</li><li>类加载器<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;----Class&lt;Person&gt; personClass &#x3D; Person.class;System.out.println(personClass);&#x2F;&#x2F;------Person person &#x3D; new Person();Class&lt;? extends Person&gt; aClass &#x3D; person.getClass();System.out.println(aClass);Class&lt;?&gt; personClz &#x3D; Class.forName(&quot;com.as.Person&quot;);System.out.println(personClz);ClassLoader classLoader &#x3D; ReflectionTest.class.getClassLoader();Class&lt;?&gt; loadClass &#x3D; classLoader.loadClass(&quot;com.as.Person&quot;);System.out.println(loadClass);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;    private String name;    public int age;    public Person() &#123;    &#125;    public Person(String name, int age) &#123;        this.name &#x3D; name;        this.age &#x3D; age;    &#125;    private Person(String name) &#123;        this.name &#x3D; name;    &#125;    public String getName() &#123;        return name;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age&#x3D;&quot; + age +                &#39;&#125;&#39;;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age &#x3D; age;    &#125;    public void show()&#123;        System.out.println(&quot;hello reflection&quot;);    &#125;    private String showNation(String nation)&#123;        System.out.println(&quot;国籍：&quot;+nation);        return nation;    &#125;&#125;public class ReflectionTest &#123;    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException, NoSuchFieldException &#123;        &#x2F;&#x2F;反射创建对象        Class&lt;Person&gt; personClass &#x3D; Person.class;        Constructor&lt;Person&gt; constructor &#x3D; personClass.getConstructor(String.class, int.class);        Person person &#x3D; constructor.newInstance(&quot;加多&quot;, 24);        System.out.println(person.toString());        &#x2F;&#x2F;反射操作对象的属性        Field age &#x3D; personClass.getDeclaredField(&quot;age&quot;);        age.set(person,21);        System.out.println(person.toString());        &#x2F;&#x2F;反射操作对象的方法        Method show &#x3D; personClass.getMethod(&quot;show&quot;);        show.invoke(person);        System.out.println(&quot;**********&quot;);        &#x2F;&#x2F;通过反射可以调用Person的私有的结构        Constructor&lt;Person&gt; declaredConstructor &#x3D; personClass.getDeclaredConstructor(String.class);        declaredConstructor.setAccessible(true);        Person instance &#x3D; declaredConstructor.newInstance(&quot;加多宝&quot;);        System.out.println(instance);        Field name &#x3D; personClass.getDeclaredField(&quot;name&quot;);        name.setAccessible(true);        name.set(person,&quot;佳铎&quot;);        System.out.println(person);        Method showNation &#x3D; personClass.getDeclaredMethod(&quot;showNation&quot;, String.class);        showNation.setAccessible(true);        showNation.invoke(person,&quot;China&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象"></a>哪些类型可以有Class对象</h3><p>类：<br>接口<br>数组 只要元素类型与纬度一样就是同一个class<br>枚举<br>注解<br>基本数据类型<br>void<br><code>数组 只要元素类型与纬度一样就是同一个class</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] a &#x3D; new int[10];int[] b &#x3D; new int[100];System.out.println(a.getClass()&#x3D;&#x3D;b.getClass()); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="有了Class对象，能做什么？"><a href="#有了Class对象，能做什么？" class="headerlink" title="有了Class对象，能做什么？"></a>有了Class对象，能做什么？</h3><h4 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h4><ol><li>调用Class对象的newInstance()方法<br>要 求：<br> 1）类必须有一个无参数的构造器。<br> 2）类的构造器的访问权限需要足够。通常设置为public<br> 所以在javabean中要求提供public的空参构造器：</li><li>通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器<h4 id="获取运行时类的完-整结构"><a href="#获取运行时类的完-整结构" class="headerlink" title="获取运行时类的完 整结构"></a>获取运行时类的完 整结构</h4>Field、Method、Constructor、Superclass、Interface、Annotation</li></ol><ol><li>实现的全部接口<br><code>public Class&lt;?&gt;[] getInterfaces()</code><br>确定此对象所表示的类或接口实现的接口。</li></ol><ol start="2"><li>所继承的父类  全部的方法 全部的Field<br><code>public Class&lt;? Super T&gt; getSuperclass()</code></li></ol><p>3.全部的构造器<br><code>public Constructor&lt;T&gt;[] getConstructors()</code><br>当前运行时类中所有public构造方法。<br><code>public Constructor&lt;T&gt;[] getDeclaredConstructors()</code><br>返回此 Class 对象表示的类声明的所有构造方法。</p><p>Constructor类中：<br>取得修饰符: <code>public int getModifiers()</code>;<br>取得方法名称: <code>public String getName()</code>;<br>取得参数的类型：<code>public Class&lt;?&gt;[] getParameterTypes()</code>;</p><ol><li>全部的方法<br><code>public Method[] getDeclaredMethods()</code><br>获得当前运行时类中类中的声明的所有方法，包含所有的权限，<strong>（不包括父类中声明的）</strong><br><code>public Method[] getMethods()</code><br>返回此Class对象所表示的<strong>类和父类</strong>中的<strong>public</strong>的方法。<br>Method类中：<br><code>public Class&lt;?&gt; getReturnType()</code>取得全部的返回值<br><code>public Class&lt;?&gt;[] getParameterTypes()</code>取得全部的参数<br><code>public int getModifiers()</code>取得修饰符<br><code>public Class&lt;?&gt;[] getExceptionTypes()</code>取得异常信息</li></ol><p>通过反射，调用类中的方法，通过Method类完成。步骤：<br>1.通过Class类的<code>getMethod(String name,Class…parameterTypes)</code>方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。<br>2.之后使用<code>Object invoke(Object obj, Object[] args)</code>进行调用，并向方法中 传递要设置的obj对象的参数信息。<br>说明：<br>a. Object 对应原方法的返回值，若原方法无返回值，此时返回null<br>b. 若原方法若为静态方法，此时形参Object obj可为null<br>c. 若原方法形参列表为空，则Object[] args为null<br>d. 若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可修改private的方法。</p><p>5.全部的Field<br><code>public Field[] getFields()</code><br>返回此Class对象所表示的<strong>类和父类</strong>中的<strong>public</strong>的Field。<br><code>public Field[] getDeclaredFields()</code><br>获得当前运行时类中类中的声明的所有属性，包含所有的权限，<strong>（不包括父类中声明的属性）</strong><br>Field方法中：<br><code>public int getModifiers()</code> 以整数形式返回此Field的修饰符<br><code>public Class&lt;?&gt; getType()</code> 得到Field的属性类型<br><code>public String getName()</code> 返回Field的名称。</p><p>在Field中：<br><code>public Object get(Object obj)</code> 取得指定对象obj上此Field的属性内容 <code>public void set(Object obj,Object value)</code> 设置指定对象obj上此Field的属性内容</p><ol><li>Annotation相关</li></ol><p><code>get Annotation(Class&lt;T&gt; annotationClass)</code><br><code>getDeclaredAnnotations()</code></p><p>7.泛型相关</p><p>获取父类泛型类型：<code>Type getGenericSuperclass()</code><br>泛型类型：<code>ParameterizedType</code><br>获取实际的泛型类型参数数组：<code>getActualTypeArguments()</code></p><p>8.类所在的包<br><code>Package getPackage()</code></p><hr><h2 id="反射实际的应用"><a href="#反射实际的应用" class="headerlink" title="反射实际的应用"></a>反射实际的应用</h2><h3 id="使用-JDBC-连接数据库"><a href="#使用-JDBC-连接数据库" class="headerlink" title="使用 JDBC 连接数据库"></a>使用 JDBC 连接数据库</h3><p>使用 Class.forName()通过反射加载数据库的驱动程序；</p><h3 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h3><p>IOC（动态加载管理 Bean）创建对象 ：程序启动的时候Spring读取配置文件applicationContext.xml兵解析成标签，反射实例化对象到容器中<br>AOP（动态代理）功能都和反射有联系；</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原 始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</code></pre><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理，<br>特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。<br>同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。<br>最好可以通过一个代理类完成全部的代理功能。<br>那这个通用的代理类只能是在运行期间才能确定，根据运行过程中看你加载到内存中的的被代理类是谁，动态地帮你去创建代理类，所以的话体现了动态性，要用到反射</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface CloFactory &#123;    public void geneCloth();&#125;&#x2F;&#x2F;被代理类class DressFactory implements CloFactory&#123;    @Override    public void geneCloth() &#123;        System.out.println(&quot;生产Dress&quot;);    &#125;&#125;&#x2F;&#x2F;代理类class ProxyDress implements CloFactory&#123;    private CloFactory cloFactory;    public ProxyDress(CloFactory cloFactory) &#123;        this.cloFactory &#x3D; cloFactory;    &#125;    @Override    public void geneCloth() &#123;        System.out.println(&quot;买材料&quot;);        cloFactory.geneCloth();        System.out.println(&quot;开始售卖&quot;);    &#125;&#125;public class StaticProxyTest&#123;    public static void main(String[] args) &#123;        DressFactory dressFactory &#x3D; new DressFactory();        ProxyDress proxyDress &#x3D; new ProxyDress(dressFactory);        proxyDress.geneCloth();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DynasticProxyTest &#123;    public static void main(String[] args) &#123;        DressFactory dressFactory &#x3D; new DressFactory();        CloFactory proxyInstance &#x3D; (CloFactory) ProxyGeneric.getProxyInstance(dressFactory);        proxyInstance.geneCloth();    &#125;&#125;interface CloFactory &#123;    public void geneCloth();&#125;&#x2F;&#x2F;被代理类class DressFactory implements CloFactory&#123;    @Override    public void geneCloth() &#123;        System.out.println(&quot;生产Dress&quot;);    &#125;&#125;class ProxyGeneric &#123;    &#x2F;&#x2F;得到被代理对象    public static Object getProxyInstance(Object obj)&#123;        MyInvocationHandler handler &#x3D;new MyInvocationHandler();        handler.bind(obj) ;        Object o &#x3D; Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);        return o ;    &#125;&#125;&#x2F;&#x2F;当我们使用代理类的对象时，调用方法的时候，就会自动调用invoke()class MyInvocationHandler implements InvocationHandler&#123;    Object obj;&#x2F;&#x2F;被代理对象    public void bind(Object obj)&#123;        this. obj &#x3D; obj;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;准备材料&quot;);        Object returnValue &#x3D; method.invoke(obj, args);        System.out.println(&quot;完工&quot;);        return returnValue;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="关于反射的疑问"><a href="#关于反射的疑问" class="headerlink" title="关于反射的疑问"></a>关于反射的疑问</h2><h3 id="怎么看待反射和封装性？？"><a href="#怎么看待反射和封装性？？" class="headerlink" title="怎么看待反射和封装性？？"></a>怎么看待反射和封装性？？</h3><p>封装：解决的是建议怎么调用的问题：表示建议你去调用公共的属性和方法，私有的就使用get set方法去调用<br>反射： 解决的是能不能调用的问题<br>不矛盾</p><h3 id="什么时候使用反射？"><a href="#什么时候使用反射？" class="headerlink" title="什么时候使用反射？"></a>什么时候使用反射？</h3><p>编译的时候确定不下来用那个对象 ，既不能通过new对象的方式来做。这是就可以用反射的方式，反射的特征：动态性（运行期间可以改变其结构的语言）</p><hr><h2 id="类的加载-与ClassLoader的理解"><a href="#类的加载-与ClassLoader的理解" class="headerlink" title="类的加载 与ClassLoader的理解"></a>类的加载 与ClassLoader的理解</h2><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进行初始化。<br>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。</p><p>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<br> 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题<br> 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存 都将在方法区中进行分配。<br> 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</p><p>初始化：执行类构造器<clinit>()方法的过程。<br>类构造器<clinit>()方法是由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的。<br>（类构造器是构造类信息的，不是构造该类对象的构造器）。<br> 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。<br> 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</p><h3 id="什么时候会发生类初始化？"><a href="#什么时候会发生类初始化？" class="headerlink" title="什么时候会发生类初始化？"></a>什么时候会发生类初始化？</h3><p>类的主动引用（一定会发生类的初始化）</p><p>当虚拟机启动，先初始化main方法所在的类<br>new一个类的对象<br>调用类的静态成员（除了final常量）和静态方法<br>使用java.lang.reflect包的方法对类进行反射调用<br>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</p><p>类的被动引用（不会发生类的初始化）</p><p>当访问一个静态域时，只有真正声明这个域的类才会被初始化  当通过子类引用父类的静态变量，不会导致子类初始化</p><p>通过数组定义类引用，不会触发此类的初始化<br>引用常量不会触发此类的初始化（<strong>常量在链接阶段就存入调用类的常量池中了</strong>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ClassLoadingTest &#123;public static void main(String[] args) &#123; &#x2F;&#x2F; 主动引用：一定会导致A和Father的初始化&#x2F;&#x2F; A a &#x3D; new A();&#x2F;&#x2F; System.out.println(A.m); &#x2F;&#x2F; Class.forName(&quot;com.atguigu.java2.A&quot;);&#x2F;&#x2F; 被动引用 A[] array &#x3D; new A[5];&#x2F;&#x2F;不会导致A和Father的初始化&#x2F;&#x2F; System.out.println(A.b);&#x2F;&#x2F;只会初始化 Father&#x2F;&#x2F; System.out.println(A.M);&#x2F;&#x2F;不会导致A和 Father的初始化 &#125;static &#123; System.out.println(&quot;main所在的类&quot;); &#125;class Father &#123;     static int b &#x3D; 2;     static &#123; System.out.println(&quot;父类被加载&quot;);     &#125;     &#125;class A extends Father &#123;static &#123;     System.out.println(&quot;子类被加载&quot;);    m &#x3D; 300;&#125; static int m &#x3D; 100; static final int M &#x3D; 1;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><h3 id="ClassLoader作用"><a href="#ClassLoader作用" class="headerlink" title="ClassLoader作用"></a>ClassLoader作用</h3><p>类加载的作用：将class 文件字节码内容加载到内存中 ，并将这些静态数据 转换成方 法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。<br>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</p><p>JVM 规范定义了如下类的加载器。<br>引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，<br><strong>用来装载核心类库</strong>。<strong>该加载器无法直接获取</strong><br>扩展类加载器：负责jre/lib/ext目录下的jar包或 D java.ext.dirs 指定目录下的jar包装入工作库<br>系统类加载器：负责java –classpath 或 –D java.class.path所指的目录下的类与jar包装入工作 ，是最常用的加载器</p><h3 id="ClassLoader获取"><a href="#ClassLoader获取" class="headerlink" title="ClassLoader获取"></a>ClassLoader获取</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;1.获取一个系统类加载器• ClassLoader classloader &#x3D; ClassLoader.getSystemClassLoader();• System.out.println(classloader);• &#x2F;&#x2F;2.获取系统类加载器的父类加载器，即扩展类加载器• classloader &#x3D; classloader.getParent();• System.out.println(classloader);• &#x2F;&#x2F;3.获取扩展类加载器的父类加载器，即引导类加载器• classloader &#x3D; classloader.getParent();• System.out.println(classloader);  &#x2F;&#x2F;null 没有办法获取到• &#x2F;&#x2F;4.测试当前类由哪个类加载器进行加载• classloader &#x3D; Class.forName(&quot;exer2.ClassloaderDemo&quot;).getClassLoader();  • System.out.println(classloader);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于类加载器的一个主要方法：<br><code>getResourceAsStream(String str)</code>:<strong>获取类路径下的指定文件的输入流</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">• InputStream in &#x3D; null;• in &#x3D; this.getClass().getClassLoader().getResourceAsStream(&quot;test.properties&quot;);• System.out.println(in);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Class-forName和classloader-loadClass的区别"><a href="#Class-forName和classloader-loadClass的区别" class="headerlink" title="Class.forName和classloader.loadClass的区别"></a>Class.forName和classloader.loadClass的区别</h3><ol><li>初始化不同:<ul><li>Class.forName()会对类初始化，而loadClass()只会装载或链接。</li><li>foranme在类加载的时候会执行静态代码块，loadclass只有在调用newInstance方法的时候才会执行静态代码块</li></ul></li><li>类加载器不同:<ul><li>Class.forName(String)方法(只有一个参数)，哪个调用了forname就用那个类加载器</li><li>ClassLoader.loadClass()方法是一个实例方法，调用时需要自己指定类加载器</li></ul></li></ol><h2 id="反射会导致性能问题呢？"><a href="#反射会导致性能问题呢？" class="headerlink" title="反射会导致性能问题呢？"></a>反射会导致性能问题呢？</h2><h3>java反射效率低主要是因为：</h3><font color = "orange">Method invoke 会对参数做封装和解封的操作</font>可以看到， invoke方法的参数是object类型的，也就是说。当我们传入的参数是简单类型的话，需要转化为object类型比如说我们传入long类型的话  ，就需要Long.valueOf转型，就生成了Lon的Object,同时传入的是OBject数组的时候，就要额外的封装object数组<p><strong>在反射调用的时候因为封装和解封，这样就产生了不必要的内存的浪费<br>当调用的系数达到一定值的时候，还会导致GC</strong><br><font color = "orange">需要检查方法的可见性</font><br>每次调用都会检查方法的可见性<br><font color = "orange">需要校验参数：</font><br>对参数做校验，就涉及到了参数的解封的操作</p><p><font color = "orange">JIT无法优化：</font><br>反射涉及到动态加载的类型，无法就行JIT优化</p><h2 id="如何避免反射导致的性能问题？"><a href="#如何避免反射导致的性能问题？" class="headerlink" title="如何避免反射导致的性能问题？"></a>如何避免反射导致的性能问题？</h2><ol><li>m.setAccessible(true);<br>由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的</li></ol><ol start="2"><li>用缓存，比如redis, 这个方法提高效率是显而易见的。<br>将反射得到元数据保存起来，使用时，只需从内存中调用即可</li><li>利用一些高性能的反射库，如ReflectASM<br>ReflectASM <strong>使用字节码生成的方式实现了更为高效的反射机制</strong>。执行时会生成一个存取类来 set/get 字段，访问方法或创建实例。一看到 ASM 就能领悟到 ReflectASM 会用字节码生成的方式，而不是依赖于 Java 本身的反射机制来实现的，所以它更快，**并且避免了访问原始类型因自动装箱而产生的问题</li></ol><p>**</p><h2 id="哪些类不能反射"><a href="#哪些类不能反射" class="headerlink" title="哪些类不能反射"></a>哪些类不能反射</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public enum  EnumSingleton &#123;    INSTANCE;    public EnumSingleton getInstance()&#123;        return INSTANCE;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class  EnumSingleton extends Enum&lt; EnumSingleton&gt; &#123;        public static final  EnumSingleton  ENUMSINGLETON;        public static  EnumSingleton[] values();        public static  EnumSingleton valueOf(String s);        static &#123;&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>反射创建，枚举Enum是个抽象类，其实一旦一个类声明为枚举，实际上就是继承了Enum，</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;            implements Comparable&lt;E&gt;, Serializable &#123;        private final String name;        public final String name() &#123;            return name;        &#125;        private final int ordinal;        public final int ordinal() &#123;            return ordinal;        &#125;        protected Enum(String name, int ordinal) &#123;            this.name &#x3D; name;            this.ordinal &#x3D; ordinal;        &#125;        &#x2F;&#x2F;余下省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>会发现并没有我们所设置的无参构造器</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;        EnumSingleton singleton1&#x3D;EnumSingleton.INSTANCE;        EnumSingleton singleton2&#x3D;EnumSingleton.INSTANCE;        System.out.println(&quot;正常情况下，实例化两个实例是否相同：&quot;+(singleton1&#x3D;&#x3D;singleton2));        Constructor&lt;EnumSingleton&gt; constructor&#x3D; null;&#x2F;&#x2F;        constructor &#x3D; EnumSingleton.class.getDeclaredConstructor();        constructor &#x3D; EnumSingleton.class.getDeclaredConstructor(String.class,int.class);&#x2F;&#x2F;其父类的构造器        constructor.setAccessible(true);        EnumSingleton singleton3&#x3D; null;        &#x2F;&#x2F;singleton3 &#x3D; constructor.newInstance();        singleton3 &#x3D; constructor.newInstance(&quot;testInstance&quot;,66);        System.out.println(singleton1+&quot;\n&quot;+singleton2+&quot;\n&quot;+singleton3);        System.out.println(&quot;通过反射攻击单例模式情况下，实例化两个实例是否相同：&quot;+(singleton1&#x3D;&#x3D;singleton3));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">正常情况下，实例化两个实例是否相同：trueException in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects    at java.lang.reflect.Constructor.newInstance(Constructor.java:417)    at com.lxp.pattern.singleton.EnumSingleton.main(EnumSingleton.java:25)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>我们看下Constructor类的newInstance方法源码：</strong></p><pre><code class="java">@CallerSensitive    public T newInstance(Object ... initargs)        throws InstantiationException, IllegalAccessException,               IllegalArgumentException, InvocationTargetException    &#123;        if (!override) &#123;            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;                Class&lt;?&gt; caller = Reflection.getCallerClass();                checkAccess(caller, clazz, null, modifiers);            &#125;        &#125;        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);        ConstructorAccessor ca = constructorAccessor;   // read volatile        if (ca == null) &#123;            ca = acquireConstructorAccessor();        &#125;        @SuppressWarnings(&quot;unchecked&quot;)        T inst = (T) ca.newInstance(initargs);        return inst;    &#125;```**说明反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。**</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="2020/11/28/%E6%B3%9B%E5%9E%8B/"/>
      <url>2020/11/28/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="30-泛型"><a href="#30-泛型" class="headerlink" title="30.泛型"></a>30.泛型</h1><h2 id="30-1：什么是泛型"><a href="#30-1：什么是泛型" class="headerlink" title="30-1：什么是泛型"></a>30-1：什么是泛型</h2><h2 id="泛型好处："><a href="#泛型好处：" class="headerlink" title="泛型好处："></a>泛型好处：</h2><p>编译器检查 ，类型安全<br>减少了数据类型转换<br>泛型可以提⾼代码的复⽤性</p><h2 id="泛型的本质就是参数化类型，也就是所操作的数组类型设计为一个参数"><a href="#泛型的本质就是参数化类型，也就是所操作的数组类型设计为一个参数" class="headerlink" title="泛型的本质就是参数化类型，也就是所操作的数组类型设计为一个参数"></a>泛型的本质就是参数化类型，也就是所操作的数组类型设计为一个参数</h2><h2 id="泛型类，接口"><a href="#泛型类，接口" class="headerlink" title="泛型类，接口"></a>泛型类，接口</h2><p>class 类名&lt;泛型标识，泛型标识&gt;{<br>  private 泛型标识 变量名</p><p>}<br>常见的泛型标识：  T E K V<br>za<br>在创建对象的时候<br>—-  指定具体的数据类型<br>—–  没有指定类型  按照Object来处理</p><p>泛型类不支持基本数据类型，<br>—-因为在使用泛型的时候，真正被编译的时候会把T转换为Object，然后在使用成员的时候在适当的实际转换为T类型<br>                      int 并不是继承自object，<br>同一个泛型类：根据不同的数据类型创建的对象，本质上是统一类型，<br>List<Integer> listint List<String> liststr  .getClass()相同</p><h2 id="泛型类派生子类"><a href="#泛型类派生子类" class="headerlink" title="泛型类派生子类"></a>泛型类派生子类</h2><p>子类是泛型类，子类和父类的泛型类型要一致 ，也可以进行扩展</p><p>子类不是泛型类的时候，父类要明确泛型的具体类型</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>修饰符 &lt;泛型标识&gt;  返回值类型 方法名（形参列表）<br>&lt;泛型标识&gt;表明该方法使用的泛型类型，，这样才可以在方法中使用泛型类型<br>调用方法的时候才能明确具体要使用的数据类型</p><p>泛型方法支持static 但是泛型类和接口不支持</p><p>泛型方法能是方法独立与类而产生变化</p><h2 id="类型通配符-？"><a href="#类型通配符-？" class="headerlink" title="类型通配符 ？"></a>类型通配符 ？</h2><p>一般是以？代替具体的类型实参<br>所以类型通配符是类型实惨 而不是类型的形参</p><p> 上限  ？ extends 类型  该泛型的类型只能是实惨类型或者是实惨类型的子类类型<br> get 能用类型接受<br> add 不能添加 比如是minicat 但是却add了cat就不行</p><p>下限  ？ super 类型  该泛型的类型只能是实惨类型或者是实惨类型的父类类型</p><h2 id="30-2：编译器如何处理泛型"><a href="#30-2：编译器如何处理泛型" class="headerlink" title="30-2：编译器如何处理泛型"></a>30-2：编译器如何处理泛型</h2><ol><li>Code specialization：在实例化一个泛型类或泛型方法时<pre><code>                 都产生一份新的字节码or二进制代码。</code></pre></li><li>Code sharing：对每个泛型类只生成唯一的一份目标代码；<pre><code>          该泛型类的所有实例都映射到这份目标代码上，          在需要的时候执行类型检查和类型转换。</code></pre></li></ol><h3 id="30-2-1：为什么Java要用这种编译器"><a href="#30-2-1：为什么Java要用这种编译器" class="headerlink" title="30-2-1：为什么Java要用这种编译器"></a>30-2-1：为什么Java要用这种编译器</h3><ol><li>C++和C#是使用Code specialization的处理机制，他有几个缺点:<ul><li>导致代码膨胀。</li><li>在引用类型系统中，浪费空间</li></ul></li><li>Java编译器通过Code sharing方式为每个泛型类型创建唯一的字节码表示，<br>并且将该泛型类型的实例都映射到这个唯一的字节码表示上。<br>将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</li></ol><h2 id="30-3-什么是类型擦除"><a href="#30-3-什么是类型擦除" class="headerlink" title="30-3: 什么是类型擦除"></a>30-3: 什么是类型擦除</h2><p>泛型是jdk1.5才引进的概念，在这之前是没有泛型的，<br>但是泛型的代码能够很好地和之前版本的版本兼容。<br>**那是因为，泛型的信息只存在与代码的编译阶段，在进入到JVM之前，与泛型相关的信息回被擦除掉，我们就称之为是泛型擦除<br>**</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> listInt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> listStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listInt<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>listStr<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="无限制类型擦除"><a href="#无限制类型擦除" class="headerlink" title="无限制类型擦除"></a>无限制类型擦除<T></h3><pre><code>    T在生成字节码文件的过程中用Object代替了</code></pre><h3 id="有限制类型擦除"><a href="#有限制类型擦除" class="headerlink" title="有限制类型擦除"></a>有限制类型擦除<T extends Number></h3><pre><code>    T用Number代替</code></pre><h3 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h3><h2 id="30-3-1：类型擦除过程"><a href="#30-3-1：类型擦除过程" class="headerlink" title="30-3-1：类型擦除过程"></a>30-3-1：类型擦除过程</h2><ol><li>将所有的泛型参数用最顶级的父类型进行替换。 </li><li>移除所有的类型参数</li></ol><p>Java的泛型基本上都是在编译器这个层次上实现的，<br>在生成的字节码中是不包含泛型中的类型信息的，<br>使用泛型的时候加上类型参数，<br>在编译器编译的时候会去掉，<br>这个过程成为类型擦除。</p><h2 id="30-4：泛型带来的问题"><a href="#30-4：泛型带来的问题" class="headerlink" title="30-4：泛型带来的问题"></a>30-4：泛型带来的问题</h2><ol><li>虚拟机中没有泛型，只有普通类和普通方法,<br>所有泛型类的类型参数在编译时都会被擦除,<br>泛型类并没有自己独有的Class类对象。<br>比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。 </li><li>创建泛型对象时需要指明类型，让编译器尽早的做参数检查</li><li>不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你。 </li><li>静态变量是被泛型类的所有实例所共享的。 </li><li>泛型的类型参数不能用在Java异常处理的catch语句中。</li></ol><h2 id="30-5：泛型应用"><a href="#30-5：泛型应用" class="headerlink" title="30-5：泛型应用"></a>30-5：泛型应用</h2><h3 id="30-5-1：List泛型和原始类型List之间的区别"><a href="#30-5-1：List泛型和原始类型List之间的区别" class="headerlink" title="30-5-1：List泛型和原始类型List之间的区别?"></a>30-5-1：List泛型和原始类型List之间的区别?</h3><p> List<Object>和原始类型List之间的区别?</p><ol><li>在编译时编译器不会对原始类型进行类型安全检查，会对带参数的类进行检查</li><li>你可以把任何带参数的类型传递给原始类型List，但是list会产生编译错误</li></ol><h3 id="30-5-2：List泛型和原始类型List泛型之间的区别"><a href="#30-5-2：List泛型和原始类型List泛型之间的区别" class="headerlink" title="30-5-2：List泛型和原始类型List泛型之间的区别?"></a>30-5-2：List泛型和原始类型List泛型之间的区别?</h3><p>List&lt;?&gt;和原始类型List<Object>之间的区别?</p><p>List<?>是一个未知类型的List，而List<Object> 其实是任意类型的List。你可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给 List<Object>。</p><h3 id="30-5-3-子类继承父类的public可以写成private吗"><a href="#30-5-3-子类继承父类的public可以写成private吗" class="headerlink" title="30-5-3:子类继承父类的public可以写成private吗"></a>30-5-3:子类继承父类的public可以写成private吗</h3><p>可以写，但是变为private之后，需要对方法重写写get/set方法</p><h3 id="30-5-4：多态时是否会出现类型擦除"><a href="#30-5-4：多态时是否会出现类型擦除" class="headerlink" title="30-5-4：多态时是否会出现类型擦除"></a>30-5-4：多态时是否会出现类型擦除</h3><p>会出现类型擦除<br>编译器在编译一个继承自泛型类的子类时，<br>为了方法覆盖的签名匹配，保留泛型类型的多态性，会生成一个桥接方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="2020/11/28/%E6%B3%A8%E8%A7%A3/"/>
      <url>2020/11/28/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<font color = gold ><p>都说框架=反射+注解+设计模式<br>那么接着就来总结一下关于注解的知识把～～</p></font><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="元注解以及分类"><a href="#元注解以及分类" class="headerlink" title="元注解以及分类"></a>元注解以及分类</h2><p>定义其他注解的注解 ，共四个</p><ol><li>@Target（表示该注解可以用于什么地方）</li><li>@Retention（表示再什么级别保存该注解信息）</li><li>@Documented（将此注解包含再javadoc中）</li><li>@Inherited（允许子类继承父类中的注解）</li></ol><h2 id="Java常用注解"><a href="#Java常用注解" class="headerlink" title="Java常用注解"></a>Java常用注解</h2><ol><li>@Override 表示当前方法覆盖了父类的方法</li><li>@Deprecation 表示方法已经过时,方法上有横线，使用时会有警告。</li><li>@SuppressWarnings 表示关闭一些警告信息(通知java编译器忽略特定的编译警告)</li><li>SafeVarargs (jdk1.7更新) 表示：专门为抑制“堆污染”警告提供的。</li><li>@FunctionalInterface (jdk1.8更新) 表示：用来指定某个接口必须是函数式接口，否则就会编译出错。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建线程？几种方式？</title>
      <link href="2020/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%9F/"/>
      <url>2020/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么创建线程"><a href="#怎么创建线程" class="headerlink" title="怎么创建线程"></a>怎么创建线程</h2><p><strong>JDK1.5之前</strong>创建新执行线程有两种方法：</p><h3 id="继承Thread类的方式"><a href="#继承Thread类的方式" class="headerlink" title="继承Thread类的方式"></a>继承Thread类的方式</h3><p><strong>方式一：继承Thread类</strong></p><ol><li><p>定义子类继承Thread类。</p></li><li><p>子类中重写Thread类中的run方法。</p></li><li><p>创建Thread子类对象，即创建了线程对象。</p></li><li><p>调用线程对象start方法</p></li></ol><h3 id="实现Runnable接口的方式"><a href="#实现Runnable接口的方式" class="headerlink" title="实现Runnable接口的方式"></a>实现Runnable接口的方式</h3><p>方式二：实现Runnable接口</p><ol><li><p>定义子类，实现Runnable接口。</p></li><li><p>子类中重写Runnable接口中的run方法。</p></li><li><p>通过Thread类含参构造器创建线程对象。</p></li><li><p>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</p></li><li><p>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</p></li></ol><p>public class Thread extends Object implements Runnable<br>都需要重写run方法，</p><h2 id="实现方式的好处"><a href="#实现方式的好处" class="headerlink" title="实现方式的好处"></a><code>实现方式的好处</code></h2><ol><li>避免了单继承的局限性s extends Thread就不能继承其他的父类了</li><li><code>多个线程可以共享同一个接口实现类的对象</code>，非常适合多个相同线程来处理同一份资源。 </li><li><code>以继承的方式的共享数据的话就需要写static</code></li></ol><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与使用Runnable相比， Callable功能更强大些</p><p><strong>run()方法，<br>可以有返回值<br>方法可以抛出异常<br>支持泛型的返回值</strong><br>需要借助FutureTask类，比如获取返回结果<br>FutureTask 同时实现了Runnable, Future接口。它既可以作为 Runnable被线程执行，又可以作为Future得到Callable的返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;Integer&gt;(new MyThread03());        new Thread(futureTask).start();        try &#123;            Integer value &#x3D; futureTask.get();&#x2F;&#x2F;            System.out.println(value);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; catch (ExecutionException e) &#123;            e.printStackTrace();        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h3><p>比如并发情况下请求树多，且每个线程的执行时间端的情况下，经常创建和销毁线程 对性能影响很大。<br>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完 放回池中。可以避免频繁创建销毁、实现重复利用。<br>好处：</p><p>提高响应速度（减少了创建新线程的时间）<br>降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>便于线程管理<br> corePoolSize：核心池的大小<br> maximumPoolSize：最大线程数<br> keepAliveTime：线程没有任务时最多保持多长时间后会终止</p><p>JDK 5.0起提供了线程池相关API：<br>ExecutorService 和 Executors<br>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor</p><p><code>void execute(Runnable command)</code> ：执行任务/命令，没有返回值，一般用来执行 Runnable<br><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务，有返回值，一般又来执行 Callable<br><code>void shutdown() ：关闭连接池</code></p><p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p><p><code>Executors.newCachedThreadPool()</code>：创建一个可根据需要创建新线程的线程池<br><code>Executors.newFixedThreadPool(n)</code>; 创建一个可重用固定线程数的线程池<br><code>Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池<br><code>Executors.newScheduledThreadPool(n)</code>：创建一个线程池，它可安排在给定延迟后运 行命令或者定期地执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;&#x2F;&#x2F;创建并使用多线程的第四种方法：使用线程池class MyThread implements Runnable &#123;@Overridepublic void run() &#123;for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);&#125;&#125;&#125;public class ThreadPool &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 1.调用Executors的newFixedThreadPool(),返回指定线程数量的ExecutorServiceExecutorService pool &#x3D; Executors.newFixedThreadPool(10);&#x2F;&#x2F; 2.将Runnable实现类的对象作为形参传递给ExecutorService的submit()方法中，开启线程&#x2F;&#x2F; 并执行相关的run()pool.execute(new MyThread());pool.execute(new MyThread());pool.execute(new MyThread());&#x2F;&#x2F; 3.结束线程的使用pool.shutdown();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><h3 id="使用两个线程打印-1-100。线程1-线程2-交替打印"><a href="#使用两个线程打印-1-100。线程1-线程2-交替打印" class="headerlink" title="使用两个线程打印 1-100。线程1, 线程2 交替打印"></a>使用两个线程打印 1-100。线程1, 线程2 交替打印</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu;public class ThreadCommunication&#123;    public static void main(String[] args) &#123;        PrintNumber printNumber &#x3D; new PrintNumber();        Thread thread &#x3D; new Thread(printNumber, &quot;分线程1&quot;);        Thread thread1 &#x3D; new Thread(printNumber, &quot;分线程11&quot;);        thread.start();        thread1.start();    &#125;&#125;class PrintNumber implements Runnable&#123;    int number &#x3D; 1;    @Override    public void run() &#123;        while(true)&#123;            synchronized (this)&#123;                notify();                if (number&lt;&#x3D;100)&#123;                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+number);                    number++;                &#125;else &#123;                    break;                &#125;                try &#123;                    wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="wait-与-notify-和-notifyAll"><a href="#wait-与-notify-和-notifyAll" class="headerlink" title="wait() 与 notify() 和 notifyAll()"></a>wait() 与 notify() 和 notifyAll()</h3><p>wait()：令当前线程阻塞，并释放锁，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</p><p>notify()：唤醒被wait的一个线程， 如果说有多个线程被阻塞的话。就唤醒优先级最高的那个<br>notifyAll ()：唤醒所有wait线程</p><p><code>这三个方法只有在synchronized方法或synchronized代码块中才能使用</code>，</p><p><code>这三个方法的调用者必须是同步监视器</code>，否则会报 java.lang.`IllegalMonitorStateException异常。</p><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处 取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如 果店中有产品了再通知消费者来取走产品。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Clerk &#123;     &#x2F;&#x2F; 售货员     private int product &#x3D; 0;     public synchronized void addProduct() &#123;         if (product &gt;&#x3D; 20) &#123;             try &#123;                 wait();             &#125; catch (InterruptedException e) &#123;                e.printStackTrace(); &#125;&#125; else &#123;     product++;     System.out.println(&quot;生产者生产了 第&quot; + product + &quot;个产品&quot;);     notifyAll();public synchronized void getProduct() &#123;     if (this.product &lt;&#x3D; 0) &#123;         try &#123;             wait();             &#125; catch (InterruptedException e) &#123;                 e.printStackTrace();                 &#125;                 &#125; else &#123;                     System.out.println(&quot;消费者取走了第&quot; + product + &quot;个产品&quot;); product--; notifyAll();                     &#125;                &#125;             &#125;    &#125;&#125;class Productor implements Runnable &#123; &#x2F;&#x2F; 生产者     Clerk clerk;    public Productor(Clerk clerk) &#123; this.clerk &#x3D; clerk; &#125;    public void run() &#123;    System.out.println(&quot;生产者开始生产产品&quot;);     while (true) &#123;         try &#123;         Thread.sleep((int) Math.random() * 1000);         &#125; catch (InterruptedException e) &#123;             e.printStackTrace(); &#125;              clerk.addProduct();              &#125;    &#125;&#125;class Consumer implements Runnable &#123; &#x2F;&#x2F; 消费者     Clerk clerk; public Consumer(Clerk clerk) &#123; this.clerk &#x3D; clerk; &#125;    public void run() &#123;    System.out.println(&quot;消费者开始取走产品&quot;);     while (true) &#123; try &#123;         Thread.sleep((int) Math.random() * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;         clerk.getProduct(); &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><h2 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a><code>synchronized 与 Lock 的对比</code></h2><ol><li><p>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），<br>synchronized是 隐式锁，出了作用域自动释放<br>当前线程的同步方法、同步代码块执行结束。<br>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、 该方法的继续执行。<br>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。<br>当前线程在同步代码块、同步方法中执行了线程对象的<code>wait()</code>方法，<code>当前线程暂停，并释放锁。</code></p></li><li><p>Lock只有代码块锁，<br>synchronized有代码块锁和方法锁</p></li><li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性（提供更多的子类）</p></li></ol><h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><ol start="5"><li>run()方法由JVM调用，<strong>什么时候调用，执行的过程控制都有操作系统的CPU 调度决定。</strong></li></ol><ol start="6"><li><strong>一个线程对象只能调用一次start()方法</strong>启动，如果重复调用了，则将抛出以上 的异常“<code>IllegalThreadStateException</code>”。<br>常用方法：<br><code>static Thread yield()</code>:释放当前线程cpu的执行权 ，下一时刻还可以再获取到<br><code>join()</code>:当a线程调用b线程的 join() 方法时，<code>a线程将被阻塞</code>，直到b线程执行完为止,a线程才结束阻塞<br><code>static void sleep(long millis)</code>：(指定时间:毫秒)<br>令当前活动线程在<strong>指定时间段内放弃对CPU控制</strong>,使其他线程有机会被执行,<strong>时间到后重排队</strong>。 抛出InterruptedException异常<br>stop(): 强制线程生命期结束，不推荐使用<br>boolean isAlive()：返回boolean，判断线程是否还活着</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/23/javaweb%E7%AC%94%E8%AE%B0-----javascript/"/>
      <url>2020/11/23/javaweb%E7%AC%94%E8%AE%B0-----javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li><p>变量声明，javascript弱类型语言，动态类型语言运行期间可以任意赋值<br> var i = 0;<br> i = true;<br> i = “hi”;<br> alert(i);<br> var str= “helloworld”;<br> alert(str);</p></li><li><p>变量赋值</p></li><li><p>变量严格区分大写小写</p></li><li><p>数据类型<br> String ， number 布尔 数组  对象 null Undefined(只声明不赋值)</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用function声明</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/22/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/cookie--session/"/>
      <url>2020/11/22/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/cookie--session/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81-id%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81-id%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单体项目--准备工作</title>
      <link href="2020/11/20/%E7%94%B5%E5%95%86%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
      <url>2020/11/20/%E7%94%B5%E5%95%86%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="电商项目：单体架构设计于项目开发"><a href="#电商项目：单体架构设计于项目开发" class="headerlink" title="电商项目：单体架构设计于项目开发"></a>电商项目：单体架构设计于项目开发</h1><h1 id="基于SpringBoot2-x"><a href="#基于SpringBoot2-x" class="headerlink" title="基于SpringBoot2.x"></a>基于SpringBoot2.x</h1><p>实现单体电商项目核心功能开发</p><p>实现单体电商项目个人中心功能</p><p>项目部署上线</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>项目展示以及主要的功能：轮播图<br>                    主页不同分类<br>                    根据页面的滚动慢慢的进行加载：在前端设计的调用模式<br>                    首页搜索功能：输入关键词 页面跳转<br>                    分页功能<br>                    默认排序 销量排序 价格有限 排序规则<br>                    购物车<br>                    支付<br>                    没有登录的话就登录<br>                    登录功能 回调到购物车<br>                    结算页面  地址 可以进行编辑 选择<br>                    微信支付 支付宝支付<br>                    查看我的订单 跳转到个人中心<br>                    个人中心：代发货<br>                    其中就是订单<br>                    我的评价<br>                    我的信息<br>                    收货地址</p><h2 id="前后段主要技术选型"><a href="#前后段主要技术选型" class="headerlink" title="前后段主要技术选型"></a>前后段主要技术选型</h2><p>后段技术选型<br><code>SpringBoot Spring Mybatis</code> 框架整合</p><p>SpringBoot还是SpringMVC??<br>SpringMVC是框架  配置项很多就很繁琐<br>                还得自己下载tomcat<br>SpringBoot是框架：主要实现了自动配置，<br>                从xml配置繁琐到yml，<br>                还集成了很多的中间件，用starter依赖和引用，简化了maven配置<br>                从外置的tomcat变为内置的tomcat，在yaml就可以配置</p><p>前端技术选型：<br>        Jquery<br>        VUE本身是渐进式框架，方便。在渐进式过程中可以逐步逐步去替换掉原来的代码<br>        html<br>        css</p><p>技术选型要考虑到的：<br>    切合业务<br>    社区活跃度：代表使用率高，优缺点<br>    团队技术水平<br>    版本更新迭代的周期：以前Dubbo中间停更了一段时间，那么这段时间就会影响业务的使用<br>    安全性<br>    成功案例：口碑不错的</p><h2 id="前后端分离开发模式："><a href="#前后端分离开发模式：" class="headerlink" title="前后端分离开发模式："></a>前后端分离开发模式：</h2><p>早起传统的JAVAweb开发模式：<br>                      用户 – 浏览器 -url–服务器 war包(后段model,view,controller 前端html(jsp渲染成html)cssjs)  只要有用户访问服务器，所有请求的页面都在服务器进行渲染。当用户越来越多的话， 所有页面都在服务器进行渲染，服务器压力太大了了。<br>                      需要注意的是  传统web开发 ，浏览器请求到的服务器的所有页面都是基于url来进行跳转的</p><p>前后端单页面的交互：mvvm前端开发模式<br>                        手机  – 小程序/安卓—- ———–服务器model,view<br>                      用户—-浏览器–h5–nginx（html css js）–Restful webservice&gt;-服务器model,view,controller静态资源在静态资源服务器上，<br>                      前端龟前端，后端代码只要一套极好了</p><h2 id="数据库表设计："><a href="#数据库表设计：" class="headerlink" title="数据库表设计："></a>数据库表设计：</h2><p>全局的规划，数据库表设计工具设计库以及表，前期就设计好的<br><code>PDMan</code>:<br>            数据库建模工具<br>            设置：预处理的模版， 每次新建表的时候都会生成<br>            数据库设置：<br>            如何把关系图和数据库的表进行对应：模型版本–初始化基线写版本号-点击同步，注意同步配置里选的必须是增量</p><hr><h3 id="我们的设计库表中没有使用数据库外键"><a href="#我们的设计库表中没有使用数据库外键" class="headerlink" title="我们的设计库表中没有使用数据库外键"></a>我们的设计库表中没有使用数据库外键</h3><p>1，性能影响</p><p>对于数据的完整性会做检查操作，特别是在大并发的时候，会影响性能</p><p>2，热更新（不停机维护）<br>如果有外键的话，是强一致性的，使的新更新的代码无法运行，需要重启服务。而我们希望不停机维护。</p><p>3 降低耦合度</p><p>物理外键不存在，逻辑外键还是存在的，比如说cghtb有htbh字段，htmxb也有htbh字段</p><p>4 数据库分库发表<br>有外键关系的两张表，难以做到分到两个不同的数据库，因为耦合度是在是太高了。</p><hr><h2 id="项目结构搭建"><a href="#项目结构搭建" class="headerlink" title="项目结构搭建"></a>项目结构搭建</h2><h3 id="项目拆分与聚合："><a href="#项目拆分与聚合：" class="headerlink" title="项目拆分与聚合："></a>项目拆分与聚合：</h3><p>后段分层架构模式：基于maven分层与拆分<br>项目分层设计原则<br>前期拆分：根据业务拆分为不同的子模块<br>后期聚合：通过<code>maven</code>项目的聚合</p><p>jar                             common.jar子模块/工程  pojo.jar(数据库表逆向生成)  mapper.jar<br>或者        —-                service.jar  controller.jar     。。。<br>war<br>最终运行的包                      pom聚合工程  所有子模块都在聚合工程里面</p><p>这样的话就可以很多人进行开发<br>多个不同的项目可以都导入common的依赖不用多次写代码，</p><h3 id="Idea构建：具体操作的话可以参考https-blog-csdn-net-weixin-43434182-article-details-108017186"><a href="#Idea构建：具体操作的话可以参考https-blog-csdn-net-weixin-43434182-article-details-108017186" class="headerlink" title="Idea构建：具体操作的话可以参考https://blog.csdn.net/weixin_43434182/article/details/108017186"></a>Idea构建：具体操作的话可以参考<a href="https://blog.csdn.net/weixin_43434182/article/details/108017186">https://blog.csdn.net/weixin_43434182/article/details/108017186</a></h3><pre><code> 1. 拆分：        父工程由于构建的是聚合工程，所以打包方式选择pom        构建pojo，pojo引用common        构建mapper，mapper引用pojo，        构建service，service引用mapper，        构建api，api引用service    聚合：root --install 之后依赖关系才会真正的建立2. 父工程整合spring boot   pom.xml引入spring boot基础依赖</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.imooc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>foodie-dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--        1.聚合工程可以分顶级项目（顶级工程，父工程）和子工程，两者之间为继承关系        子工程在maven中称之为module，模块之间时平级的，可以相互依赖        2.子工程可以使用父工程所有的资源（依赖），子工程之间如果需要相互之间使用资源，需要构建依赖（构建关系）        3.父工程可以由多个子工程组合而成    --></span>    <span class="token comment" spellcheck="true">&lt;!--所有的子工程都会在这里出现--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-common<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-pojo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-mapper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 聚合工程打包方式选择pom--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--引入依赖parent,统一管理版本--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--设置资源属性--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--设置源码编码格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--设置编译后文件编码格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!--排除这一块依赖，后续引入其他依赖--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--spring boot可以解析yml文件，如果想解析xml等非yml配置文件，需要此依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-configuration-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span>然后在controller层就可以在resource下创建application.yml</code></pre><p>然后编写启动类<br>    <code>java     @SpringBootApplication     public class Application &#123;         public static void main(String[] args) &#123;             SpringApplication.run(Application.class,args);         &#125;     &#125;     </code></p><p>然后，因为是聚合项目，需要先install子项目，使其成为主项目的依赖，然后启动项目</p><hr><p>mybatis mysql mapper<br>导入依赖<br>写配置文件<br>mybatis逆向生成工具:打开项目，主要修改generatorConfig.xml文件,然后GeneratorDisplay，右键运行，生成相应的文件，<br>复制到项目中，因为引用了通用mapper，需要在项目中进行相应的配置</p><p>Restful<br>api service 层开发<br><code>Postman</code>调试Restful接口</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8 9 10新特性</title>
      <link href="2020/11/20/java8910%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>2020/11/20/java8910%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p><code>Lambda 表达式</code>：在Java 8 语言中引入的一种新的语法元素和操 作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符 或箭头操作符。它将 Lambda 分为两个部分：<br><code>接口中有且仅有一个抽象方法，但是允许有其他实现的default方法</code><br><code>左侧</code>：指定了 Lambda 表达式需要的参数列表<br><strong>数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</strong><br><strong>Lambda 若只需要一个参数时，参数的小括号可以省略</strong><br><code>右侧</code>：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。<br><strong>当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</strong></p><h2 id="函数式-Functional-接口"><a href="#函数式-Functional-接口" class="headerlink" title="函数式(Functional)接口"></a>函数式(Functional)接口</h2><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h2 id="强大的Stream-API"><a href="#强大的Stream-API" class="headerlink" title="强大的Stream API"></a>强大的Stream API</h2><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者---线程通信</title>
      <link href="2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      
        <content type="html"><![CDATA[<p>题目：现在两个线程，可以操作初始值为零的变量，<br>实现一个线程+1，一个线程减1；<br>交替打印 来10轮 变量初始值为零</p><font color='orange' ><ol><li><p><code>线程操作资源类</code>：高内聚低耦合</p></li><li><p>通信：不符合条件判断等待，业务逻辑，唤醒；</p></li><li><p>多线程交互中，必须要防止多线程的<code>虚假唤醒</code>，也即在多线程判断中不许用if，就要用while</p></li></ol></font><hr><h2 id="synchronized-wait-notifyAll"><a href="#synchronized-wait-notifyAll" class="headerlink" title="synchronized+wait+notifyAll"></a>synchronized+wait+notifyAll</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Opera&#123;    private int num &#x3D; 0;    public synchronized void incrnum() throws InterruptedException &#123;        while(num!&#x3D;0)&#123;            this.wait();        &#125;        num++;        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num);        this.notifyAll();    &#125;    public synchronized void decrnum() throws InterruptedException &#123;        while(num&#x3D;&#x3D;0)&#123;            this.wait();        &#125;        num--;        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num);        this.notifyAll();    &#125;    public static void main(String[] args) &#123;        Opera op &#x3D; new Opera();        Thread b &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.decrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;b&quot;);        Thread a &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.incrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;a&quot;);        Thread c &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.incrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;c&quot;);        Thread d &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.decrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;d&quot;);        a.start();        b.start();        c.start();        d.start();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Lock-await-signalAll"><a href="#Lock-await-signalAll" class="headerlink" title="Lock+await+signalAll"></a>Lock+await+signalAll</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Opera1&#123;    private int num &#x3D; 0;    private  Lock lock &#x3D;new ReentrantLock();    private Condition condition &#x3D; lock.newCondition();    public void incrnum() throws InterruptedException &#123;        lock.lock();        try &#123;            while(num!&#x3D;0)&#123;                condition.await();            &#125;            num++;            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num);            condition.signalAll();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public  void decrnum() throws InterruptedException &#123;        lock.lock();        try &#123;            while(num&#x3D;&#x3D;0)&#123;                condition.await();            &#125;            num--;            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num);            condition.signalAll();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;public static void main(String[] args) &#123;        Opera1 op &#x3D; new Opera1();        Thread b &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.decrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;b&quot;);        Thread a &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.incrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;a&quot;);        Thread c &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.incrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;c&quot;);        Thread d &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.decrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;d&quot;);        a.start();        b.start();        c.start();        d.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="精确通知顺序访问"><a href="#精确通知顺序访问" class="headerlink" title="精确通知顺序访问"></a>精确通知顺序访问</h2><font color='orange' ><ol><li><p><code>线程操作资源类</code>：高内聚低耦合</p></li><li><p>通信：不符合条件判断等待，业务逻辑，唤醒；</p></li><li><p>多线程交互中，必须要防止多线程的<code>虚假唤醒</code>，也即在多线程判断中不许用if，就要用while</p></li><li><p>标识位</p></li></ol></font><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class OrderCommunition &#123;    public static void main(String[] args) &#123;        OrderPrint orderPrint &#x3D; new OrderPrint();        new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 3; i++) &#123;                try &#123;                    orderPrint.print1();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();        new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 3; i++) &#123;                try &#123;                    orderPrint.print2();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();        new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 3; i++) &#123;                try &#123;                    orderPrint.print3();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();    &#125;&#125;class OrderPrint&#123;    private  int number &#x3D; 1;    private Lock lock &#x3D; new ReentrantLock();    private Condition condition1&#x3D; lock.newCondition();    private Condition condition2&#x3D; lock.newCondition();    private Condition condition3&#x3D; lock.newCondition();    public void print1() throws InterruptedException &#123;        lock.lock();        try &#123;            while(number!&#x3D;1)&#123;                condition1.await();            &#125;            for (int i &#x3D; 0; i &lt; 5; i++) &#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;            number&#x3D;2;            condition2.signal();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void print2() throws InterruptedException &#123;        lock.lock();        try &#123;            while(number!&#x3D;2)&#123;                condition2.await();            &#125;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;            number&#x3D;3;            condition3.signal();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void print3() throws InterruptedException &#123;        lock.lock();        try &#123;            while(number!&#x3D;3)&#123;                condition3.await();            &#125;            for (int i &#x3D; 0; i &lt; 5; i++) &#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;            number&#x3D;1;            condition1.signal();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全如何保证？</title>
      <link href="2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="线程的安全"><a href="#线程的安全" class="headerlink" title="线程的安全"></a>线程的安全</h2><ol><li><code>synchronized</code><h3 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h3><code>同步方法的锁</code>：静态方法（类名.class）、非静态方法（this）<br><code>同步代码块</code>：自己指定，很多时候也是指定为this或类名.class<br>必须确保使用<code>同一个资源的多个线程共用一把锁</code> ，这个非常重要 ，否则就无法保证共享资源的安全<br><code>一个线程类中的所有静态方法共用同一把锁（类名.class）</code>，<br><code>所有非静态方法共用同一把锁（this）</code><br>同步代码块（指定需谨慎）<br>必须是同一把锁<br> <code>注意的是</code><br>在Thread中要谨慎使用this作为同步监视器 ，因为都是new thread() 多线程调用的时候不是同一把锁<br>而在Runnable的时候， 多个线程通过共同实现Runnable接口，所以的话可以使用this作为同步监视器</li></ol><h3 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h3><p>当前线程的同步方法、同步代码块执行结束。<br>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、 该方法的继续执行。<br>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。<br>当前线程在同步代码块、同步方法中执行了线程对象的<code>wait()</code>方法，<code>当前线程暂停，并释放锁。</code><br> 2.  Lock(锁)</p><p>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。<br>java.util.concurrent.locks.<code>Lock接口</code>是控制多个线程对共享资源进行访问的 工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p><p><code>ReentrantLock </code>类实现了 Lock ，它拥有与 synchronized 相同的并发性和 内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以 显式加锁、释放锁。<br>非公平锁：十分不公平：可以插队 （默认）</p><p>严格按照规范来写   lock.lock(); 在try外面</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class A&#123;private final ReentrantLock lock &#x3D; new ReenTrantLock(); public void m()&#123;lock.lock(); try&#123;&#x2F;&#x2F;保证线程安全的代码; &#125; finally&#123;lock.unlock(); &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁的学习案例--理解</title>
      <link href="2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B--%E7%90%86%E8%A7%A3/"/>
      <url>2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B--%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a><code>加深理解</code></h2><ol><li>如果说同一个类中有多个非static的synchronized的时候，某一个时刻内，只能一个线程去调用其中的一个Synchronized方法</li><li>sleep是不会释放锁的</li><li>不同点的线程可以同时访问synchronized方法和普通方法</li><li>如果锁的不是同一个对象时，可以同时访问</li><li>静态同步方法，多个线程都是锁的同一个字节码</li><li>静态同步方法和对象不是同一个锁</li></ol>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="2020/11/20/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>2020/11/20/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>redis  6.0.8</p><p><code>分布式锁</code> ： 在分布式架构中 拆分哥哥微服务之后 为了避免冲突和数据故障而加入的一种锁</p><p>mysql<br>zookeeper<br>redis<br>一班大家都习惯redis分布式锁</p><p>redis—redlock ====redission lock  unlock</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="2020/11/20/maven/%E4%BB%80%E4%B9%88%E6%98%AFmaven/"/>
      <url>2020/11/20/maven/%E4%BB%80%E4%B9%88%E6%98%AFmaven/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用maven"><a href="#为什么要使用maven" class="headerlink" title="为什么要使用maven"></a>为什么要使用maven</h2><p>Maven是干什么用的？们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。<br>1.1 添加第三方jar包<br>在今天的JavaEE开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些jar包最简单的方法就是复制粘贴到 <code>WEB-INF目录下的lib目录</code>下。但是这会导致每次创建一个新的工程就需要将jar包重复复制到lib目录下，从而造成工作区中存在<code>大量重复</code>的件。<br>使用Maven后每个jar包只在<code>本地仓库</code>中保存<code>一份</code>，需要jar包的工程只需要维护一个文本形式的jar包的引用——我们称之为“<code>坐标</code>”。不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。<br>1.2 jar包之间的依赖关系<br>jar包往往不是孤立存在的，很多jar包都需要在其他jar包的支持下才能够正常工作，我们称之为jar包之间的依赖关系。<br>那么问题来了，你知道你所使用的所有jar包的依赖关系吗？<br>当你拿到一个新的从未使用过的jar包，你如何得知他需要哪些jar包的支持呢？如果不了解这个情况，导入的jar包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个jar包时，你还会人为的，手工的逐一确认它们依赖的其他jar包吗？这简直是不可想象的。<br><strong>引入Maven后</strong>，Maven就可<strong>以替我们自动的将当前jar包所依赖的其他所有jar包全部导入进来，无需人工参与，</strong>节约了我们大量的时间和精力<br>1.3 处理jar包之间的冲突<br>上一点说的是jar包不足项目无法正常工作，但其实有的时候jar包多了项目仍然无法正常工作，这就是jar包之间的冲突。<br>举个例子：我们现在有三个工程MakeFriend、HelloFriend、和Hello。MakeFriend依赖HelloFriend，HelloFriend依赖Hello。而Hello依赖log4j.1.2.17.jar，HelloFriend依赖log4j.1.2.14.jar。<br>那么MakeFriend工程的运行时环境中该导入log4j.1.2.14.jar呢还是log4j.1.2.17.jar呢？<br>这样的问题一个两个还可以手工解决，但如果系统中存在几十上百的jar包，他们之间的依赖关系会非常复杂，几乎不可能手工实现依赖关系的梳理。<br>使用Maven就可以自动的处理jar包之间的冲突问题。因为Maven中内置了两条依赖原则：   **<code>最短路径者优先和先声明者优先</code>**，上述问题MakeFriend工程会自动使用log4j.1.2.14.jar。<br>1.4 获取第三方jar包<br>JavaEE开发中需要使用到的jar包种类繁多，几乎每个jar包在其本身的官网上的获取方式都不尽相同。为了查找一个jar包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的jar包里有的时候并没有你需要的那个类，又或者又同名的类没有你要的方法——以不规范的方式获取的jar包也往往是不规范的。<br>使用Maven我们可以享受到一个完全统一规范的jar包管理体系。你只需要在你的项目中以坐标的方式依赖一个jar包，Maven就会自动从<code>中央仓库</code>进行下载，并同时下载这个jar包所依赖的其他jar包——规范、完整、准确！一次性解决所有问题！<br>1.5 将项目拆分成多个工程模块<br>随着JavaEE项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于JavaEE项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个Web工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过package结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是Java工程，有的是Web工程。<br>那么<code>工程拆分后又如何进行互相调用和访问呢</code>？这就需要用到Maven的<code>依赖管理机制</code>。大家请看我们的Survey调查项目拆分的情况：</p><p>上层模块依赖下层，所以下层模块中定义的API都可以为上层所调用和访问。<br>1.6 实现项目的分布式部署<br>在实际生产环境中，项目规模增加到一定程度后，可能每个模块都需要运行在独立的服务器上，我们称之为`分布式部署，这里同样需要用到Maven。</p><h2 id="什么是maven"><a href="#什么是maven" class="headerlink" title="什么是maven"></a>什么是maven</h2><p> Maven是一款自动化构建工具，专注服务于Java平台的项目构建和依赖管理。</p><h3 id="那么什么是构建呢？"><a href="#那么什么是构建呢？" class="headerlink" title="那么什么是构建呢？"></a>那么什么是构建呢？</h3><p>构建并不是创建，创建一个工程并不等于构建一个项目。要了解构建的含义我们应该由浅入深的从以下三个层面来看：<br>①纯Java代码<br>大家都知道，我们Java是一门编译型语言，.java扩展名的源文件需要编译成.class扩展名的字节码文件才能够执行。所以编写任何Java代码想要执行的话就必须经过编译得到对应的.class文件。<br>②Web工程<br>当我们需要通过浏览器访问Java程序时就必须将包含Java程序的Web工程编译的结果“拿”到服务器上的指定目录下，并启动服务器才行。这个“拿”的过程我们叫部署。<br>我们可以将未编译的Web工程比喻为一只生的鸡，编译好的Web工程是一只煮熟的鸡，编译部署的过程就是将鸡炖熟。<br>Web工程和其编译结果的目录结构对比见下图：</p><p>③实际项目<br>在实际项目中整合第三方框架，Web工程中除了Java程序和JSP页面、图片等静态资源之外，还包括第三方框架的jar包以及各种各样的配置文件。所有这些资源都必须按照正确的目录结构部署到服务器上，项目才可以运行。<br>所以综上所述：构建就是以我们编写的Java代码、框架配置文件、国际化等其他资源文件、JSP页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。<br>那么项目构建的全过程中都包含哪些环节呢？</p><h3 id="构建环节"><a href="#构建环节" class="headerlink" title="构建环节"></a>构建环节</h3><p>①清理：删除以前的编译结果，为重新编译做好准备。<br>②编译：将Java源程序编译为字节码文件。<br>③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。<br>④报告：在每一次测试后以标准的格式记录和展示测试结果。<br>⑤打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应jar包，Web工程对应war包。<br>⑥安装：在Maven环境下特指将打包的结果——jar包或war包安装到本地仓库中。<br>⑦部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>当A jar包需要用到B jar包中的类时，我们就说A对B有依赖。<br>通过第二个Maven工程我们已经看到，当前工程会到本地仓库中根据坐标查找它所依赖的jar包。<br>配置的基本形式是使用dependency标签指定目标jar包的坐标。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">   &lt;dependencies&gt;&lt;dependency&gt;&lt;!—坐标 --&gt;&lt;groupId&gt;junit&lt;&#x2F;groupId&gt;&lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;&lt;version&gt;4.10&lt;&#x2F;version&gt;&lt;!-- 依赖的范围 --&gt;&lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="直接依赖和间接依赖"><a href="#直接依赖和间接依赖" class="headerlink" title="直接依赖和间接依赖"></a>直接依赖和间接依赖</h3><p>如果A依赖B，B依赖C，那么A→B和B→C都是直接依赖，而A→C是间接依赖。</p><h3 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h3><p>当一个Maven工程添加了对某个jar包的依赖后，这个被依赖的jar包可以对应下面几个可选的范围：<br>①compile<br>[1]<strong>main目录下的Java代码可以访问这个范围的依赖</strong><br>[2]<strong>test目录下的Java代码可以访问这个范围的依赖</strong><br>[3]<strong>部署到Tomcat服务器上运行时要放在WEB-INF的lib目录下</strong><br>例如：对Hello的依赖。主程序、测试程序和服务器运行时都需要用到。<br>②test<br>[1]<strong>main目录下的Java代码不能访问这个范围的依赖<br>[2]test目录下的Java代码可以访问这个范围的依赖<br>[3]部署到Tomcat服务器上运行时不会放在WEB-INF的lib目录下</strong><br>例如：对junit的依赖。仅仅是测试程序部分需要。<br>③provided<br>[1]main目录下的Java代码可以访问这个范围的依赖<br>[2]test目录下的Java代码可以访问这个范围的依赖<br>[3]部署到Tomcat服务器上运行时不会放在WEB-INF的lib目录下<br>例如：servlet-api在服务器上运行时，Servlet容器会提供相关API，所以部署的时候不需要。</p><h3 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h3><p>当存在间接依赖的情况时，主工程对间接依赖的jar可以访问吗？这要看间接依赖的jar包引入时的依赖范围——<code>只有依赖范围为compile时可以访问</code>。例如：</p><h3 id="依赖的原则：解决jar包冲突"><a href="#依赖的原则：解决jar包冲突" class="headerlink" title="依赖的原则：解决jar包冲突"></a>依赖的原则：解决jar包冲突</h3><p><code>路径最短者优先</code><br> 举个例子：我们现在有三个工程MakeFriend、HelloFriend、和Hello。MakeFriend依赖HelloFriend，HelloFriend依赖Hello。而Hello依赖log4j.1.2.17.jar，HelloFriend依赖log4j.1.2.14.jar。<br><code>路径相同时先声明者优先</code></p><p>这里“声明”的先后顺序指的是<code>dependency标签配置的先后顺序。</code></p><h3 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h3><p>有的时候为了确保程序正确可以将有可能重复的间接依赖排除。</p><pre class="line-numbers language-none"><code class="language-none">&lt;exclusions&gt;&lt;exclusion&gt;&lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt;&lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt;&lt;&#x2F;exclusion&gt;&lt;&#x2F;exclusions&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="统一管理目标jar包的版本"><a href="#统一管理目标jar包的版本" class="headerlink" title="统一管理目标jar包的版本"></a>统一管理目标jar包的版本</h3><p>以对Spring的jar包依赖为例：Spring的每一个版本中都包含spring-core、spring-context等jar包。我们应该导入版本一致的Spring jar包</p><pre class="line-numbers language-none"><code class="language-none">      &lt;properties&gt;          &lt;spring.version&gt;4.1.1.RELEASE&lt;&#x2F;spring.version&gt;      &lt;&#x2F;properties&gt;      &lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;&lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h2><p>创建父工程和创建一般的Java工程操作一致，唯一需要注意的是：<code>打包方式处要设置为pom。</code><br>在子工程中引用父工程<br>`<parent><br>    <!-- 父工程坐标 --><br>    <groupId>…</groupId><br>    <artifactId>…</artifactId><br>    <version>…</version><br>    <relativePath>从当前目录到父项目的pom.xml文件的相对路径</relativePath><br></parent></p><parent>    <groupId>com.atguigu.maven</groupId>    <artifactId>Parent</artifactId>    <version>0.0.1-SNAPSHOT</version><pre><code>&lt;!-- 指定从当前子工程的pom.xml文件出发，查找父工程的pom.xml的路径 --&gt;&lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;</code></pre><p></parent><code>在父工程中管理依赖 将Parent项目中的dependencies标签，用dependencyManagement标签括起来</code><dependencyManagement><br>    <dependencies><br>        <dependency><br>            <groupId>junit</groupId><br>            <artifactId>junit</artifactId><br>            <version>4.9</version><br>            <scope>test</scope><br>        </dependency><br>    </dependencies><br></dependencyManagement><code>在子项目中重新指定需要的依赖，删除范围和版本号</code><dependencies><br>    <dependency><br>        <groupId>junit</groupId><br>        <artifactId>junit</artifactId><br>    </dependency><br></dependencies>`</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC简介</title>
      <link href="2020/11/20/springmvc/springmvc%E5%BA%94%E7%94%A8/"/>
      <url>2020/11/20/springmvc/springmvc%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-what"><a href="#1-what" class="headerlink" title="1.what"></a>1.what</h2><p>1）    Spring 为基于 <code>MVC 设计理念</code>的优秀的Web 框架，是目前最主流的MVC 框架之一 ，是应用  <code>表现层</code>的框架</p><p><strong><code>MVC设计模式</code></strong></p><p>MVC 全名是 Model View Controller，是 模型(model)－视图(view)－控制器(controller) 的缩写， 是⼀ 种⽤于设计创建 Web 应⽤程序表现层的模式。MVC 中每个部分各司其职：</p><p>Model（模型）：模型包含<code>业务模型和数据模型</code>，数据模型⽤于封装数据[pojo vo前台传递数据 po想数据库持久化数据]，业务模型⽤于处理业务。</p><p>View（视图）： 通常指的就是我们的 jsp 或者 html。作⽤⼀般就是展示数据的。通常视图是<code>依据 模型数据创建</code>的。</p><p>Controller（控制器）： 是应⽤程序中处理⽤户交互的部分。作⽤⼀般就是处理程序逻辑的。</p><p>MVC提倡：每⼀层只编写⾃⼰的东⻄，不编写任何其他的代码；分层是为了<code>解耦</code>，解耦是为了维 护⽅便和<code>分⼯协作</code>。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>它通过⼀套注解，让⼀个简单的Java类成为处理请求的控制器，⽽⽆须实现任何接⼝。</p><p>同时它还⽀持 RESTful 编程⻛格的请求。</p><p><code>Spring MVC 本质可以认为是对servlet的封装</code>，简化了我们serlvet的开发<br><code>作⽤：1）接收请求 2）返回响应，跳转⻚⾯</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>url-pattern配置原理及对静态资源的支持</title>
      <link href="2020/11/20/springmvc/url%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/"/>
      <url>2020/11/20/springmvc/url%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;    &lt;&#x2F;init-param&gt;  &lt;&#x2F;servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;        &lt;!--拦截匹配规则的url请求，进入springmvc框架处理--&gt;    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;  &lt;&#x2F;servlet-mapping&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①    解释配置文件的名称定义规则:<br>②    DispatcherServlet自动加载的配置文件的位置及名称：<br>实际上也可以不通过 contextConfigLocation 来配置 SpringMVC 的配置文件, 而使用默认的.默认的配置文件为: <code>/WEB-INF/&lt;servlet-name&gt;-servlet.xml</code><br>3）    加入 Spring MVC 的配置文件：springmvc.xml<br> <init-param><br>      <param-name>contextConfigLocation</param-name><br>      <param-value>classpath:springmvc.xml</param-value><br>    </init-param></p><h2 id="1：-不会拦截-jsp，"><a href="#1：-不会拦截-jsp，" class="headerlink" title="1：/ 不会拦截 .jsp，"></a>1：<code>/ 不会拦截 .jsp，</code></h2><p>   <code>但是会拦截.html等静态资源</code>（静态资源：除了servlet和jsp之外的<code>js、css、png</code>等）</p><h3 id="为什么配置为-会拦截静态资源？？？"><a href="#为什么配置为-会拦截静态资源？？？" class="headerlink" title="为什么配置为/ 会拦截静态资源？？？"></a><strong>为什么配置为/ 会拦截静态资源？？？</strong></h3><p>因为tomcat容器中有一个web.xml，你的项目中也有一个web.xml<br>父web.xml中有一个DefaultServlet,  url-pattern 是一个 /<br>此时我们自己的web.xml中也配置了一个 / ,<strong>覆写了父web.xml的配置</strong></p><p>当开发人员设置的url-pattern与tomcat的一样时，开发人员的优先被处理<br>所以客户端发送请求的时候，优先通过DispatcherServlet去处理请求，找该请求是否有对应的处理器.<br>因此对于静态资源的请求, SpringMVC 会将他们当成一个普通请求处理,<code>因找不到对应处理器将导致错误</code>。</p><h3 id="为什么不拦截-jsp呢？"><a href="#为什么不拦截-jsp呢？" class="headerlink" title="为什么不拦截.jsp呢？"></a><strong>为什么不拦截.jsp呢？</strong></h3><p>因为父web.xml中有一个  <code>JspServlet</code>，这个servlet<code>拦截.jsp文件</code>，<strong>而我们并没有覆写这个配置，</strong><br>所以springmvc此时不拦截jsp，<strong>jsp的处理交给了tomcat</strong></p><h2 id="2：-拦截所有，包括-jsp"><a href="#2：-拦截所有，包括-jsp" class="headerlink" title="2：/* 拦截所有，包括.jsp"></a>2：/* <code>拦截所有，包括.jsp</code></h2><h2 id="如何解决-拦截静态资源这件事？"><a href="#如何解决-拦截静态资源这件事？" class="headerlink" title="如何解决/拦截静态资源这件事？"></a>如何解决/拦截静态资源这件事？</h2><ol><li>这种方案只能把静态资源防止在webapp目录下<br>在 SpringMVC 的配置文件中<br>配置 <a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a><br>配置 <a href="mvc:annotation-driven/">mvc:annotation-driven/</a>(自动注册合适的适配器和映射器)</li></ol><p><code>关于&lt;mvc:default-servlet-handler/&gt;作用</code><br><a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a> 将在 SpringMVC 上下文中定义一个<code>DefaultServletHttpRequestHandler</code>，<br><strong>它会对进入 <code>DispatcherServlet </code>的请求进行筛查，</strong><br>    —如果发现是是静态资源的请求，就将该请求交由 <strong>WEB 应用服务器默认的 Servlet</strong> 处理，<br>    —如果不是静态资源的请求，才由 DispatcherServlet 继续处理</p><p>一般 WEB 应用服务器默认的 Servlet 的名称都是 default。<br>若所使用的 WEB 服务器的默认 Servlet 名称不是 default，则需要通过 default-servlet-name 属性显式指定        </p><p><code>&lt;mvc:default-servlet-handler default-servlet-name=&quot;&quot;/&gt;</code></p><ol start="2"><li>想要放在resource下放置静态资源a.html<br> &lt;mvc:resources location= “classpath:/“ mapping=”/resources/**”&gt;</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC请求处理流程及三大核心组件</title>
      <link href="2020/11/20/springmvc/%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"/>
      <url>2020/11/20/springmvc/%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC请求流程"><a href="#SpringMVC请求流程" class="headerlink" title="SpringMVC请求流程"></a>SpringMVC请求流程</h2><p>第⼀步：⽤户发送请求⾄前端控制器<code>DispatcherServlet </code><br>第⼆步：<code>DispatcherServlet</code>收到请求,调⽤<code>HandlerMapping处理器映射器</code> ,问当前处理请求的handler，<br>HandlerMapping处理器映射器是个map,key是url,value能够处理当前url的handle,</p><p>第三步：处理器映射器根据请求Url找到具体的<code>Handler</code>（后端控制器:执行具体业务逻辑的方法），返回<code>处理器的执行链</code><br>⽣成处理器对象及处理器<code>拦截器</code>(如果 有则⽣成)⼀并返回<code>DispatcherServlet</code></p><p>第四步：<code>DispatcherServle</code>t调⽤<code>HandlerAdapter处理器适配器</code>去调⽤<code>Handler </code></p><p>第五步：处理器适配器执⾏<code>Handler</code> </p><p>第六步：Handler执⾏完成给处理器适配器返回<code>ModelAndView </code></p><p>第七步：处理器适配器向前端控制器返回 <code>ModelAndView</code>，ModelAndView 是SpringMVC 框架的⼀个底层对象，包括 Model 和 View </p><p>第⼋步：前端控制器请求视图解析器去进⾏视图解析，根据逻辑视图名来解析真正的视图。 </p><p>第九步：视图解析器向前端控制器返回<code>View 对象</code></p><p>第⼗步：前端控制器进⾏视图渲染，就是将模型数据（在 ModelAndView 对象中）填充到 <code>request 域 </code></p><p>第⼗⼀步：前端控制器向⽤户响应结果</p><p><img src="2020-12-09-19-45-53.png"></p><h2 id="Spring-MVC-九⼤组件"><a href="#Spring-MVC-九⼤组件" class="headerlink" title="Spring MVC 九⼤组件"></a>Spring MVC 九⼤组件</h2><p><strong>HandlerMapping（处理器映射器）</strong><br>HandlerMapping 是⽤来查找 Handler 的，也就是处理器，具体的表现形式可以是类，也可以是 ⽅法。<br>⽐如，<code>标注了@RequestMapping的每个⽅法都可以看成是⼀个Handler</code>。<br>Handler<code>负责具体实际的请求处理</code>，在请求到达后，HandlerMapping 的<code>作⽤</code>便是找到请求相应的处理器 <code>Handler</code> 和 <code>Interceptor</code>.<br>HandlerMapping ：请求映射到处理器，找谁来处理，如果映射成功返回一个HandlerExecutionChain对象（包含一个Handler处理器(页面控制器)对象、多个HandlerInterceptor拦截器对象）<br><strong>HandlerAdapter（处理器适配器）</strong><br>HandlerAdapter 是⼀个适配器。因为 Spring MVC 中 Handler 可以是任意形式的，只要能处理请 求即可。但是把请求交给 Servlet 的时候，由于 Servlet 的⽅法结构都是 doService(HttpServletRequest req,HttpServletResponse resp)形式的，要让固定的 Servlet 处理 ⽅法调⽤ Handler 来进⾏处理，便是 HandlerAdapter 的职责(<code>执行不同形式的handler</code>)。</p><p><strong>ViewResolver</strong><br>视图解析器，找谁来处理返回的页面。把<code>逻辑视图解析为具体的View</code>,进行这种<strong>策略模式</strong>，很容易更换其他视图技术；<br>如<code>InternalResourceViewResolver</code><strong>将逻辑视图名映射为JSP视图</strong></p><p><strong>HandlerExceptionResolver</strong><br>HandlerExceptionResolver ⽤于<code>处理 Handler 产⽣的异常情况</code>。它的作⽤是根据异常设置 ModelAndView，之后交给渲染⽅法进⾏渲染，渲染⽅法会将 ModelAndView 渲染成⻚⾯。</p><p><strong>MultipartResolver</strong><br>MultipartResolver ⽤于上传请求，通过将普通的请求包装成 MultipartHttpServletRequest 来实 现。MultipartHttpServletRequest 可以通过 getFile() ⽅法 直接获得⽂件。如果上传多个⽂件，还 可以调⽤ getFileMap()⽅法得到Map&lt;FileName，File&gt;这样的结构，MultipartResolver 的作⽤就 是封装普通的请求，使其拥有⽂件上传的功能。</p><p><strong>FlashMapManager</strong><br>FlashMap ⽤于<strong>重定向</strong>时的参数传递，⽐如在处理⽤户订单时候，为了避免重复提交，可以处理完 post请求之后重定向到⼀个get请求，这个get请求可以⽤来显示订单详情之类的信息。这样做虽然 可以规避⽤户重新提交订单的问题，但是在这个⻚⾯上要显示订单的信息，这些数据从哪⾥来获得 呢？因为重定向时么有传递参数这⼀功能的，如果不想把参数写进URL（不推荐），那么就可以通 过FlashMap来传递。只需要在重定向之前将要传递的数据写⼊请求（可以通过 ServletRequestAttributes.getRequest()⽅法获得）的属性OUTPUT_FLASH_MAP_ATTRIBUTE 中，这样在重定向之后的Handler中Spring就会⾃动将其设置到Model中，在显示订单信息的⻚⾯ 上就可以直接从Model中获取数据。FlashMapManager 就是⽤来管理 FalshMap 的。<br>RequestToViewNameTranslator<br>RequestToViewNameTranslator 组件的作⽤是从请求中获取 ViewName.因为 ViewResolver 根据 ViewName 查找 View，但有的 Handler 处理完成之后,没有设置 View，也没有设置 ViewName， 便要通过这个组件从请求中查找 ViewName。</p><p>LocaleResolver<br>本地化、国际化。</p><p>ThemeResolver<br>ThemeResolver 组件是⽤来解析主题的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC请求数据</title>
      <link href="2020/11/20/springmvc/%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/"/>
      <url>2020/11/20/springmvc/%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="参数绑定：取出参数值绑定到handler⽅法的形参上"><a href="#参数绑定：取出参数值绑定到handler⽅法的形参上" class="headerlink" title="参数绑定：取出参数值绑定到handler⽅法的形参上"></a>参数绑定：取出参数值绑定到handler⽅法的形参上</h2><p>原⽣servlet接收⼀个整型参数：<br>1）String ageStr = request.getParameter(“age”);<br>2) Integer age = Integer.parseInt(ageStr);<br>3) SpringMVC框架对Servlet的封装，简化了servlet的很多操作<br>4) SpringMVC在接收整型参数的时候，直接在Handler⽅法中声明形参即可 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;xxx&quot;) public String handle(Integer age) &#123; System.out.println(age); &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>默认⽀持 Servlet API 作为⽅法参数 当需要使⽤HttpServletRequest、HttpServletResponse、HttpSession等原⽣servlet对象时，直接在handler⽅法中形参声明使⽤即可。</li><li>绑定简单数据类型参数，只需要直接声明形参即可（<code>形参参数名和传递的参数名要保持⼀ 致</code>，<strong>建议使⽤包装类型</strong>，因为简单数据类型为null时不能转换<br>当形参参数名和传递参数名不⼀致时可以使⽤@RequestParam注解进⾏ ⼿动映射）<br><code>@RequestParam</code>注解<br> 1）在处理方法入参处使用 @RequestParam 可以把请求参数传递给请求方法<br> 2）value：参数名<br> 3）required：是否必须。默认为 true, 表示请求参数中必须包含对应的参数，若不存在，将抛出异常<br> 4）defaultValue: 默认值，当没有传递参数时使用该值<br><code>@CookieValue</code> 注解<br>1）    使用 @CookieValue 绑定请求中的 Cookie 值<br>2）    @CookieValue 可让处理方法入参绑定某个 Cookie 值<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;testCookieValue&quot;)public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;) String sessionId) &#123;System.out.println(&quot;testCookieValue: sessionId: &quot; + sessionId);return &quot;success&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>使用POJO作为参数<br> 1）    使用 POJO 对象绑定请求参数值<br> 2）    Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。如：dept.deptId、dept.address.tel <pre><code> 接收pojo类型参数，直接形参声明即可，类型就是Pojo的类型，形参名无所谓</code></pre></li></ol><ul><li><strong>但是要求传递的参数名必须和Pojo的属性名保持一致</strong><!-- 测试 POJO 对象传参，支持级联属性 --><form action=" testPOJO" method="POST">username: <input type="text" name="username"/><br>password: <input type="password" name="password"/><br>email: <input type="text" name="email"/><br>age: <input type="text" name="age"/><br>city: <input type="text" name="address.city"/><br>province: <input type="text" name="address.province"/><input type="submit" value="Submit"/></form></li></ul><ol start="4"><li><code>绑定⽇期类型参数</code>（需要配置<code>⾃定义类型转换器</code>）<br>因为String不能直接转换为日期类型</li></ol><p>前端jsp</p><fieldset> <p>测试⽤例：SpringMVC接收⽇期类型参数</p><p><a href="/demo/handle06?birthday=2019-10-08">点击测试</a></p></fieldset><p>后台Handler⽅法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;handle06&quot;) public ModelAndView handle06(Date birthday)     &#123; Date date &#x3D; new Date();    ModelAndView modelAndView &#x3D; new ModelAndView();     modelAndView.addObject(&quot;date&quot;,date);     modelAndView.setViewName(&quot;success&quot;);     return modelAndView; &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义类型转换器，implements Converter&lt;String, Date&gt;字符串转date</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DateConverter implements Converter&lt;String, Date&gt; &#123;    @Override    public Date convert(String source) &#123;        &#x2F;&#x2F; 完成字符串向日期的转换        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        try &#123;            Date parse &#x3D; simpleDateFormat.parse(source);            return parse;        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>别忘了</p><!--注册自定义类型转换器--><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--        自动注册最合适的处理器映射器，处理器适配器(调用handler方法)    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span> <span class="token attr-name">conversion-service</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>conversionServiceBean<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>conversionServiceBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.format.support.FormattingConversionServiceFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>converters<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.lagou.edu.converter.DateConverter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC对Restful风格的支持</title>
      <link href="2020/11/20/springmvc/Restful/"/>
      <url>2020/11/20/springmvc/Restful/</url>
      
        <content type="html"><![CDATA[<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>rest是⼀个url请求的⻛格，基于这种⻛格设计请求的url </p><ol><li><p>没有rest的话，原有的url设计 <a href="http://localhost:8080/user/queryUserById.action?id=3">http://localhost:8080/user/queryUserById.action?id=3</a> url中定义了动作（操作），参数具体锁定到操作的是谁</p></li><li><p>有了rest⻛格之后 rest中，认为互联⽹中的所有东⻄都是资源，<br>既然是资源就会有⼀个唯⼀的uri标识它，<br>代表它 <a href="http://localhost:8080/user/3">http://localhost:8080/user/3</a> 代表的是id为3的那个⽤户记录（资源）<br>锁定资源之后如何操作它呢？<br>常规操作就是增删改查<br>根据请求⽅式不同，代表要做不同的操作<br>get 查询，获取资源 post 增加，新建资源 put 更新 delete 删除资源<br>rest⻛格带来的直观体现：<strong>就是传递参数⽅式的变化，参数可以在uri中了</strong><br>/account/1 HTTP GET ：得到 id = 1 的 account<br>/account/1 HTTP DELETE：删除 id = 1 的 account<br>/account/1 HTTP PUT：更新 id = 1 的 account<br>URL：资源定位符，通过URL地址去定位互联⽹中的资源（抽象的概念，⽐如图⽚、视频、app服务 等）。<br>RESTful ⻛格 URL：互联⽹所有的事物都是资源，<strong>要求URL中只有表示资源的名称，没有动词</strong>。<br>RESTful⻛格资源操作：<br>使⽤HTTP请求中的method⽅法put、delete、post、get来操作资源。分别对 应添加、删除、修改、查询。不过⼀般使⽤时还是 post 和 get。put 和 delete⼏乎不使⽤。</p></li></ol><hr><h2 id="Spring-MVC-⽀持-RESTful-⻛格请求"><a href="#Spring-MVC-⽀持-RESTful-⻛格请求" class="headerlink" title="Spring MVC ⽀持 RESTful ⻛格请求"></a>Spring MVC ⽀持 RESTful ⻛格请求</h2><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p><code>@PathVariable </code>注解获取 RESTful ⻛格的请求 <code>URL中的路径变量</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*     * restful  get   &#x2F;demo&#x2F;handle&#x2F;15     *&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;handle&#x2F;&#123;id&#125;&quot;,method &#x3D; &#123;RequestMethod.GET&#125;)    public ModelAndView handleGet(@PathVariable(&quot;id&quot;) Integer id) &#123;        ModelAndView modelAndView &#x3D; new ModelAndView();        modelAndView.setViewName(&quot;success&quot;);        return modelAndView;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a>HiddenHttpMethodFilter</h3><p><code>HiddenHttpMethodFilter</code>浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支持，<br>Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与 DELETE 请求。</p><p>如何发送PUT请求或DELETE请求?</p><ul><li>①.配置HiddenHttpMethodFilter</li><li>②.需要发送POST请求</li><li>③.需要在发送POST请求时携带一个 name=”_method”的隐含域，值为PUT或DELETE</li></ul><!--配置springmvc请求方式转换过滤器，会检查请求参数中是否有_method参数，如果有就按照指定的请求方式进行转换--><p>`<br>  <filter><br>    <filter-name>hiddenHttpMethodFilter</filter-name><br>    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class><br>  </filter></p>  <filter-mapping>    <filter-name>encoding</filter-name>    <url-pattern>/*</url-pattern>  </filter-mapping>  <filter-mapping>    <filter-name>hiddenHttpMethodFilter</filter-name>    <url-pattern>/*</url-pattern>  </filter-mapping>  `<p>`<br>  <!-- 实验1 测试 REST风格 GET 请求 --><br><a href="springmvc/testRESTGet/1">testREST GET</a><br/><br/></p><!-- 实验2 测试 REST风格 POST 请求 --><form action="springmvc/testRESTPost" method="POST"><input type="submit" value="testRESTPost"></form><!-- 实验3 测试 REST风格 PUT 请求 --><form action="springmvc/testRESTPut/1" method="POST"><input type="hidden" name="_method" value="PUT"><input type="submit" value="testRESTPut"></form><!-- 实验4 测试 REST风格 DELETE 请求 --><form action="springmvc/testRESTDelete/1" method="POST"><input type="hidden" name="_method" value="DELETE"><input type="submit" value="testRESTDelete"></form>`---<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(value&#x3D;&quot;&#x2F;testRESTGet&#x2F;&#123;id&#125;&quot;,method&#x3D;RequestMethod.GET)public String testRESTGet(@PathVariable(value&#x3D;&quot;id&quot;) Integer id)&#123;System.out.println(&quot;testRESTGet id&#x3D;&quot;+id);return &quot;success&quot;;&#125; @RequestMapping(value&#x3D;&quot;&#x2F;testRESTPost&quot;,method&#x3D;RequestMethod.POST)public String testRESTPost()&#123;System.out.println(&quot;testRESTPost&quot;);return &quot;success&quot;;&#125; @RequestMapping(value&#x3D;&quot;&#x2F;testRESTPut&#x2F;&#123;id&#125;&quot;,method&#x3D;RequestMethod.PUT)public String testRESTPut(@PathVariable(&quot;id&quot;) Integer id)&#123;System.out.println(&quot;testRESTPut id&#x3D;&quot;+id);return &quot;success&quot;;&#125; @RequestMapping(value&#x3D;&quot;&#x2F;testRESTDelete&#x2F;&#123;id&#125;&quot;,method&#x3D;RequestMethod.DELETE)public String testRESTDelete(@PathVariable(&quot;id&quot;) Integer id)&#123;System.out.println(&quot;testRESTDelete id&#x3D;&quot;+id);return &quot;success&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC响应数据</title>
      <link href="2020/11/20/springmvc/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/"/>
      <url>2020/11/20/springmvc/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="几种途径输出模型数据"><a href="#几种途径输出模型数据" class="headerlink" title="几种途径输出模型数据"></a>几种途径输出模型数据</h2><p>1）    <strong>ModelAndView</strong>: 处理方法返回值类型为 ModelAndView 时, 方法体即可通过该对象添加模型数据<br>2）    <strong>Map 或 Model</strong>: 入参为 org.springframework.ui.Model、<br>org.springframework.ui.ModelMap 或 java.uti.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中。</p><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><pre><code>控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息</code></pre><p>1）    两个重要的成员变量:</p><pre><code><pre class="line-numbers language-java" data-language="java"><code class="language-java">private Object view;视图信息private ModelMap model; 模型数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></code></pre><p>2）添加模型数据:<br>MoelAndView addObject(String attributeName, Object attributeValue)   设置模型数据<br>ModelAndView addAllObject(Map&lt;String, ?&gt; modelMap)<br>3）设置视图:<br>void setView(View view)                设置视图对象<br>void setViewName(String viewName)     设置视图名字<br>4）获取模型数据<br>      protected Map&lt;String, Object&gt; getModelInternal()   获取模型数据<br>      public ModelMap getModelMap()<br>      public Map&lt;String, Object&gt; getModel()<br>5.3.1    Map介绍</p><p><strong>SpringMVC在handler方法上传入Map、Model和ModelMap参数，并向这些参数中保存数据（放入到<code>请求域</code>），都可以在<code>页面获取到</code></strong></p><ul><li>它们之间是什么关系？</li><li>运行时的具体类型都是 <code>BindingAwareModelMap</code>，相当于给BindingAwareModelMap中<strong>保存的数据都会放在请求域中</strong></li><li></li><li> Map(jdk中的接口)        Model（spring的接口）</li><li></li><li> ModelMap(class,实现Map接口)</li><li>BindingAwareModelMap继承了ExtendedModelMap，ExtendedModelMap继承了ModelMap,实现了Model接口</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**     * url: http:&#x2F;&#x2F;localhost:8080&#x2F;demo&#x2F;handle01     *&#x2F;    @RequestMapping(&quot;&#x2F;handle01&quot;)    public ModelAndView handle01(@ModelAttribute(&quot;name&quot;) String name) &#123;        int c &#x3D; 1&#x2F;0;        Date date &#x3D; new Date();&#x2F;&#x2F; 服务器时间        &#x2F;&#x2F; 返回服务器时间到前端页面        &#x2F;&#x2F; 封装了数据和页面信息的 ModelAndView        ModelAndView modelAndView &#x3D; new ModelAndView();        &#x2F;&#x2F; addObject 其实是向请求域中request.setAttribute(&quot;date&quot;,date);        modelAndView.addObject(&quot;date&quot;,date);        &#x2F;&#x2F; 视图信息(封装跳转的页面信息) 逻辑视图名        modelAndView.setViewName(&quot;success&quot;);        return modelAndView;    &#125;       &#x2F;**     * 直接声明形参ModelMap，封装数据     * url: http:&#x2F;&#x2F;localhost:8080&#x2F;demo&#x2F;handle11     *     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;modelmap:class org.springframework.validation.support.BindingAwareModelMap     *&#x2F;    @RequestMapping(&quot;&#x2F;handle11&quot;)    public String handle11(ModelMap modelMap) &#123;        Date date &#x3D; new Date();&#x2F;&#x2F; 服务器时间        modelMap.addAttribute(&quot;date&quot;,date);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;modelmap:&quot; + modelMap.getClass());        return &quot;success&quot;;    &#125;    &#x2F;**     * 直接声明形参Model，封装数据     * url: http:&#x2F;&#x2F;localhost:8080&#x2F;demo&#x2F;handle12     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;model:class org.springframework.validation.support.BindingAwareModelMap     *&#x2F;    @RequestMapping(&quot;&#x2F;handle12&quot;)    public String handle12(Model model) &#123;        Date date &#x3D; new Date();        model.addAttribute(&quot;date&quot;,date);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;model:&quot; + model.getClass());        return &quot;success&quot;;    &#125;    &#x2F;**     * 直接声明形参Map集合，封装数据     * url: http:&#x2F;&#x2F;localhost:8080&#x2F;demo&#x2F;handle13     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;map:class org.springframework.validation.support.BindingAwareModelMap     *&#x2F;    @RequestMapping(&quot;&#x2F;handle13&quot;)    public String handle13(Map&lt;String,Object&gt; map) &#123;        Date date &#x3D; new Date();        map.put(&quot;date&quot;,date);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;map:&quot; + map.getClass());        return &quot;success&quot;;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json交互</title>
      <link href="2020/11/20/springmvc/json%E4%BA%A4%E4%BA%92/"/>
      <url>2020/11/20/springmvc/json%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯</title>
      <link href="2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<ol><li> 爬楼梯<br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</li></ol><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li> 1 阶 + 1 阶</li><li> 2 阶<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li> 1 阶 + 1 阶 + 1 阶</li><li> 1 阶 + 2 阶</li><li> 2 阶 + 1 阶</li></ol>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零</title>
      <link href="2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ol start="11"><li>盛最多水的容器<br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</li></ol><p>说明：你不能倾斜容器。<br><img src="2020-12-11-22-24-00.png"><br>示例 1：</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><hr><h2 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h2><p>给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。<br><strong>你应当保留两个分区中每个节点的初始相对位置。</strong><br>输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;        ListNode l1 &#x3D; new ListNode(-1);        ListNode l2 &#x3D; new ListNode(-1);        ListNode cur &#x3D; head;        ListNode small &#x3D; l1;        ListNode large &#x3D; l2;        while(cur!&#x3D;null)&#123;            if(cur.val&lt;x)&#123;                small.next &#x3D;cur;                small &#x3D; small.next;            &#125;else&#123;                large.next &#x3D; cur;                large &#x3D; large.next;            &#125;            cur &#x3D; cur.next;        &#125;        large.next &#x3D; null;        small.next &#x3D; l2.next;        return l1.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零</title>
      <link href="2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<ol start="283"><li>移动零<br>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</li></ol><p>示例:</p><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>使用count指针指向该数组的头部。<br>遍历数组：i指针不断向右移动，每次i指针指向非零数，则将左右指针对应的数交换，同时左指针右移。<br>注意到以下性质：<br>count指针左边均为非零数；<br>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务传播特性详解</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="事务传播特性—-详解："><a href="#事务传播特性—-详解：" class="headerlink" title="事务传播特性—-详解："></a>事务传播特性—-详解：</h1><p><code>required</code>：使用当前的事务，如果当前没有事务，则创建一个事务，子方法是必须运行在一个事务中的，如果当前存在事务，则加入这个事务，成为一个整体。<br><code>supports</code>:如果当前有事务，则使用事务，如果当前没有事务，则不使用事务<br><code>mandatory</code>：该传播属性强制必须存在一个事务，如果不存在，则抛出异常<br><code>required_new</code>:如果当前有事务，则挂起该事务，并且自己创建一个新的事务给自己使用；如果当前没有事务，则同required<br><code>not_support</code>:如果当前有事务，则把事务挂起，自己不使用事务去进行数据库操作<br><code>never</code>:如果当前事务存在，则抛出异常<br><code>nested</code>：  如果当前有事务，则开启子事务（嵌套事务），嵌套事务是独立提交或者回滚；如果当前没有事务，则同required<br>但是如果父事务提交，则会携带子事务一起提交。如果父事务回滚，则子事务会一起回滚。相反，子事务异常，则父事务可以不会滚（捕获子事务的异常），也可以回滚。<br>有异常才会回滚事务，如果异常被捕获，也就是try，catch，就不会回滚事务了，<br>发生异常，或者抛出异常都会回滚事务</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>导入test依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;    &lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写test类 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RunWith(SpringRunner.class)@SpringBootTest(classes &#x3D; Application.class)public class TransTest &#123;    @Autowired    private TestTransService testTransService;    &#x2F;*    * 事务传播特性    *   required：    *   supports：    *   mandatory：    *   required_new:    *   not_supported:    *   never:    *   nested:    * *&#x2F;    @Test    public void demo()&#123;        testTransService.saveParent();        testTransService.saveChildren();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写需要的测试方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service    public class TestTransService &#123;        @Autowired        private StuMapper stuMapper;        public void saveParent()&#123;            Stu stu&#x3D;new Stu();            stu.setName(&quot;parent&quot;);            stu.setAge(55);            stuMapper.insert(stu);        &#125;        public void saveChildren()&#123;            saveChild1();            int a&#x3D;1&#x2F;0;            saveChild2();        &#125;        public void saveChild1()&#123;            Stu stu1&#x3D;new Stu();            stu1.setName(&quot;child-1&quot;);            stu1.setAge(11);            stuMapper.insert(stu1);        &#125;        public void saveChild2()&#123;            Stu stu2&#x3D;new Stu();            stu2.setName(&quot;child-2&quot;);            stu2.setAge(22);            stuMapper.insert(stu2);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title=" REQUIRED"></a><font color = gold> REQUIRED</font></h2><font color=orange>required：使用当前的事务，如果当前没有事务，则创建一个事务，子方法是必须运行在一个事务中的，如果当前存在事务，则加入这个事务，成为一个整体。</font><p>(1)<code>demo方法没有开启事务</code>，直接测试<br>报错：java.lang.ArithmeticException: / by zero<br>parent，child1入库<br><strong>结论：在报错之前，已经执行的代码会进行数据库操作，之后代码没有执行，也就没有操作数据库</strong></p><hr><p>(2)<code>在demo()方法上开启事务propagation = Propagation.REQUIRED，进行测试</code><br>    /*<br>    * 事务传播特性<br>    *   required：<br>    *   supports：<br>    *   mandatory：<br>    *   required_new:<br>    *   not_supported:<br>    *   never:<br>    *   nested:<br>    * */</p><pre><code>`@Transactional(propagation = Propagation.REQUIRED)`<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void demo()&#123;    testTransService.saveParent();    testTransService.saveChildren();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></code></pre><p>报错：<code>java.lang.ArithmeticException: / by zero</code></p><p><strong>结论</strong>：<br>demo()方法开启REQUIRED事务，事务具有传播特性，方体体里面的方法也具有事务，所以报错后数据库进行了回滚操作</p><p>如果demo方法没有开启事务，在saveChildren()上开启了事务（  @Transactional(propagation = Propagation.REQUIRED)），则会保存saveParent()方法插入的数据。</p><hr><h2 id="supports"><a href="#supports" class="headerlink" title="supports "></a><font color = gold>supports </font></h2><p><font color = orange>supports:如果当前有事务，则使用事务，如果当前没有事务，则不使用事务</font></p><ol><li>demo方法上没有加事务，但是 saveChildren加SUPPORTS事务<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#96;@Transactional(propagation &#x3D; Propagation.SUPPORTS)&#96;public void saveChildren()&#123;            saveChild1();            int a&#x3D;1&#x2F;0;            saveChild2();        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>结论</strong>： 数据库新增parent,child-1数据<br>是因为外层demo没有事务，saveChildren也就跟着外层函数来，不增加事务。<br>2. demo方法上加Required事务，但是 saveChildren加SUPPORTS事务</p><p><strong>结论</strong>: 没有数据入库，事务就进行了回滚操作</p><hr><h2 id="mandatory"><a href="#mandatory" class="headerlink" title="mandatory"></a><font color = gold>mandatory</font></h2><p><font color = orange>该传播属性强制必须存在一个事务，如果不存在，则抛出异常</font></p><ol><li>把调用方demo的Required事务给注释掉，在被调用方saveChildren使用事务mandatory<br>会抛出没有事务的异常</li><li>demo方法上加Required事务，saveChildren加mandatory事务</li></ol><hr><h2 id="required-new"><a href="#required-new" class="headerlink" title="required_new"></a><font color = gold>required_new</font></h2><p><font color = orange>required_new:如果当前有事务，则挂起该事务，并且自己创建一个新的事务给自己使用；如果当前没有事务，则同required</font></p><ol><li>把调用方demo的Required事务给注释掉，在被调用方saveChildren使用事务required_new<br>会有一条parent记录，saveChildren自己本身有事务，进行了回滚</li><li><strong>demo方法上加Required事务，saveChildren加required_new事务<br>此时有两个事务，<br>数据库此时并没有任何数据<br>这是因为saveChildren回滚，本身有/0异常，会影响到demo方法，也会回滚</strong><br> 由于抛出空指针异常，所以saveChildren()这个新事物会回滚，而抛出的异常会传递给父方法，父方法的事务也会回滚，所有没有一条记录</li><li>demo方法上加Required事务，saveChildren加required_new事务<br> 把saveChildren的/0注释掉，放到demo方法中的时候，<br> 数据库有child1 ,chird2<br> 结论：可以证明required_new创建的时新事务</li></ol><hr><h2 id="not-support"><a href="#not-support" class="headerlink" title="not_support"></a><font color = gold>not_support</font></h2><p><font color = orange>如果当前有事务，则把事务挂起，自己不使用事务去进行数据库操作</font></p><ol><li>把调用方demo的Required事务给注释掉，在被调用方saveChildren（有异常）使用事务not_support<br>parent，child1入库,没有回滚</li><li>调用方demo使用Required事务，在被调用方saveChildren（有异常）使用事务not_support<br>child1入库</li></ol><hr><h2 id="never"><a href="#never" class="headerlink" title="never"></a><font color = gold>never</font></h2><p><font color = orange>如果当前事务存在，则抛出异常</font><br>1.调用方demo使用Required事务，在被调用方saveChildren（有异常）使用事务never<br>    会抛出另一个异常非法事务状态<br>2.调用方demo不使用Required事务，在被调用方saveChildren（有异常）使用事务never<br>    会抛出异常 /0  parent，child1入库</p><hr><h2 id="nested"><a href="#nested" class="headerlink" title="nested"></a><font color = gold>nested</font></h2><p><font color = orange>如果当前有事务，则开启子事务（嵌套事务），嵌套事务是独立提交或者回滚；如果当前没有事务，则同required</font></p><p>1.调用方demo使用Required事务（有异常），在被调用方saveChildren（没有异常）使用事务nested<br>    数据库没有数据<br>    如果在外层方法发生异常，被调用方法也会回滚<br>    <strong>父事务回滚，则子事务会一起回滚</strong></p><pre><code>**区别与required_new**  主方法发生异常，子方法不会收到影响 新开启一个新的事务  看前面</code></pre><p>2.调用方demo使用Required事务（没有异常），在被调用方saveChildren（有异常）使用事务nested<br>    会抛出异常 /0  没有数据库入库</p><pre><code>在外层方法demo追加try catch，主方法其他操作不会受到子事务的影响<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(propagation &#x3D; Propagation.REQUIRED)public void demo()&#123;    testTransService.saveParent();    try &#123;        &#x2F;&#x2F;相当于数据库中的savepoint 捕获异常之后，不影响其他事务操作        testTransService.saveChildren();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre><font color = orange>但是如果父事务提交，则会携带子事务一起提交。如果父事务回滚，则子事务会一起回滚。相反，子事务异常，则父事务可以不回滚（捕获子事务的异常），也可以回滚。有异常才会回滚事务，如果异常被捕获，也就是try，catch，就不会回滚事务了，发生异常，或者抛出异常都会回滚事务</font>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--日志监控功能</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86x%E9%A1%B9%E7%9B%AE--%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86x%E9%A1%B9%E7%9B%AE--%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="通过日志监控service执行时间"><a href="#通过日志监控service执行时间" class="headerlink" title="通过日志监控service执行时间"></a>通过日志监控service执行时间</h2><p>使用到切面，引入依赖<br><code>        &lt;!--引入aop依赖--&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;         &lt;/dependency        </code></p><p>使用<code>环绕通知</code>，编写切面类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.imooc.aspect; import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;&#x2F;** 记录每个service所需要的时间* *&#x2F;@Aspect@Componentpublic class ServiceLogAspect &#123;    private static final Logger log&#x3D; LoggerFactory.getLogger(ServiceLogAspect.class);     &#x2F;**     * 切面表达式：     * execution 执行的位置     * 第一处：* 代表所有的返回类型     * 第二处：包名 代表aop监控的类所在的包     * 第三处：.. 代表该包及其子包     * 第四处：* 所有的类     * 第五处：*（..) * 代表所有的方法名，(..)代表方法中的任何参数     * @param joinPoint     * @return     *&#x2F;    @Around(&quot;execution(* com.imooc.service.impl..*.*(..))&quot;)    public Object recordTimeLog(ProceedingJoinPoint joinPoint) throws Throwable &#123;        &#x2F;&#x2F;&#123;&#125; 代表占位符 &#123;&#125;.&#123;&#125; 类名.方法名        log.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 开始执行 &#123;&#125;.&#123;&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;,joinPoint.getTarget().getClass(),                joinPoint.getSignature().getName());        &#x2F;&#x2F;开始记录时间        long start&#x3D;System.currentTimeMillis();        &#x2F;&#x2F;执行方法        Object result &#x3D; joinPoint.proceed();        &#x2F;&#x2F;结束记录时间        long end&#x3D;System.currentTimeMillis();        long takeTime&#x3D;end-start;        if(takeTime&gt;3000)&#123;            log.error(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行结束，耗时：&#123;&#125;毫秒 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;,takeTime);        &#125;else if(takeTime&gt;2000)&#123;            log.warn(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行结束，耗时：&#123;&#125;毫秒 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;,takeTime);        &#125;else&#123;            log.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行结束，耗时：&#123;&#125;毫秒 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;,takeTime);        &#125;        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--整合swagger2</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE--%E6%95%B4%E5%90%88Swagger2/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE--%E6%95%B4%E5%90%88Swagger2/</url>
      
        <content type="html"><![CDATA[<p>postMan 后端人员自测<br>和前端人员交互的时候就需要编写接口文档了</p><p>API  swagger2  开源的插件，减少编写更多的文档，只需要通过一些简单的代码，和前端人员对接<br>                并且使用文档也能完成自测功能</p><p>引入依赖：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;!--swagger2 配置 下面两个是官方的 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.4.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.4.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--这个是第三方的ui--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;swagger-bootstrap-ui&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.6&lt;&#x2F;version&gt;&lt;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*向springboot表明是配置类*&#x2F;@Configuration@EnableSwagger2&#x2F;*开启swagger2配置*&#x2F;public class Swagger2 &#123;    &#x2F;&#x2F; http:&#x2F;&#x2F;localhost:8088&#x2F;swagger-ui.html 原路径    &#x2F;&#x2F; http:&#x2F;&#x2F;localhost:8088&#x2F;doc.html 界面美观路径    &#x2F;&#x2F; 配置swagger2核心配置 docket    @Bean    public Docket createRestApi()&#123;        return new Docket(DocumentationType.SWAGGER_2) &#x2F;&#x2F;指定api类型为Swagger2                .apiInfo(apiInfo())                    &#x2F;&#x2F;用于定义api文档汇总                .select().apis(RequestHandlerSelectors                        .basePackage(&quot;com.imooc.controller&quot;)) &#x2F;&#x2F;指定controller包                        .paths(PathSelectors.any())             &#x2F;&#x2F;选定所有controller包                        .build();    &#125;    private ApiInfo apiInfo()&#123;        return new ApiInfoBuilder()                .title(&quot;天天吃货 电商平台接口api&quot;)            &#x2F;&#x2F;文档页标题                .contact(new Contact(&quot;小丸子&quot;,                        &quot;https:&#x2F;&#x2F;tomorrow813.github.io&quot;,                        &quot;245482791@qq.com&quot;))           &#x2F;&#x2F;联系人信息                .description(&quot;专为天天吃货提供的api文档&quot;)      &#x2F;&#x2F;详细信息                .version(&quot;1.0.1&quot;)                           &#x2F;&#x2F;文档版本号码                .termsOfServiceUrl(&quot;https:&#x2F;&#x2F;www.imooc.com&quot;) &#x2F;&#x2F;网站地址                .build();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>swagger2优化</p><p>controller：</p><p>@ApiIgnore注释在controller上：表明该controller不显示在文档中/<em>用于注释该controller</em>/<br>@Api(value = “注册登录”,tags = {“用于注册登录的相关接口”})/<em>用于注释该controller</em>/<br>@ApiOperation(value = “用户名是否存在”,notes = “用户名是否存在”,httpMethod = “GET”)//用于注释该方法<br>model：</p><p>注释在实体类名上：@ApiModel(value = “用户名BO”,description = “从客户端，有用户传入的数据封装在此entity中”)<br>注释在实体属性上：@ApiModelProperty(value =”用户名”,name = “username”,example = “imooc”,required = true)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--自定义响应数据结构</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE--%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE--%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Restful webservice返回的强规范: HttpStatus.OK<br>我们也可以自定义响应的数据结构传递回前端：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @Description: 自定义响应数据结构 * 前端接受此类数据（json object)后，可自行根据业务去实现相关功能 *  * 200：表示成功 * 500：表示错误，错误信息在msg字段中 * 501：bean验证错误，不管多少个错误都以map形式返回 * 502：拦截器拦截到用户token出错 * 555：异常抛出信息 * 556: 用户qq校验异常 *&#x2F;public class JSONResult &#123;    &#x2F;&#x2F; 定义jackson对象    private static final ObjectMapper MAPPER &#x3D; new ObjectMapper();    &#x2F;&#x2F; 响应业务状态    private Integer status;    &#x2F;&#x2F; 响应消息    private String msg;    &#x2F;&#x2F; 响应中的数据    private Object data;        @JsonIgnore    private String ok;&#x2F;&#x2F; 不使用    public static JSONResult build(Integer status, String msg, Object data) &#123;        return new JSONResult(status, msg, data);    &#125;    public static JSONResult build(Integer status, String msg, Object data, String ok) &#123;        return new JSONResult(status, msg, data, ok);    &#125;        public static JSONResult ok(Object data) &#123;        return new JSONResult(data);    &#125;    public static JSONResult ok() &#123;        return new JSONResult(null);    &#125;        public static JSONResult errorMsg(String msg) &#123;        return new JSONResult(500, msg, null);    &#125;        public static JSONResult errorMap(Object data) &#123;        return new JSONResult(501, &quot;error&quot;, data);    &#125;        public static JSONResult errorTokenMsg(String msg) &#123;        return new JSONResult(502, msg, null);    &#125;        public static JSONResult errorException(String msg) &#123;        return new JSONResult(555, msg, null);    &#125;        public static JSONResult errorUserQQ(String msg) &#123;        return new JSONResult(556, msg, null);    &#125;    public JSONResult() &#123;    &#125;    public JSONResult(Integer status, String msg, Object data) &#123;        this.status &#x3D; status;        this.msg &#x3D; msg;        this.data &#x3D; data;    &#125;        public JSONResult(Integer status, String msg, Object data, String ok) &#123;        this.status &#x3D; status;        this.msg &#x3D; msg;        this.data &#x3D; data;        this.ok &#x3D; ok;    &#125;    public JSONResult(Object data) &#123;        this.status &#x3D; 200;        this.msg &#x3D; &quot;OK&quot;;        this.data &#x3D; data;    &#125;    public Boolean isOK() &#123;        return this.status &#x3D;&#x3D; 200;    &#125;    public Integer getStatus() &#123;        return status;    &#125;    public void setStatus(Integer status) &#123;        this.status &#x3D; status;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg &#x3D; msg;    &#125;    public Object getData() &#123;        return data;    &#125;    public void setData(Object data) &#123;        this.data &#x3D; data;    &#125;public String getOk() &#123;return ok;&#125;public void setOk(String ok) &#123;this.ok &#x3D; ok;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--核心功能</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h2><h3 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h3><pre><code>用户 -----访问网站进行注册---输入用户名密码----校验（主要针对用户名不要和数据库的用户名字一样，密码的校验两次输入一致）--那么后端收到这三个参数如何处理呢？第一步肯定是判断：三个参数是否存在空值的情况，虽然有前端的判断，但是不排除有人会绕过前端来注册，所以后端的判断一个都不能少。然后判断用户名是否已存在，我们不希望系统里存在两个张三。还要判断密码长度是否小于6，我们不希望咱们网站的用户密码太过脆弱。最后判断两次密码是否一致。校验失败重新输入，成功注册成功了</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>  用户名以及密码表单提交的以后  会把这三个参数包装到jsonobject传入后段  偏向于业务类型的jsonobject<br>  UserBO去接收前端传入的对象  成员属性包括用户名字， 密码 ， 确认密码<br>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping(&quot;&#x2F;regist&quot;) public JSONResult regist(@RequestBody UserBO userBO,                          HttpServletRequest request,                          HttpServletResponse reponse) &#123;     String username &#x3D; userBO.getUsername();     String password &#x3D; userBO.getPassword();     String confirmPassword &#x3D; userBO.getConfirmPassword();     &#x2F;&#x2F;1. 判断用户名和密码必须不为空     if (StringUtils.isBlank(username) ||             StringUtils.isBlank(password)) &#123;         return JSONResult.errorMsg(&quot;用户名或密码不能为空&quot;);     &#125;     &#x2F;&#x2F;查询用户名是否存在     boolean isExist &#x3D; userService.queryUsernameIsExist(username);     if(isExist)&#123;         return JSONResult.errorMsg(&quot;用户名已经存在&quot;);     &#125;     &#x2F;&#x2F;密码长度不能少于6位     if(password.length()&lt;6)&#123;         return JSONResult.errorMsg(&quot;密码长度不能少于6&quot;);     &#125;     &#x2F;&#x2F;判断两次密码是否一致     if(!password.equals(confirmPassword))&#123;         return JSONResult.errorMsg(&quot;两次密码输入不一致&quot;);     &#125;     &#x2F;&#x2F;实现注册     Users userResult &#x3D; userService.createUser(userBO);     userResult &#x3D; setNUllProperty(userResult);     CookieUtils.setCookie(request,reponse,&quot;user&quot;, JsonUtils.objectToJson(userResult),true);     return JSONResult.ok(); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  具体的还是看代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(propagation &#x3D; Propagation.SUPPORTS)    @Override    public boolean queryUsernameIsExist(String username) &#123;        Example userExample &#x3D; new Example(Users.class);&#x2F;&#x2F;查询哪一个对应的实体类        Example.Criteria userExampleCriteria &#x3D; userExample.createCriteria();        userExampleCriteria.andEqualTo(&quot;username&quot;, username);&#x2F;&#x2F;构建条件        Users user &#x3D; usersMapper.selectOneByExample(userExample);        return user &#x3D;&#x3D; null ? false : true;    &#125;    &#x2F;*        创建用户     *&#x2F;    @Transactional(propagation &#x3D; Propagation.REQUIRED)    @Override    public Users createUser(UserBO userBO) &#123;        &#x2F;&#x2F;保证主键全局唯一，这个之后继续学习，id生成器        String userId &#x3D; sid.nextShort();        Users user &#x3D; new Users();        user.setId(userId);        user.setUsername(userBO.getUsername());        try &#123;            user.setPassword(MD5Utils.getMD5Str(userBO.getPassword()));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F;设置默认值        user.setNickname(userBO.getUsername());        user.setFace(USER_FACE);        user.setBirthday(DateUtil.stringToDate(&quot;1970-01-01&quot;));        user.setSex(Sex.secret.type);        user.setCreatedTime(new Date());        user.setUpdatedTime(new Date());        usersMapper.insert(user);        return user;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiOperation(value &#x3D; &quot;用户名登录&quot; , notes &#x3D; &quot;用户名登录&quot;, httpMethod &#x3D; &quot;POST&quot;)    @PostMapping(&quot;&#x2F;login&quot;)    public JSONResult login(@RequestBody UserBO userBO,                                      HttpServletRequest request,                                      HttpServletResponse reponse) throws Exception &#123;        String username &#x3D; userBO.getUsername();        String password &#x3D; userBO.getPassword();        String confirmPassword &#x3D; userBO.getConfirmPassword();        &#x2F;&#x2F;0. 判断用户名和密码必须不为空        if (StringUtils.isBlank(username) ||                StringUtils.isBlank(password)) &#123;            return JSONResult.errorMsg(&quot;用户名或密码不能为空&quot;);        &#125;        &#x2F;&#x2F;1. 实现登录        Users userResult &#x3D; userService.queryUserForLogin(username,                MD5Utils.getMD5Str(password));        if (userResult&#x3D;&#x3D;null)&#123;            return JSONResult.errorMsg(&quot;用户名或密码不正确&quot;);        &#125;        userResult &#x3D; setNUllProperty(userResult);        CookieUtils.setCookie(request,reponse,&quot;user&quot;, JsonUtils.objectToJson(userResult),true);        return JSONResult.ok(userResult);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(propagation &#x3D; Propagation.SUPPORTS)    @Override    public Users queryUserForLogin(String username, String password) &#123;        Example userExample &#x3D; new Example(Users.class);&#x2F;&#x2F;查询哪一个对应的实体类        Example.Criteria userExampleCriteria &#x3D; userExample.createCriteria();        userExampleCriteria.andEqualTo(&quot;username&quot;, username);&#x2F;&#x2F;构建条件        userExampleCriteria.andEqualTo(&quot;password&quot;,password);        Users user &#x3D; usersMapper.selectOneByExample(userExample);        return user ;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h2><h2 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h2><p>cookie:</p><p>以键值对的形式存储在浏览器<br>cookie不能跨域，当前及其父级域名可以取值（比如mercury.jd.como可以取值到jd.com域名）<br>cookie可以设置有效期<br>cookie可以设置path（<a href="http://www.jd.com/users">www.jd.com/users</a> 设置了此域名，其他该域名下的路径就不可以使用此cookie）<br>session</p><p>基于服务器内存的缓存（非持久化），可保存请求会话  非持久化指的是服务器宕机或者重启之后，所有的会话请求都会丢失<br>每个session通过sessionid来区分不同请求<br>session可以设置过期时间<br>session也是以键值对形式存在的<br>用户第一次请求，在服务器端，只要创建了一个session，就可以在cookie里面保存一个jessionid，可以在servlet中设置，下一次请求，request header会携带此cookie.</p><p>其他文章具体总结</p><h2 id="集成Swagger2-api"><a href="#集成Swagger2-api" class="headerlink" title="集成Swagger2 api"></a>集成Swagger2 api</h2><h2 id="日志监控功能"><a href="#日志监控功能" class="headerlink" title="日志监控功能"></a>日志监控功能</h2><h2 id="自定义相应数据结构"><a href="#自定义相应数据结构" class="headerlink" title="自定义相应数据结构"></a>自定义相应数据结构</h2><h2 id="分类的设计与实现-：商品的类别"><a href="#分类的设计与实现-：商品的类别" class="headerlink" title="分类的设计与实现 ：商品的类别"></a>分类的设计与实现 ：商品的类别</h2><h2 id="首页商品推荐"><a href="#首页商品推荐" class="headerlink" title="首页商品推荐"></a>首页商品推荐</h2><h2 id="商品的搜索与分页"><a href="#商品的搜索与分页" class="headerlink" title="商品的搜索与分页"></a>商品的搜索与分页</h2><h2 id="商品的详情与评论渲染"><a href="#商品的详情与评论渲染" class="headerlink" title="商品的详情与评论渲染"></a>商品的详情与评论渲染</h2><h2 id="购物车与订单-订单的幂等性-锁的机制控制库存"><a href="#购物车与订单-订单的幂等性-锁的机制控制库存" class="headerlink" title="购物车与订单 订单的幂等性 锁的机制控制库存"></a>购物车与订单 订单的幂等性 锁的机制控制库存</h2><h2 id="微信与支付宝支付"><a href="#微信与支付宝支付" class="headerlink" title="微信与支付宝支付"></a>微信与支付宝支付</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体项目--准备工作</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%95%86%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91--%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%95%86%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91--%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="电商项目：单体架构设计于项目开发"><a href="#电商项目：单体架构设计于项目开发" class="headerlink" title="电商项目：单体架构设计于项目开发"></a>电商项目：单体架构设计于项目开发</h1><h1 id="基于SpringBoot2-x"><a href="#基于SpringBoot2-x" class="headerlink" title="基于SpringBoot2.x"></a>基于SpringBoot2.x</h1><p>实现单体电商项目核心功能开发</p><p>实现单体电商项目个人中心功能</p><p>项目部署上线</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>项目展示以及主要的功能：轮播图<br>                    主页不同分类<br>                    根据页面的滚动慢慢的进行加载：在前端设计的调用模式<br>                    首页搜索功能：输入关键词 页面跳转<br>                    分页功能<br>                    默认排序 销量排序 价格有限 排序规则<br>                    购物车<br>                    支付<br>                    没有登录的话就登录<br>                    登录功能 回调到购物车<br>                    结算页面  地址 可以进行编辑 选择<br>                    微信支付 支付宝支付<br>                    查看我的订单 跳转到个人中心<br>                    个人中心：代发货<br>                    其中就是订单<br>                    我的评价<br>                    我的信息<br>                    收货地址</p><h2 id="前后段主要技术选型"><a href="#前后段主要技术选型" class="headerlink" title="前后段主要技术选型"></a>前后段主要技术选型</h2><p>后段技术选型<br><code>SpringBoot Spring Mybatis</code> 框架整合</p><p>SpringBoot还是SpringMVC??<br>SpringMVC是框架  配置项很多就很繁琐<br>                还得自己下载tomcat<br>SpringBoot是框架：主要实现了自动配置，<br>                从xml配置繁琐到yml，<br>                还集成了很多的中间件，用starter依赖和引用，简化了maven配置<br>                从外置的tomcat变为内置的tomcat，在yaml就可以配置</p><p>前端技术选型：<br>        Jquery<br>        VUE本身是渐进式框架，方便。在渐进式过程中可以逐步逐步去替换掉原来的代码<br>        html<br>        css</p><p>技术选型要考虑到的：<br>    切合业务<br>    社区活跃度：代表使用率高，优缺点<br>    团队技术水平<br>    版本更新迭代的周期：以前Dubbo中间停更了一段时间，那么这段时间就会影响业务的使用<br>    安全性<br>    成功案例：口碑不错的</p><h2 id="前后端分离开发模式："><a href="#前后端分离开发模式：" class="headerlink" title="前后端分离开发模式："></a>前后端分离开发模式：</h2><p>早起传统的JAVAweb开发模式：<br>                      用户 – 浏览器 -url–服务器 war包(后段model,view,controller 前端html(jsp渲染成html)cssjs)  只要有用户访问服务器，所有请求的页面都在服务器进行渲染。当用户越来越多的话， 所有页面都在服务器进行渲染，服务器压力太大了了。<br>                      需要注意的是  传统web开发 ，浏览器请求到的服务器的所有页面都是基于url来进行跳转的</p><p>前后端单页面的交互：mvvm前端开发模式<br>                        手机  – 小程序/安卓—- ———–服务器model,view<br>                      用户—-浏览器–h5–nginx（html css js）–Restful webservice&gt;-服务器model,view,controller静态资源在静态资源服务器上，<br>                      前端龟前端，后端代码只要一套极好了</p><h2 id="数据库表设计："><a href="#数据库表设计：" class="headerlink" title="数据库表设计："></a>数据库表设计：</h2><p>全局的规划，数据库表设计工具设计库以及表，前期就设计好的<br><code>PDMan</code>:<br>            数据库建模工具<br>            设置：预处理的模版， 每次新建表的时候都会生成<br>            数据库设置：<br>            如何把关系图和数据库的表进行对应：模型版本–初始化基线写版本号-点击同步，注意同步配置里选的必须是增量</p><hr><h3 id="我们的设计库表中没有使用数据库外键"><a href="#我们的设计库表中没有使用数据库外键" class="headerlink" title="我们的设计库表中没有使用数据库外键"></a>我们的设计库表中没有使用数据库外键</h3><p>1，性能影响</p><p>对于数据的完整性会做检查操作，特别是在大并发的时候，会影响性能</p><p>2，热更新（不停机维护）<br>如果有外键的话，是强一致性的，使的新更新的代码无法运行，需要重启服务。而我们希望不停机维护。</p><p>3 降低耦合度</p><p>物理外键不存在，逻辑外键还是存在的，比如说cghtb有htbh字段，htmxb也有htbh字段</p><p>4 数据库分库发表<br>有外键关系的两张表，难以做到分到两个不同的数据库，因为耦合度是在是太高了。</p><hr><h2 id="项目结构搭建"><a href="#项目结构搭建" class="headerlink" title="项目结构搭建"></a>项目结构搭建</h2><h3 id="项目拆分与聚合："><a href="#项目拆分与聚合：" class="headerlink" title="项目拆分与聚合："></a>项目拆分与聚合：</h3><p>后段分层架构模式：基于maven分层与拆分<br>项目分层设计原则<br>前期拆分：根据业务拆分为不同的子模块<br>后期聚合：通过<code>maven</code>项目的聚合</p><p>jar                             common.jar子模块/工程  pojo.jar(数据库表逆向生成)  mapper.jar<br>或者        —-                service.jar  controller.jar     。。。<br>war<br>最终运行的包                      pom聚合工程  所有子模块都在聚合工程里面</p><p>这样的话就可以很多人进行开发<br>多个不同的项目可以都导入common的依赖不用多次写代码，</p><h3 id="Idea构建：具体操作的话可以参考https-blog-csdn-net-weixin-43434182-article-details-108017186"><a href="#Idea构建：具体操作的话可以参考https-blog-csdn-net-weixin-43434182-article-details-108017186" class="headerlink" title="Idea构建：具体操作的话可以参考https://blog.csdn.net/weixin_43434182/article/details/108017186"></a>Idea构建：具体操作的话可以参考<a href="https://blog.csdn.net/weixin_43434182/article/details/108017186">https://blog.csdn.net/weixin_43434182/article/details/108017186</a></h3><pre><code> 1. 拆分：        父工程由于构建的是聚合工程，所以打包方式选择pom        构建pojo，pojo引用common        构建mapper，mapper引用pojo，        构建service，service引用mapper，        构建api，api引用service    聚合：root --install 之后依赖关系才会真正的建立2. 父工程整合spring boot   pom.xml引入spring boot基础依赖</code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.imooc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>foodie-dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--        1.聚合工程可以分顶级项目（顶级工程，父工程）和子工程，两者之间为继承关系        子工程在maven中称之为module，模块之间时平级的，可以相互依赖        2.子工程可以使用父工程所有的资源（依赖），子工程之间如果需要相互之间使用资源，需要构建依赖（构建关系）        3.父工程可以由多个子工程组合而成    --></span>    <span class="token comment">&lt;!--所有的子工程都会在这里出现--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-common<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-pojo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-mapper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 聚合工程打包方式选择pom--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>     <span class="token comment">&lt;!--引入依赖parent,统一管理版本--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--设置资源属性--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--设置源码编码格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--设置编译后文件编码格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!--排除这一块依赖，后续引入其他依赖--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--spring boot可以解析yml文件，如果想解析xml等非yml配置文件，需要此依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-configuration-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span>然后在controller层就可以在resource下创建application.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编写启动类<br>    <pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class,args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>然后，因为是聚合项目，需要先install子项目，使其成为主项目的依赖，然后启动项目</p><hr><p>mybatis mysql mapper<br>导入依赖<br>写配置文件<br>mybatis逆向生成工具:打开项目，主要修改generatorConfig.xml文件,然后GeneratorDisplay，右键运行，生成相应的文件，<br>复制到项目中，因为引用了通用mapper，需要在项目中进行相应的配置</p><p>Restful<br>api service 层开发<br><code>Postman</code>调试Restful接口</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--跨域配置实现前后端联调</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE--%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE--%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class CorsConfig &#123;    public CorsConfig()&#123;    &#125;    @Bean    public CorsFilter corsFilter()&#123;        &#x2F;&#x2F;1. 添加cors配置信息        CorsConfiguration config &#x3D; new CorsConfiguration();        &#x2F;*允许访问的客户端域名*&#x2F;&#x2F;&#x2F;        config.addAllowedOrigin(&quot;http:&#x2F;&#x2F;192.168.180.129:80&quot;);        config.addAllowedOrigin(&quot;http:&#x2F;&#x2F;localhost:8080&quot;);        &#x2F;&#x2F;&#x2F;*是否允许请求带有验证信息*&#x2F;设置是否发送cookie信息        config.setAllowCredentials(true);        &#x2F;&#x2F;设置允许请求的方式        config.addAllowedMethod(&quot;*&quot;);        &#x2F;*允许服务端访问的客户端请求头*&#x2F;        config.addAllowedHeader(&quot;*&quot;);        &#x2F;&#x2F;2. 为url添加映射路径        UrlBasedCorsConfigurationSource corsSource &#x3D; new UrlBasedCorsConfigurationSource();        corsSource.registerCorsConfiguration(&quot;&#x2F;**&quot;,config);&#x2F;&#x2F;所有路径都可以使用配置信息        return new CorsFilter(corsSource);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/javaweb/javaweb%E7%AC%94%E8%AE%B0-----html/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/javaweb/javaweb%E7%AC%94%E8%AE%B0-----html/</url>
      
        <content type="html"><![CDATA[<p>1、HTML语法<br>      1)标签分为有开始有结束的标签和自结束标签<br>      2)标签不区分大小写<br>      3)标签可以嵌套，但不可以交叉嵌套<br>      4)标签必须正常关闭<br>      5)标签的属性必须有值，且属性值必须用引号括起来<br>      6)注释不可以嵌套</p><p>2、常用标签<br>      1)标题标签h1-h6,大小粗细递减<br>      2)<div></div>标签作用布局<br>      3)<p></p>段落标签<br>      4)转义字符       以&amp;开始，以;结束<br>                                          普通空格：&nbsp;<br>                                          中文空格：&emsp;<br>                                          大于号：&gt;<br>                                          小于号：&lt;<br>                                          版权号：&copy;<br>      5)列表<br>                                    有序列表<ol><br>                        <li></li><br>                                 </ol><br>                                    无序列表<ul><br>                        <li></li><br>                                 </ul>    type:disc 实心圆  、circle空心圆 、 square 方块</p><p>3、插入图片<code>&lt;img alt=&quot;picture&quot; src=&quot;img/wm.jpg&quot; title=&quot;aaa&quot;&gt;</code><br>     img 标签插入图片<br>     alt:图片插入路径有误时显示的文本<br>     src:图片插入的路径<br>     title:鼠标悬停时提示文本<br>     ../返回上一级<br>     src路径：当目标文件与当前文件在同一包中时可以直接访问。<br>                                当目标文件和当前文件不在同一包中时，要先找其父包，再找目标文件。</p><p>4、超链接    <code>&lt;a href=&quot;pages/target.html&quot; target=&quot;_blank&quot;&gt;</code>跳转到目标页面，目标页面有美女！</a><br>             使用a标签制作超链接<br>          href中是链接路径<br>          target中有        _blank在新的页面下打开<br>                      _self在当前界面打开</p><p>5、表格<br>         <code>&lt;table&gt;                &lt;tr&gt;             tr表示行                    &lt;th&gt;|&lt;td&gt;    th表头|td单元格                &lt;/tr&gt;          &lt;/table&gt;</code></p><pre><code>     rowspan跨行     clospan跨列     align=&quot;cender&quot;居中     width     height     border边界</code></pre><p>6、表单<br>               使用form制作表单<br>        input制作表单项<br>         type表单项类型<br>          text文本框<br>          password密码框<br>          reset重置<br>          submit提交<br>          file<br>          hidden</p><pre><code>     `name`名称，有name属性才可以提交数据到目标位置     value值     checked默认选中(radio(单选)|checkbox(复选))             使用select option 制作表单   action属性   表单提交的路径   method属性     表单提交的方式      get不安全     post安全</code></pre><p>7、CSS<br>1.CSS样式由选择符(选择器)和声明组成，而声明又由属性和值组成<br>选择器的分类<br>    ①标签选择器：如上图的p<br>    ②类选择器：.class属性值{..}<br>    ③ID选择器：#id属性值{..}<br>①写在标签的style属性中：<code>&lt;p style=“font-size: 30px”&gt;字体大小用px表示&lt;/p&gt;</code><br>②写在style标签中(style标签一般写在head标签与title标签之间)：<br>          <pre class="line-numbers language-html" data-language="html"><code class="language-html">      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">  <span class="token selector">p</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>③引入外部CSS文件：<br>    <code>html&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; </code>  </p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>html学习笔记<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">p</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>gold<span class="token punctuation">&#125;</span>        <span class="token selector">.color_orange</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">&#125;</span>        <span class="token selector">#font_size</span><span class="token punctuation">&#123;</span><span class="token property">font-size</span><span class="token punctuation">:</span> 36px<span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>这是我的第一个html页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    1. 语法<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!-- 1.标签的分类    开始结束标签    自闭合标签    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>css<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color_orange<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>javascript<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>font_size<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 2.标签不区分大小写 --></span>    <span class="token comment">&lt;!-- 3.标签可以嵌套但不能交叉嵌套 --></span>    <span class="token comment">&lt;!-- 4.标签必须正确关闭 --></span>    <span class="token comment">&lt;!-- 5.属性必须有值，且属性值必须加引号 --></span>    <span class="token comment">&lt;!-- 6.注释不能嵌套 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span>  <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>动漫头像  图片不能显示提示信息<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>动漫头像 放到图片上提示信息<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>常用标签.html<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击有美女,新页面打开<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>常用标签.html<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_self<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击有美女,在该页面打开<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>300px<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>姓名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>年龄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>静<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>13<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>喜洋洋<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--action表单提交的路径--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>success.html<span class="token punctuation">"</span></span>   <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        用户名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        密<span class="token entity named-entity" title="&emsp;">&amp;emsp;</span>码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        性别：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>man<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checked<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>男        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>woman<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        爱好：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>basketball<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checked<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>篮球        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>football<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>足球        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>volleyball<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>排球        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        喜欢的明星：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>star<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fbb<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>范冰冰<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>杨颖<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zzy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>章子怡<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 JavaWeb</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/javaweb/javaweb/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/javaweb/javaweb/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><ol><li>什么是 JavaWeb</li></ol><p>JavaWeb 是指，<code>所有通过Java语言编写可以通过浏览器访问的程序的总称</code>，叫 JavaWeb。 JavaWeb 是基于请求和响应来开发的。</p><p>b)什么是请求</p><p>请求是指客户端给服务器发送数据，叫请求 Request。</p><p>c)什么是响应</p><p>响应是指服务器给客户端回传数据，叫响应 Response。</p><p>d)请求和响应的关系</p><p>请求和响应是成对出现的，有请求就有响应。</p><ol start="2"><li>Web 资源的分类</li></ol><p>web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。 静态资源： html、css、js、txt、mp4 视频 , jpg 图片<br><strong>动态资源： jsp 页面、Servlet 程序</strong></p><p>3.常用的 Web 服务器</p><p>Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。它是一种轻量级的 javaWeb 容器（服务 器），也是当前应用最广的 JavaWeb 服务器（免费）。 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）。<br>GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业服务器，达到产品级质量（应用很少）。<br>Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良， resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的 Web 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）</p><p><img src="2020-12-10-17-41-59.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="2020/11/17/%E5%BC%82%E5%B8%B8/"/>
      <url>2020/11/17/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="31-2：Java中的两种异常类型是什么"><a href="#31-2：Java中的两种异常类型是什么" class="headerlink" title="31-2：Java中的两种异常类型是什么"></a>31-2：Java中的两种异常类型是什么</h2><p>Java 中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。</p><ol><li>受检异常<br>这种异常在IO操作中⽐较多。<br>⽬的就是告诉这个⽅法的调⽤者，<br>我这个⽅法不保证⼀定可以成功，<br>是有可能找不到对应的⽂件的，<br>你要明确的对这种情况做特殊处理哦。</li><li>非受检异常<br>这种异常⼀般可以理解为是代码原因导致的。<br>⽐如发⽣空指针、数组越界等。</li></ol><h2 id="1-1：他们有什么区别"><a href="#1-1：他们有什么区别" class="headerlink" title="1-1：他们有什么区别"></a>1-1：他们有什么区别</h2><ol><li>不受检查的异常不需要在方法或者是构造函数上声明</li><li>受检查的异常必须要用 throws 语句在方法或者是构造函数上声明。</li></ol><h2 id="1-2：异常链"><a href="#1-2：异常链" class="headerlink" title="1-2：异常链"></a>1-2：异常链</h2><p>是指在进⾏⼀个异常处理时抛出了另外⼀个异常， 由此产⽣了⼀个异常链条。<br>该技术⼤多⽤于将“ 受检查异常” 封装成为“⾮受检查异常”或者RuntimeException。</p><h2 id="1-3：try、catch、finally执行顺序"><a href="#1-3：try、catch、finally执行顺序" class="headerlink" title="1-3：try、catch、finally执行顺序"></a>1-3：try、catch、finally执行顺序</h2><h3 id="不带return返回顺序"><a href="#不带return返回顺序" class="headerlink" title="不带return返回顺序"></a>不带return返回顺序</h3><p>如果try中没有异常，则顺序为try→finally，如果try中有异常，则顺序为try→catch→finally</p><h3 id="带return返回顺序"><a href="#带return返回顺序" class="headerlink" title="带return返回顺序"></a>带return返回顺序</h3><p><code>如果try中带有return</code><br>   程序执行try块中return之前代码；<br>   再执行finally块，最后执行try中return;<br>   <code>finally块之后的语句return不再执行</code>，因为程序在try中已经return过了。</p><p><code>catch块中有return</code><br>   程序先执行try，如果遇到异常执行catch块，<br>      有异常：执行catch中return之前代码，<br>             再执行finally语句中全部代码，<br>             最后执行catch块中return。<br>             finally之后的return不再执行。<br>      无异常：执行完try再finally再return。</p><p><code>try块和finally块中有return</code><br>   无异常：程序执行<code>try块中return之前</code>代码；<br>          再执行<code>finally块</code>，因为finally块中有return所以提前退出，<br>          而不再执行try中的return；<br>   有异常：不执行try，顺序执行catch-finally</p><p><code>catch块和finally块中有return</code><br>   无异常：执行try后跳过catch执行finally；得到finally的返回值；<br>   有异常：程序执行catch块中return之前代码；<br>          再执行finally块，因为finally块中有return所以提前退出。<br>          而不再执行catch中的return。</p><p><code>try块、catch块和finally块中有return</code><br>   无异常：然后再执行finally块，<br>          因为finally块中有return所以提前退出。<br>   有异常：执行catch块中return之前代码；<br>          再执行finally块，因为finally块中有return所以提前退出。</p><p><a href="https://www.jianshu.com/p/8c9ea967ffe6">https://www.jianshu.com/p/8c9ea967ffe6</a>  具体习题可参考这片博文</p><h2 id="1-4：什么是OOM？常见有哪些OOM"><a href="#1-4：什么是OOM？常见有哪些OOM" class="headerlink" title="1-4：什么是OOM？常见有哪些OOM"></a>1-4：什么是OOM？常见有哪些OOM</h2><ol><li><code>Java堆溢出——OutOfMemoryError</code><br>原因：由于不断创建对象实例，当对象数量达到了最大堆的容量限制后产生内存溢出异常。<br>解决方法：<br>1)首先确认是内存泄露（Memory Leak）还是内存溢出（Memory Overflow）；<br>2)如果是内存泄漏引起的，查看GC Roots引用链，找出为什么无法被垃圾回收的原因；<br>3)如果是内存溢出，检查虚拟机的堆参数（-Xmx最大值和-Xms最小值），对比物理内存看是否可以调大；</li><li><code>虚拟机栈和本地方法栈溢出——StackOverflowError</code><br>原因：在单线程下，虚拟机栈容量太小或者定义了大量的本地变量<br>解决方法：增大虚拟机栈容量<br>原因：在多线程下，大量创建新线程，会抛出OOM，每个线程的栈分配的内存越大，越容易产生；<br>解决方法：减少线程产生、降低最大堆、减少栈容量；</li><li><code>运行时常量池溢出</code><br>原因：代码在运行时创建了大量的常量，超出了常量池上限；<br>解决方法：通过修改-XX:PermSize和-XX:MaxPermSize参数来修改方法区大小，从而修改常量池大小；</li><li><code>方法区溢出</code><br>原因：在运行时，ClassLoader动态加载了大量的Class信息，超出方法区上限；<br>解决方法：通过修改参数来修改方法区大小；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Java集合---List集合比较</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88/List%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88/List%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="源码扩容过程有什么值得借鉴的地方？"><a href="#源码扩容过程有什么值得借鉴的地方？" class="headerlink" title="源码扩容过程有什么值得借鉴的地方？"></a>源码扩容过程有什么值得借鉴的地方？</h2><p>答：有两点：</p><ol><li>是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封 装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时， 也可快速扩容。</li><li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li></ol><p>这两点在我们平时设计和写代码时都可以借鉴。</p><h2 id="ArrayList-和-LinkedList-两者有没有最大容量"><a href="#ArrayList-和-LinkedList-两者有没有最大容量" class="headerlink" title="ArrayList 和 LinkedList 两者有没有最大容量"></a>ArrayList 和 LinkedList 两者有没有最大容量</h2><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存 空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用 的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p><h2 id="vector、Arraylist区别和适用场景"><a href="#vector、Arraylist区别和适用场景" class="headerlink" title="vector、Arraylist区别和适用场景"></a>vector、Arraylist区别和适用场景</h2><p>1.<code>线程</code>：Vector是多线程安全的， Vector类中的方法很多有synchronized进行修饰，<br>         只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>         ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。<br>         这样就导致了Vector在效率上无法与ArrayList相比</p><ol start="2"><li><p><code>底层</code>：两个都是数组实现，支持快速随机访问，其 API 都做了一层对数组底层访问的封装</p></li><li><p><code>初始化</code>：Vector无参构造器初始化时就生成了容量为10的空数组，ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。</p><pre><code>  Vector可以设置增长因子CapacityIncrement，而ArrayList不可以</code></pre></li><li><p><code>扩容机制</code>：<br>Vector在每次add增加元素(可能是1个，也可能是一组)时，都要调用ensureCapacityHelper方法来确保足够的容量，当容量不足以容纳当前的元素个数时，即minCapacity（指的是当前元素数目elementCount + 1） - elementData.length &gt; 0，就会grow(minCapacity)扩容，就看构造方法中传入的容量增长系数CapacityIncrement是否为0，</p><pre><code>  如果不为0，就设置新的容量为 旧容量 + 容量增长量；  如果为0，设置新的容量为旧的容量的2倍，  如果设置后的容量还不够，则直接新的容量设置为  传入参数所需要的容量 </code></pre><p>ArrayList在每次add增加元素(可能是1个，也可能是一组)时，都要调用nsureCapacityInternal方法来确保足够的容量,如果我们期望的最小容量大于目前数组的长度，那么就扩容.</p><ol><li>ArrayList第一次add元素时，扩容为长度为10的数组。<br>当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时minCapacity等于默认的容量（10）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</li></ol></li></ol><h2 id="ArrayList、LinkedList区别和适用场景"><a href="#ArrayList、LinkedList区别和适用场景" class="headerlink" title="ArrayList、LinkedList区别和适用场景"></a>ArrayList、LinkedList区别和适用场景</h2><ol><li><code>是否保证线程安全</code>： ArrayList在单线程下是线程安全的，<pre><code>             多线程下由于多个线程不断抢夺资源，             所以会出现不安全             和 LinkedList 都是不同步的，也就是不保证线程安全；</code></pre></li><li><code>底层数据结构</code>： Arraylist 底层使用的是 Object 数组；<pre><code>             LinkedList 底层使用的是 双向链表 数据结构</code></pre></li><li><code>插入和删除是否受元素位置的影响</code>：<br>① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。<br>② LinkedList 采用链表存储，插入删除元素时间复杂度不受元素位置的影响，<pre><code>         如果是要在指定位置i插入和删除元素的话需要先移动到指定位置再插入。</code></pre></li><li><code>是否支持快速随机访问</code>： LinkedList 不支持高效的随机元素访问，<br>LinkedList 并没有采用从头循环到尾的做法， 而是采取了简单二分 法， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值 得我们借鉴。<br>而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。</li><li><code>内存空间占用</code>： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间；<br>双向链表节点对应的类Node的实例，<br>Node中包含成员变量：prev，next，item。<br>prev是该节点的上一个节点，<br>next是该节点的下一个节点，<br>item是该节点所包含的值。（因为要存放直接后继和直接前驱以及数据）<br>当需要对数据进行对此访问的情况下选用ArrayList，<br>当需要对数据进行多次增加删除修改时采用LinkedList。<br>ArrayList与LinkedList集合各有所长，可以在不同场合根据具体需求选用:<br>–    ArrayList元素的检索速度高于LinkedList<br>–    LinkedList因为内存的不连续性，更适合于大批量数据的存放和管理<br>–    如果在非末端插入数据，LinkedList速度优于ArrayList</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Java集合---LinkedList源码笔记</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88/LinkedList/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88/LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><font color=orange>LinkedList</font></h1><!-- ![avatar](http://i1.fuimg.com/729820/166f5e5b5f18282c.png)   --><img src='http://i1.fuimg.com/729820/166f5e5b5f18282c.png' width="30%"  ><font color=orange>可爱的小姐姐头像镇楼～～～～～～继续总结。开始LinkedList咯～～～～还是来个可爱的分隔符～</font><p><code>-------------------------------------------------------</code></p><h2 id="3-1：linkedlist数据结构"><a href="#3-1：linkedlist数据结构" class="headerlink" title="3-1：linkedlist数据结构"></a>3-1：linkedlist数据结构</h2><p><code>LinkedList</code>是List接口的<strong>双向链表</strong>非同步实现，<br>并允许包括<code>null</code>在内的所有元素。<br>双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如 下：</p><p>双向链表节点对应的<code>类Node</code>的实例，<br>Node中包含成员变量：<code>prev，next，item。</code><br><code>prev</code>是该节点的上一个节点，<br><code>next</code>是该节点的下一个节点，<br><code>item</code>是该节点所包含的值。<br><code>first</code> 是双向链表的头节点，它的前一个节点是 null。<br><code>last</code> 是双向链表的尾节点，它的后一个节点是 null；<br>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；<br>因为是个<code>双向链表</code>，只要机器内存足够强大，是没有大小限制的。</p><h2 id="3-2：linkedlist-根据索引返回对应的Node值"><a href="#3-2：linkedlist-根据索引返回对应的Node值" class="headerlink" title="3-2：linkedlist   根据索引返回对应的Node值"></a>3-2：linkedlist   根据索引返回对应的Node值</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Returns the (non-null) Node at the specified element index. *&#x2F;Node&lt;E&gt; node(int index) &#123;    &#x2F;&#x2F; assert isElementIndex(index);    if (index &lt; (size &gt;&gt; 1)) &#123;&#x2F;&#x2F; 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; 1 是 size 除以 2 的意思。        Node&lt;E&gt; x &#x3D; first;&#x2F;&#x2F; 直到 for 循环到 index 的前一个 node 停止        for (int i &#x3D; 0; i &lt; index; i++)            x &#x3D; x.next;        return x;    &#125; else &#123;&#x2F;&#x2F; 如果 index 处于队列的后半部分，从尾开始找        Node&lt;E&gt; x &#x3D; last;&#x2F;&#x2F; 直到 for 循环到 index 的后一个 node 停止        for (int i &#x3D; size - 1; i &gt; index; i--)            x &#x3D; x.prev;        return x;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码中我们可以发现， LinkedList 并没有采用从头循环到尾的做法， 而是采取了<font color=orange>简单二分法</font>， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，<code>这种思想值 得我们借鉴。</code></p><h2 id="3-3：linkedlist增加节点"><a href="#3-3：linkedlist增加节点" class="headerlink" title="3-3：linkedlist增加节点"></a>3-3：linkedlist增加节点</h2><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把 节点的值，前后指向节点都置为 null，帮助 GC 进行回收。<br>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开 始追加，addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void linkLast(E e) &#123;&#x2F;&#x2F; 把尾节点数据暂存    final Node&lt;E&gt; l &#x3D; last;&#x2F;&#x2F; 新建新的节点，初始化入参含义： &#x2F;&#x2F; l 是新节点的前一个节点，当前值是尾节点值    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);    last &#x3D; newNode;&#x2F;&#x2F;如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节    if (l &#x3D;&#x3D; null)        first &#x3D; newNode;&#x2F;&#x2F;否则把前尾节点的下一个节点，指向当前尾节点。    else        l.next &#x3D; newNode;&#x2F;&#x2F;大小和版本更改    size++;    modCount++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从头部追加（addFirst）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Links e as first element. *&#x2F;private void linkFirst(E e) &#123;    final Node&lt;E&gt; f &#x3D; first;    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);    first &#x3D; newNode;    if (f &#x3D;&#x3D; null)        last &#x3D; newNode;    else        f.prev &#x3D; newNode;    size++;    modCount++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4：linkedlist删除节点"><a href="#3-4：linkedlist删除节点" class="headerlink" title="3-4：linkedlist删除节点"></a>3-4：linkedlist删除节点</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">private E unlinkLast(Node&lt;E&gt; l) &#123;    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;    final E element &#x3D; l.item;    final Node&lt;E&gt; prev &#x3D; l.prev;    l.item &#x3D; null;    l.prev &#x3D; null; &#x2F;&#x2F; help GC    last &#x3D; prev;    if (prev &#x3D;&#x3D; null)        first &#x3D; null;    else        prev.next &#x3D; null;    size--;    modCount++;    return element;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">private E unlinkFirst(Node&lt;E&gt; f) &#123;    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;    final E element &#x3D; f.item;    final Node&lt;E&gt; next &#x3D; f.next;    f.item &#x3D; null;    f.next &#x3D; null; &#x2F;&#x2F; help GC    first &#x3D; next;    if (next &#x3D;&#x3D; null)        last &#x3D; null;    else        next.prev &#x3D; null;    size--;    modCount++;    return element;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Java集合---Vector源码笔记</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88/Vector/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88/Vector/</url>
      
        <content type="html"><![CDATA[<p><code>VECTOR</code></p><p><code>休息了一会会，接着再来看看Vector的源码吧，加油～～</code><br><img src='http://i1.fuimg.com/729820/166f5e5b5f18282c.png' width="25%" ><br><code>-----------------------------------------------------------------------------</code></p><h2 id="1-1：vector数据结构"><a href="#1-1：vector数据结构" class="headerlink" title="1-1：vector数据结构"></a>1-1：vector数据结构</h2><p>底层数据结构为<code>数组</code>，支持快速随机访问</p><h2 id="1-2：vector构造器"><a href="#1-2：vector构造器" class="headerlink" title="1-2：vector构造器"></a>1-2：vector构造器</h2><p><code>Vector</code>有四个不同的构造函数。 无参构造的容量默认值为10，容量增长系数<code>CapacityIncrement</code>为0</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Vector(int initialCapacity, int capacityIncrement) &#123;    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    this.elementData &#x3D; new Object[initialCapacity];    this.capacityIncrement &#x3D; capacityIncrement;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3：vector-indexOf-object-o"><a href="#1-3：vector-indexOf-object-o" class="headerlink" title="1-3：vector  indexOf(object o)"></a>1-3：vector  indexOf(object o)</h2><p>Vector在查找给定元素索引值方法中，<code>indexOf(object o )</code>–&gt;<br>Vector中允许元素为<code>null</code><br>源码都将该元素的值分为null和不为null两种情况处理，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int indexOf(Object o) &#123;    return indexOf(o, 0);&#125;public synchronized int indexOf(Object o, int index) &#123;    if (o &#x3D;&#x3D; null) &#123;        for (int i &#x3D; index ; i &lt; elementCount ; i++)            if (elementData[i]&#x3D;&#x3D;null)                return i;    &#125; else &#123;        for (int i &#x3D; index ; i &lt; elementCount ; i++)            if (o.equals(elementData[i]))                return i;    &#125;    return -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4：扩容机制"><a href="#1-4：扩容机制" class="headerlink" title="1-4：扩容机制"></a>1-4：扩容机制</h2><p>与<code>ArrayList</code>不同的是，<br><code>Vector</code>在每次<code>add</code>增加元素(可能是1个，也可能是一组)时，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public synchronized boolean add(E e) &#123;    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] &#x3D; e;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都要调用<code>ensureCapacityHelper</code>方法来确保足够的容量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void ensureCapacityHelper(int minCapacity) &#123;    &#x2F;&#x2F; overflow-conscious code    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当容量不足以容纳当前的元素个数时，即<code>minCapacity</code>（指的是当前元素数目<code>elementCount + 1） - elementData.length &gt; 0</code>，就会<code>grow(minCapacity)</code>扩容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void grow(int minCapacity) &#123;    &#x2F;&#x2F; overflow-conscious code    int oldCapacity &#x3D; elementData.length;    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ?                                     capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity &#x3D; minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity &#x3D; hugeCapacity(minCapacity);    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就看构造方法中传入的容量增长系数<code>CapacityIncrement</code>是否为0，<br>**如果不为0，就设置新的容量为 旧容量 + 容量增长量；<br>如果为0，设置新的容量为旧的容量的2倍，<br>如果设置后的容量还不够，则直接新的容量设置为传入参数所需要的容量 **<br>而后同样用<code>Arrays.copyof()</code>方法将元素拷贝到新的数组。</p><h2 id="1-5：Vector是保证线程安全的"><a href="#1-5：Vector是保证线程安全的" class="headerlink" title="1-5：Vector是保证线程安全的"></a>1-5：Vector是保证线程安全的</h2><p>由于vector中Add方法加了<code>synchronized</code>，来保证add操作是线程安全的</p>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入学习-----ArrayList</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88/ArrayList/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88/ArrayList/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 深入Java集合—ArrayList源码笔记<br>date: 2020-11-17 14:20:32<br>tags: java，集合，源码</p><hr><h1 id="ARRAYLIST"><a href="#ARRAYLIST" class="headerlink" title="ARRAYLIST"></a><font color=orange>ARRAYLIST</font></h1><!-- ![avatar](http://i1.fuimg.com/729820/166f5e5b5f18282c.png)   --><img src='http://i1.fuimg.com/729820/166f5e5b5f18282c.png' width="30%" ><p><code>可爱的小姐姐头像镇楼～～～～～～ 今天打算把看过的源码总结一下。从集合框架开始咯～～～～ 来个可爱的分隔符～！ 话不多说正式开始总结啦！！！！</code><br><code>-------------------------------------------------------</code></p><h2 id="数组-Array-和列表-ArrayList-有什么区别？"><a href="#数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？"></a>数组(Array)和列表(ArrayList)有什么区别？</h2><ol><li>定义上： Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。 </li><li>容量上： Array 大小固定， ArrayList 的大小是动态变化的。 </li><li>操作上： ArrayList 提供更多的方法和特性， </li></ol><p>使用基本数据类型或者知道数据元素数量的时候<br>可以考虑Array;<br>ArrayList处理固定数量<br>的基本类型数据类型时<br>会自动装箱来减少编码工作量，<br>但是相对较慢。</p><h2 id="2-1：ArrayList数据结构"><a href="#2-1：ArrayList数据结构" class="headerlink" title="2-1：ArrayList数据结构"></a>2-1：ArrayList数据结构</h2><p>private transient Object[] elementData;<br>底层使用<code>数组</code>实现, 其 API 都做了一层对数组底层访问的封装</p><p>并允许包括null在内的所有元素。</p><h2 id="2-2-：构造器"><a href="#2-2-：构造器" class="headerlink" title="2-2 ：构造器"></a>2-2 ：构造器</h2><p>有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如 下：<br><code>无参数直接初始化:</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;public ArrayList() &#123;    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。<br><code>指定初始数据初始化</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ArrayList(Collection&lt;? extends E&gt; c) &#123;    elementData &#x3D; c.toArray();    if ((size &#x3D; elementData.length) !&#x3D; 0) &#123;        &#x2F;&#x2F; c.toArray might (incorrectly) not return Object[] (see 6260652)&#x2F;&#x2F;是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型        if (elementData.getClass() !&#x3D; Object[].class)            elementData &#x3D; Arrays.copyOf(elementData, size, Object[].class);    &#125; else &#123;        &#x2F;&#x2F; replace with empty array.&#x2F;&#x2F; 给定集合（c）无值，则默认空数组        this.elementData &#x3D; EMPTY_ELEMENTDATA;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=orange>为什么要创建空数组？</font><br>因为开发中很多时候 创建了ArrayList对象，但是没有装元素，这个时候的话，直接初始化为10，就会浪费空间。</p><h2 id="2-3：ArrayList的add操作-以及-扩容"><a href="#2-3：ArrayList的add操作-以及-扩容" class="headerlink" title="2-3：ArrayList的add操作  以及 扩容"></a>2-3：ArrayList的add操作  以及 扩容</h2><p>新增就是往数组中添加元素，主要分成两步：<br>判断是否需要扩容，如果需要执行扩容操作；<br>直接赋值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean add(E e) &#123;&#x2F;&#x2F;确保数组大小是否足够，不够执行扩容，size 为当前数组的大小    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!    elementData[size++] &#x3D; e;    return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;&#x2F;&#x2F;如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        return Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    return minCapacity;&#125;private void ensureExplicitCapacity(int minCapacity) &#123;&#x2F;&#x2F;记录数组被修改    modCount++;    &#x2F;&#x2F; overflow-conscious code&#x2F;&#x2F; 如果我们期望的最小容量大于目前数组的长度，那么就扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);&#125;&#x2F;&#x2F; 如果我们期望的最小容量大于目前数组的长度，那么就扩容private void grow(int minCapacity) &#123;    &#x2F;&#x2F; overflow-conscious code    int oldCapacity &#x3D; elementData.length;    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);&#x2F;&#x2F; 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值    if (newCapacity - minCapacity &lt; 0)        newCapacity &#x3D; minCapacity;&#x2F;&#x2F; 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity &#x3D; hugeCapacity(minCapacity);    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，每当向数组中添加元素时， 都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容， 以满足添加数据的需求。数组扩容通过一个公开的方法 <code>ensureCapacity(int minCapacity)</code> 来 实现。</p><ol><li><p><code>ArrayList</code>第一次<code>add</code>元素时，扩容为长度为10的数组。<br>  当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时<code>minCapacity</code>等于默认的容量（<strong>10</strong>）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p></li><li><p>   扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原 来容量的 <strong>1.5</strong> 倍；<br>当ArrayList数组超过当前容量时，扩容至1.5倍（遇到计算结果为小数的，向下取整），<br>第一次扩容后，容量为15，第二次扩容至22</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static int hugeCapacity(int minCapacity) &#123;    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ArrayList 中的数组的最大值是 <code>Integer.MAX_VALUE</code>，超过这个值，JVM 就不会给数组分配 内存空间了。这边也可以看到ArrayList允许的最大容量，就是Integer的最大值（-2的31次方~2的31次方减1）。</p></li><li><p>   新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 <code>null</code> 值的。</p></li><li><p>   不是原子操作，，没有任何锁控制，所以这里的操作是线程不安全的，原因主要是<code>elementData[size++] = e</code>可以继续进行拆分</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static int hugeCapacity(int minCapacity) &#123;    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>扩容是通过这行代码来实现的： <code>Arrays.copyOf(elementData, newCapacity); </code>这行代码描述的 本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据 拷贝过去，我们通过 <code>System.arraycopy </code>方法进行拷贝</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @param src 被拷贝的数组 * @param srcPos 从数组那里开始* @param dest 目标数组 * @param destPos 从目标数组那个索引位置开始拷贝 * @param length 拷贝的长度 * 此方法是没有返回值的，通过 dest 的引用进行传值 *&#x2F;public static native void arraycopy(Object src,  int  srcPos,                                    Object dest, int destPos,                                    int length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4：remove"><a href="#2-4：remove" class="headerlink" title="2-4：remove"></a>2-4：remove</h2><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理 和思路都差不多，我们选取根据值删除方式来进行源码说明：</p><p>我们需要注意的两点是：</p><p>新增的时候是没有对 <code>null</code> 进行校验的，所以删除的时候也是允许删除 <code>null</code> 值的； 找到值在数组中的索引位置，是通过 <code>equals</code> 来判断的，如果数组元素不是基本类型，需要我 们关注 <code>equals</code> 的具体实现。</p><p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean remove(Object o) &#123;    if (o &#x3D;&#x3D; null) &#123;        for (int index &#x3D; 0; index &lt; size; index++)            if (elementData[index] &#x3D;&#x3D; null) &#123;                fastRemove(index);                return true;            &#125;    &#125; else &#123;        for (int index &#x3D; 0; index &lt; size; index++)            if (o.equals(elementData[index])) &#123;                fastRemove(index);                return true;            &#125;    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void fastRemove(int index) &#123;    modCount++;    int numMoved &#x3D; size - index - 1;    if (numMoved &gt; 0)&#x2F;&#x2F; numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去&#x2F;&#x2F; 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 num        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);&#x2F;&#x2F; remove方法会让下标到数组末尾的元素向前移动一个单位，并把最后一位的值置空，方便GC    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5：ArrayList线程不安全"><a href="#2-5：ArrayList线程不安全" class="headerlink" title="2-5：ArrayList线程不安全"></a>2-5：ArrayList线程不安全</h2><p>只有当 ArrayList 作为<code>共享变量</code>时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，<strong>所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</strong></p><h2 id="2-6：那如何解决ArrayList线程不安全问题呢？"><a href="#2-6：那如何解决ArrayList线程不安全问题呢？" class="headerlink" title="2-6：那如何解决ArrayList线程不安全问题呢？"></a>2-6：那如何解决ArrayList线程不安全问题呢？</h2><ol><li>用Collections.synchronizedList<ul><li>因为Collections.synchronizedList封装后的list，<br> list的所有操作方法都是带synchronized关键字的，<br> 相当于所有操作都会进行加锁，<br> 所以使用它是线程安全的，但是性能大大降低，</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">SynchronizedCollection(Collection&lt;E&gt; c) &#123;    this.c &#x3D; Objects.requireNonNull(c);    mutex &#x3D; this;&#125;public boolean add(E e) &#123;    synchronized (mutex) &#123;return c.add(e);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><code>CopyOnWriteArrayList</code><ul><li>写操作：添加元素时，<pre><code>   不直接往当前容器添加，而是先拷贝一份数组，   在新的数组中添加元素后，   在将原容器的引用指向新的容器。   因为数组时用volatile关键字修饰的，   所以当array重新赋值后，   其他线程可以立即知道（volatile的可见性）</code></pre></li><li>读操作：读取数组时，读老的数组，不需要加锁。</li><li>读写分离：写操作是copy了一份新的数组进行写，<pre><code>     读操作是读老的数组，所以是读写分离。</code></pre>采用了<code>Fail-Fast</code>机制，<br>面对并发的修改时，迭代器很快就会完全失败，<br>而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java基础，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github博客：网站内图片不能正常显示，但本地文件可以显示</title>
      <link href="2020/09/07/hexo%E5%8D%9A%E5%AE%A2/pic/"/>
      <url>2020/09/07/hexo%E5%8D%9A%E5%AE%A2/pic/</url>
      
        <content type="html"><![CDATA[<p>在同级的img下放图片，md引用即可</p><p>参考文章：<br>网上流传的另一份代码 npm install <a href="https://github.com/CodeFalling/hexo-asset-image">https://github.com/CodeFalling/hexo-asset-image</a> –save 并不能使用。</p><p><a href="https://cpper.blog.csdn.net/article/details/104117319?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.not_use_machine_learn_pai">https://cpper.blog.csdn.net/article/details/104117319?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.not_use_machine_learn_pai</a></p><p><img src="a.png"></p><img src="/2020/09/07/hexo%E5%8D%9A%E5%AE%A2/pic/a.png" class="" title="hi"><p><img src="1.png"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-看图了解思想</title>
      <link href="2020/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Sort/"/>
      <url>2020/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Sort/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5>今天看了bilibili左神的排序算法的公开课！！！  <p>学到了学到了  </p><p>接着想练习一下   </p><p>做了leedcode912. 排序数组    </p><p>下面来总结一下常见的排序算法把～～～<br></font ><br><font color = 'pink' size = 3>(里面的动态图参考<a href="https://www.cnblogs.com/onepixel/p/7674659.html%E5%A4%A7%E4%BD%AC%E7%9A%84">https://www.cnblogs.com/onepixel/p/7674659.html大佬的</a>)<br></font></p><hr><p>   <font color = 'pink' size = 3> 以下是时间复杂度：o(n2)  空间复杂度：o(1)三兄弟<br>   其中冒泡 插入 稳定的<br>   选择不稳定<br>   具体分析看下面详解<br>   </font></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>进行n-1次排序,依次选择最大的数字浮到数组的后面<br>比较相邻的元素。如果第一个比第二个大，就交换它们两个；对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p><img src=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif alt="bubbleSort" /><p><code>时间：o(n2)   空间o(1) 稳定的</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;                for(int i &#x3D; 0 ; i&lt;nums.length-1;i++)&#123;            for(int j &#x3D; 0 ;j &lt; nums.length-1-i;j++)&#123;                if(nums[j]&gt;nums[j+1])&#123;                    int tmp &#x3D; nums[j];                    nums[j]&#x3D;nums[j+1];                    nums[j+1]&#x3D;tmp;                &#125;            &#125;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次选择最小值放在前面，<br>看图说话</p><p><img src=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gifalt="selectSort" /></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        &#x2F;&#x2F;selctSort        for(int i &#x3D; 0 ; i&lt;nums.length-1;i++)&#123;            int minindex &#x3D; i;            for(int j &#x3D; i+1;j&lt;nums.length;j++)&#123;                if(nums[minindex]&gt;nums[j])&#123;                    minindex &#x3D; j;                &#125;            &#125;            int tmp &#x3D; nums[i];nums[i]&#x3D;nums[minindex];nums[minindex]&#x3D;tmp;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>时间：o(n2)   空间o(1) 不稳定的</code><br><strong>注意注意</strong><br>比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等 的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列<strong>5 8 5 2 9</strong>，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序<strong>不是一个稳定的排序算法</strong>。<br>执行结果：<br>[5, 8, 5, 2, 9]<br>[2, 8, 5, 5, 9]<br>[2, 5, 8, 5, 9]<br>[2, 5, 5, 8, 9]</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>从第一个元素开始，该元素可以认为已经被排序；<br>取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；</p><p><img src=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gifalt="insertSort" /></p><p><code>时间：o(n2)   空间o(1)  稳定的</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        &#x2F;&#x2F;&#x2F;selectsort        for(int i &#x3D; 1; i &lt; nums.length;i++)&#123;            int current &#x3D; nums[i];            int preIndex &#x3D; i-1;            &#x2F;&#x2F;找位置插入               while(preIndex&gt;&#x3D;0&amp;&amp;nums[preIndex]&gt;current)&#123;                nums[preIndex+1]&#x3D;nums[preIndex];                preIndex--;            &#125;            nums[preIndex+1]&#x3D;current;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把长度为n的输入序列分成两个长度为n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。</p><p><img src=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gifalt="mergeSort" /><br><code>时间复杂度O(N*logN)，额外空间复杂度O(N) 稳定</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        &#x2F;&#x2F;归并排序        if(nums&#x3D;&#x3D;null||nums.length&lt;2) return nums;        mergeSort(nums,0,nums.length-1);        return nums;    &#125;    public void mergeSort(int[] nums,int l,int r)&#123;        if(l&#x3D;&#x3D;r) return;        int mid &#x3D; l + ((r-l)&gt;&gt;1);        mergeSort(nums,l,mid);        mergeSort(nums,mid+1,r);        merge(nums,l,mid,r);    &#125;    public void merge(int[] nums,int l, int mid, int r)&#123;        int[] help &#x3D; new int[r-l+1];        int p1 &#x3D; l;        int p2 &#x3D; mid+1;        int i &#x3D; 0;        while(p1&lt;&#x3D;mid&amp;&amp;p2&lt;&#x3D;r)&#123;            help[i++] &#x3D; (nums[p1]&lt;nums[p2])?nums[p1++]:nums[p2++];        &#125;        while(p1&lt;&#x3D;mid)&#123;            help[i++]&#x3D;nums[p1++];        &#125;        while(p2&lt;&#x3D;r)&#123;            help[i++]&#x3D;nums[p2++];        &#125;        for(int j &#x3D; 0 ; j &lt; help.length;j++)&#123;            nums[j+l] &#x3D; help[j];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><p>从数列中挑出一个元素，称为 “基准”（pivot）；<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br><code>时间复杂度O(N*logN)，额外空间复杂度O(logN) 不稳定</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        if(nums&#x3D;&#x3D;null||nums.length&lt;2) return nums;        &#x2F;&#x2F;quickSort        quickSort(nums,0,nums.length-1);        return nums;    &#125;    public void quickSort(int[] nums, int l , int r)&#123;        if(l&gt;&#x3D;r) return ;        &#x2F;&#x2F; pivot: 标杆位置，cur: 小于pivot的元素的个数        int pivot &#x3D; partition(nums,l,r);        quickSort(nums,l,pivot-1);        quickSort(nums,pivot+1,r);    &#125;    public int  partition(int[] nums, int l,int r)&#123;        int pivot &#x3D; r;        int cur &#x3D; l;        for(int i &#x3D; l ; i &lt; r;i++)&#123;            if(nums[i]&lt;nums[pivot])&#123;                int tmp &#x3D; nums[i];nums[i]&#x3D;nums[cur];nums[cur]&#x3D;tmp;                cur++;            &#125;        &#125;        int tmp &#x3D; nums[cur];nums[cur]&#x3D;nums[pivot];nums[pivot]&#x3D;tmp;        return cur;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序引出的逆序对和小数和问题</title>
      <link href="2020/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2020/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<font color = 'pink' size = 5>！！！  看了归并排序那接着来看看几道题把  趁热打铁</font >---<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p><code>剑指 Offer 51. 数组中的逆序对</code><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>示例 1:<br>输入: [7,5,6,4]<br>输出: 5</p><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    int sum &#x3D; 0;    public int reversePairs(int[] nums) &#123;        if(nums&#x3D;&#x3D;null||nums.length&lt;2) return 0;        mergeSort(nums,0,nums.length-1);        return sum;    &#125;    public int mergeSort(int[] nums,int l,int r)&#123;        if(l&#x3D;&#x3D;r) return 0;        int mid &#x3D; l + ((r-l)&gt;&gt;2);        return mergeSort(nums,l,mid)+mergeSort(nums,mid+1,r)+merge(nums,l,mid,r);    &#125;    public int merge(int[] nums,int l ,int mid,int r)&#123;        int i &#x3D; 0;        int[] help &#x3D; new int[r-l+1];        int p1&#x3D;l;        int p2&#x3D;mid+1;        while(p1&lt;&#x3D;mid&amp;&amp;p2&lt;&#x3D;r)&#123;            sum +&#x3D; nums[p1]&gt;nums[p2]?(mid-p1+1):0;            help[i++]&#x3D;nums[p1]&gt;nums[p2]?nums[p2++]:nums[p1++];        &#125;        while(p1&lt;&#x3D;mid)&#123;            help[i++]&#x3D;nums[p1++];        &#125;        while(p2&lt;&#x3D;r)&#123;            help[i++]&#x3D;nums[p2++];        &#125;        for(i &#x3D; 0;i&lt;help.length;i++)&#123;            nums[l+i]&#x3D;help[i];        &#125;        return sum;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><p><code>小和问题</code></p><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。</p><p>例子： [1,3,4,2,5] 1左边比1小的数，没有；<br> 3左边比3小的数，1；<br> 4左边比4小的数，1、3；<br>2左边比2小的数，1；<br>5左边比5小的数，1、3、4、2；<br>   所以小和为1+1+3+1+1+3+4+2=16</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int smallSum(int[] arr) &#123;if (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;return 0;&#125;return mergeSort(arr, 0, arr.length - 1);&#125;public static int mergeSort(int[] arr, int l, int r) &#123;if (l &#x3D;&#x3D; r) &#123;return 0;&#125;int mid &#x3D; l + ((r - l) &gt;&gt; 1);return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r);&#125;public static int merge(int[] arr, int l, int m, int r) &#123;int[] help &#x3D; new int[r - l + 1];int i &#x3D; 0;int p1 &#x3D; l;int p2 &#x3D; m + 1;int res &#x3D; 0;while (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;res +&#x3D; arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0;help[i++] &#x3D; arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#125;while (p1 &lt;&#x3D; m) &#123;help[i++] &#x3D; arr[p1++];&#125;while (p2 &lt;&#x3D; r) &#123;help[i++] &#x3D; arr[p2++];&#125;for (i &#x3D; 0; i &lt; help.length; i++) &#123;arr[l + i] &#x3D; help[i];&#125;return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程是什么-与线程的初相识</title>
      <link href="2019/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>2019/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="什么叫做线程"><a href="#什么叫做线程" class="headerlink" title="什么叫做线程"></a>什么叫做线程</h2><p><img src="/img/b.png"></p><p><code>程序(program)</code>：是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。</p><p><code>进程(process)</code>是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。——生命周期<br>如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的<br>进程作为<code>资源分配的单位</code>，系统在运行时会为每个进程分配不同的内存区域，每个进程会有独立的方法区和堆空间</p><p><code>线程(thread)</code>，进程可进一步细化为线程，<strong>是一个程序内部的一条执行路径。</strong></p><p>若<strong>一个进程同一时间并行执行多个线程</strong>，就是支持<strong>多线程</strong>的<br>线程作为<code>调度和执行的单位</code>，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小<br>一个进程中的多个线程<code>共享相同的内存单元/内存地址空间</code> ，它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得<code>线程间通信更简便、高效</code>。<br>但多个线程操作共享的系统资源可能就会带来<code>安全</code>的隐患。</p><p><code>并行与并发</code></p><ol><li>并发： 同⼀时间段，多个任务都在执⾏；</li><li>并⾏： 单位时间内，多个任务同时执⾏。</li></ol><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</p><p>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，<strong>此时它已 具备了运行的条件</strong>，只是没分配到CPU资源</p><p>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能</p><p>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</p><p>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</p><p> -&gt; 创建状态：一个新进程被创建时的第一个状态；<br>创建状态 -&gt; 就绪状态：当进程被创建完成并初始化后，<br>                     一切就绪准备运行时，<br>                     变为就绪状态，这个过程是很快的；<br>就绪态 -&gt; 运行状态：处于就绪状态的进程被操作系统的进程调度器选中后，<br>                    就分配给 CPU 正式运行该进程；<br>运行状态 -&gt; 结束状态：当进程已经运行完成或出错时，<br>                      会被操作系统作结束状态处理；<br>运行状态 -&gt; 就绪状态：处于运行状态的进程在运行过程中，<br>                      由于分配给它的运行时间片用完，<br>                      <strong>yield( )或失去cpu资源</strong><br>                      操作系统会把该进程变为就绪态，<br>                      接着从就绪态选中另外一个进程运行；<br>运行状态 -&gt; 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I/O 事件；<br>                    sleep(long time) join  wait 等待同步锁</p><p>阻塞状态 -&gt; 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；<br>                    sleep时间到  join结束  notify/notifyAll 获取到了同步锁</p><h2 id="wait和sleep的异同"><a href="#wait和sleep的异同" class="headerlink" title="wait和sleep的异同"></a>wait和sleep的异同</h2><p>相同点：<br>一旦执行方法都可以使当前线程进入阻塞状态</p><p>不同点：</p><ol><li><p><code>来自不同的类</code>，Thread类中声明了sleep,object类中声明wait</p></li><li><p><code>调用的要求不同</code>：sleep可以在任意需要的场景下调用，wait必须在同步代码块或者同步方法中调用</p></li><li><p><code>关于是否释放同步监视器的问题</code>：如果两个方法都在同步代码块当中，sleep不会释放锁，wait会释放锁</p></li><li><p>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。<br>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发安全包</title>
      <link href="2019/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>2019/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>主要有俩个方法</p><p>昂一个线程或者多个线程调用<code>await</code>方法的时候，这些线程会被阻塞，</p><p>调用<code>countDown</code>方法会将计数器减1，调用countDown方法的线程不会被阻塞</p><p>当计数器的值变为0的时候，因为<code>await</code>阻塞的线程就会被唤醒，继续执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws InterruptedException &#123;        CountDownLatch countDownLatch &#x3D; new CountDownLatch(3);        for (int i &#x3D; 0 ; i &lt; 3;i++)&#123;            new Thread(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;);                countDownLatch.countDown();            &#125;,String.valueOf(i)).start();        &#125;    countDownLatch.await();        System.out.println(&quot;main完成&quot;);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3,()-&gt;&#123;            System.out.println(&quot;等到3个线程完成之后才会打印&quot;);        &#125;);        for (int i &#x3D; 0 ; i &lt; 3;i++)&#123;            final int tmp &#x3D; i ;            new Thread(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+tmp);                try &#123;                    cyclicBarrier.await();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125; catch (BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;            &#125;,String.valueOf(i)).start();        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>acquire</code>:当一个线程调用acquire操作的时候，要么通过成功获取信号量（<code>信号量减1</code>），<strong>要么一直等待下去，知道有线程释放信号量或者超时</strong><br><code>release</code>：实际上会将<code>信号量加1</code>，然后等待<code>唤醒等待的线程</code></p><p><code>信号量主要目的</code><br>一个是用于<code>共享资源的互斥使用</code>，<br>一个是用于<code>并发线程数的控制</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Semaphore semaphore &#x3D; new Semaphore(3);        for(int i &#x3D; 0;i&lt;6;i++)&#123;            new Thread(()-&gt;&#123;                try &#123;                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName()+&quot;抢到了&quot;);                    try &#123;TimeUnit.SECONDS.sleep(1);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;                    System.out.println(Thread.currentThread().getName()+&quot;离开了&quot;);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    semaphore.release();                &#125;            &#125;,String.valueOf(i)).start();        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>为了保证并发量，<br>希望读读共存<br>读写不能共存<br>写读不能共存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">static class MyCache &#123;        private volatile Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();        private ReadWriteLock readWriteLock &#x3D; new ReentrantReadWriteLock();        public void put(String key, Object value)  &#123;            readWriteLock.writeLock().lock();  &#x2F;&#x2F;上写锁            try &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t-----写入数据key&quot;);&#x2F;&#x2F;            Thread.sleep(3000);                map.put(key, value);                System.out.println(Thread.currentThread().getName() + &quot;\t-----写入数据成功&quot;);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125; finally &#123;                readWriteLock.writeLock().unlock();            &#125;        &#125;        public void get(String key)  &#123;            readWriteLock.readLock().lock();  &#x2F;&#x2F;上读锁            try &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t读取数据key&quot;);&#x2F;&#x2F;            Thread.sleep(3000);                Object result &#x3D; map.get(key);                System.out.println(Thread.currentThread().getName() + &quot;\t读取数据成功&quot; + result);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125; finally &#123;                readWriteLock.readLock().unlock();            &#125;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        MyCache myCache &#x3D; new MyCache();        for (int i &#x3D; 0; i &lt; 5; i++) &#123;            final int tmp &#x3D; i ;            new Thread(()-&gt;&#123;                myCache.put(tmp+&quot;&quot;,tmp+&quot;&quot;);            &#125;,String.valueOf(i)).start();        &#125;        for (int i &#x3D; 0; i &lt; 5; i++) &#123;            final int tmp &#x3D; i ;            new Thread(()-&gt;&#123;                myCache.get(tmp+&quot;&quot;);            &#125;,String.valueOf(i)).start();        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类如何让加载，常见的类加载器，如何自定义类加载器</title>
      <link href="2019/09/07/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD/load/"/>
      <url>2019/09/07/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD/load/</url>
      
        <content type="html"><![CDATA[<p><code>类加载运行全过程</code></p><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到 JVM。</p><p>通过Java命令执行代码的大体流程如下：<br>其中loadClass的类加载过程有如下几步： 加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 </p><p><code>加载：</code></p><p>通过全类名获取定义此类的二进制字节流<br>将字节流所代表的静态存储结构转换为方法区的运行时数据结构<br>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</p><p><code>验证：</code>校验字节码文件的正确性</p><p><code>准备：</code>给类的<code>静态变量</code>分配内存，并赋予默认值<br>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。<br>    <code>特殊情况</code>：比如给 value 变量加上了 fianl 关键字public static final int value=1 ，那么准备阶段 value 的值就被复制为 1。<br><code>解析：</code>将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如 main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过 程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用，下 节课会讲到动态链接</p><p>初始化：对类的<code>静态变量初始化为指定的值</code>，<code>执行静态代码块</code><br>也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <clinit> ()方法的过程。<br>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化：<br>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<br>使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。<br>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。<br>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。<br>当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。</p><p><strong>注意</strong>，<br>主类在运行过程中如果使用到其它类，会逐步加载这些类。<br>jar包或war包里的类不是一次性全部加载的，是 <strong>使用到时才加载</strong>。</p><p><code>类加载器和双亲委派机制</code></p><p>上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器</p><p><code>引导类加载器</code>：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等<br><code>扩展类加载器</code>：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包<br>应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那 些类 自定义加载器：负责加载用户自定义路径下的类包</p><p><code>类加载器初始化过程</code>：</p><p>参见类运行加载全过程图可知其中会创建JVM启动器实例sun.misc.Launcher。 sun.misc.Launcher初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个 sun.misc.Launcher实例。 在Launcher构造方法内部，其创建了两个类加载器，分别是 sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应 用类加载器)。 JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们 的应用程序。</p><p><code>双亲委派机制</code><br>双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载</p><p>我们来看下应用程序类加载器AppClassLoader加载类的双亲委派机制源码，AppClassLoader 的loadClass方法最终会调用其父类ClassLoader的loadClass方法，该方法的大体逻辑如下：</p><ol><li><p>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接 返回。</p></li><li><p>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加 载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加 载。</p></li><li><p>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 findClass方法来完成类加载。</p></li></ol><p><code>为什么要设计双亲委派机制？</code></p><p>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心 API库被随意篡改</p><p>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一 次，保证被加载类的唯一性</p><p><code>自定义类加载器示例</code>：</p><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是 loadClass(String, boolean)，实现了双亲委派机制，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是重写</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类的加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志设置</title>
      <link href="2019/09/07/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E6%97%A5%E5%BF%97/"/>
      <url>2019/09/07/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-boot使用logback实现日志配置"><a href="#Spring-boot使用logback实现日志配置" class="headerlink" title="Spring boot使用logback实现日志配置"></a>Spring boot使用logback实现日志配置</h2><p>在pom.xml中添加依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- lombok --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建日志文件：LoggerTest-java"><a href="#创建日志文件：LoggerTest-java" class="headerlink" title="创建日志文件：LoggerTest.java"></a>创建日志文件：LoggerTest.java</h3><p>在里面有两种写法<br><code>第一种方法</code>：在日志类里面都必须添加上：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private final Logger logger &#x3D; LoggerFactory.getLogger(LoggerTest.class);@RunWith(SpringRunner.class)@SpringBootTestpublic class LoggerTest &#123;private final Logger logger &#x3D; LoggerFactory.getLogger(LoggerTest.class);@Testpublic void test()&#123;logger.debug(&quot;debug&quot;);logger.info(&quot;info&quot;);logger.error(&quot;error&quot;);&#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：这种方法每次用日志的时候都得写当前类</p><p><code>第二种方法</code>：加上<code>@Slf4j</code>这个注解</p><p>如果在info/warn/….中加上内容，有两种方法<br>第一种方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RunWith(SpringRunner.class)@SpringBootTest@Slf4jpublic class LoggerTest &#123;@Testpublic void test()&#123;String name &#x3D; &quot;jack&quot;;String password &#x3D; &quot;123456&quot;;log.info(&quot;name: &quot;+ name+&quot;, &quot;+&quot;password: &quot;+password);        log.debug(&quot;debug&quot;);        log.error(&quot;error &quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果是需要输出多个name和password，会比较麻烦</p><p>第二种方法：<code>log.info(&quot;name: &#123;&#125;,password:&#123;&#125;&quot;,name,password);</code></p><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><ol><li>需要满足的需求是区分info和error日志，</li><li>每天产生一个日志文件，采用两种方式配置，<br>一种是通过application.yml，另一种是通过logback-spring.xml配置。</li><li>1 application.yml<pre class="line-numbers language-none"><code class="language-none">logging:  pattern:    console: &quot;%d - %msg%n&quot;  file:    path: D:\0log  level: debug  #指定日志级别<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在进行第二种配置方式之前，先把application.yml中的配置注释掉</li><li>2  logback-spring.xml配置<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 配置控制台日志输出 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>consolelog<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.PatternLayout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d -%msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--  配置文件日志输出--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileInfoLog<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>ERROR<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">></span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">></span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 滚动策略 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 路径 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>自己的路径/info.%d.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileErrorLog<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.ThresholdFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>ERROR<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 滚动策略 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 路径 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>自己的路径/error.%d.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>consolelog<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileInfoLog<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileErrorLog<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>剩余的参考下<a href="https://www.bilibili.com/read/cv4547836/">https://www.bilibili.com/read/cv4547836/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 点餐项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点餐项目 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
