<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/"/>
      <url>2021/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hi.md</title>
      <link href="2021/01/07/hi-md/"/>
      <url>2021/01/07/hi-md/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;        ListNode l1 &#x3D; new ListNode(-1);        ListNode l2 &#x3D; new ListNode(-1);        ListNode cur &#x3D; head;        ListNode small &#x3D; l1;        ListNode large &#x3D; l2;        while(cur!&#x3D;null)&#123;            if(cur.val&lt;x)&#123;                small.next &#x3D;cur;                small &#x3D; small.next;            &#125;else&#123;                large.next &#x3D; cur;                large &#x3D; large.next;            &#125;            cur &#x3D; cur.next;        &#125;        large.next &#x3D; null;        small.next &#x3D; l2.next;        return l1.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>与链表的初相识💗</title>
      <link href="2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
      <url>2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5 align = 'center'><p>  啦啦啦啦啦啦啦啦啦   </p><p>实验室的小伙伴一直在实验室打电话<br>哎 生活不易 猪猪叹气  </p><p>既然不能专心刷题，  </p><p>那就来和链表这串串🚪，巩固巩固友情把 </p><p>～～～<br></font >  </p><hr><font color = 'pink' size = 3> <p>👇 先来一道简单的   </p><p>调整调整心态  </p></font>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️<h2 id="哑节点"><a href="#哑节点" class="headerlink" title="哑节点"></a>哑节点</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p>删除链表中等于给定值 val 的<strong>所有节点</strong>。<br>示例:<br>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5<br><code>这道题太简单了就弄个哑节点  然后遍历链表  只要遇到相同的就把当前元素的pre指向cur的next即可.哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode removeElements(ListNode head, int val) &#123;        ListNode dummy &#x3D; new ListNode(-1);        dummy.next &#x3D; head;        ListNode cur &#x3D; head,pre &#x3D; dummy;        while(cur!&#x3D;null)&#123;            if(cur.val!&#x3D;val)&#123;                pre &#x3D; cur ;            &#125;else&#123;                pre.next &#x3D; cur.next ;            &#125;            cur &#x3D; cur.next;        &#125;        return dummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。<br>注意：此题对比原题有改动<br>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode deleteNode(ListNode head, int val) &#123;    ListNode dummy &#x3D; new ListNode(-1);    dummy.next &#x3D; head;    ListNode pre &#x3D; dummy,cur&#x3D; head;    while(cur !&#x3D;null &amp;&amp;cur.val!&#x3D;val)&#123;        pre&#x3D; cur;        cur&#x3D; cur.next;    &#125;    if(cur&#x3D;&#x3D;null) return head;    pre.next&#x3D;cur.next;    return dummy.next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h3><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点<br>现有一个链表 – head = [4,5,1,9]，它可以表示为:<br><img src=https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png  /><br>输入：head = [4,5,1,9], node = 5<br>输出：[4,1,9]<br>解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p><code>为了利用node.next=node.next.next;  </code><br><code>就把node.next节点替换node的val</code><br><code>删除的其实是node.next节点</code><br><img src=https://pic.leetcode-cn.com/ec23cc1b03e264cf28c84133699326b6f8f2479c0acfaa1d56efee876c43bb1f-image.png  /></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void deleteNode(ListNode node) &#123;    node.val &#x3D;node.next.val;    node.next&#x3D;node.next.next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️</p><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.</p><p><code>将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00，比如 987 + 23 = 987 + 023 = 1010 每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值</code><br><code>如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1</code><br><code>**小技巧**：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode addTwoNumbers(ListNode head1, ListNode head2) &#123;        ListNode nummy &#x3D; new ListNode(0);        ListNode cur &#x3D; nummy,l1&#x3D;head1,l2&#x3D;head2;        int carry &#x3D; 0 ;        while(l1!&#x3D;null||l2!&#x3D;null)&#123;            int num1 &#x3D; l1!&#x3D;null?l1.val:0;            int num2 &#x3D; l2!&#x3D;null?l2.val:0;            int sum &#x3D; num1+num2+carry;            carry&#x3D;sum&#x2F;10;            cur.next&#x3D;new ListNode(sum%10);            cur&#x3D;cur.next;            if(l1!&#x3D;null) l1&#x3D;l1.next;            if(l2!&#x3D;null) l2&#x3D;l2.next;        &#125;        if(carry&gt;0)  cur.next &#x3D; new ListNode(carry);        return nummy.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        if(l1&#x3D;&#x3D;null) return l2;        if(l2&#x3D;&#x3D;null) return l1;        ListNode nummy &#x3D; new ListNode(-1);        ListNode p &#x3D; nummy;&#x2F;&#x2F;因为Nummy是亚节点 固定的，弄一个游标        while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null)&#123;            if(l1.val&lt;&#x3D;l2.val)&#123;                p.next&#x3D;l1;                l1&#x3D;l1.next;            &#125;else&#123;                p.next&#x3D;l2;                l2&#x3D;l2.next;            &#125;            p&#x3D;p.next;        &#125;        p.next&#x3D;(l1&#x3D;&#x3D;null)?l2:l1;        return nummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️</p><hr><font color = 'pink' size = 3> <p>👇 小的串一串，大的串一串，最后两串连一串……</p></font>---<p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️</p><h3 id="86-分隔链表-下一道题变形题"><a href="#86-分隔链表-下一道题变形题" class="headerlink" title="86. 分隔链表(下一道题变形题)"></a>86. 分隔链表(下一道题变形题)</h3><p>给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。<br><strong>你应当保留两个分区中每个节点的初始相对位置。</strong><br>输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5<br><code>遍历结束后，我们将large的next 指针置空，</code><br><code>这是因为当前节点复用的是原链表的节点，而其next 指针可能指向一个小于 x 的节点，我们需要切断这个引用</code><br><font color = 'MediumSlateBlue' size = 3><br>large最后是合并链表的最后一个元素，最后一个元素的next指向null<br>如果最后一个large刚好指向一个small的节点，就会有环了<br></font></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;        ListNode l1 &#x3D; new ListNode(-1);        ListNode l2 &#x3D; new ListNode(-1);        ListNode cur &#x3D; head;        ListNode small &#x3D; l1;        ListNode large &#x3D; l2;        while(cur!&#x3D;null)&#123;            if(cur.val&lt;x)&#123;                small.next &#x3D;cur;                small &#x3D; small.next;            &#125;else&#123;                large.next &#x3D; cur;                large &#x3D; large.next;            &#125;            cur &#x3D; cur.next;        &#125;        large.next &#x3D; null;        small.next &#x3D; l2.next;        return l1.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️<br><strong>嘟嘟嘟嘟嘟嘟，还有和他相似的一道题</strong></p><hr><h3 id="面试题-02-04-分割链表（类似下一道）"><a href="#面试题-02-04-分割链表（类似下一道）" class="headerlink" title="面试题 02.04. 分割链表（类似下一道）"></a>面试题 02.04. 分割链表（类似下一道）</h3><p>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。<br><code>题目要求是只要把小于x的数移动到所有x的左方就行,没有顺序要求，而且等于x,大于x这些元素没有要求！</code></p><p><strong>所以运用双指针</strong>,<br>    <code>第一个指针落在不小于x的节点上,第二个向前移动。如果第二个指针遇到小于x的节点,交换二者的值,然后第一个指针指向next。第二个指针肯定走得更快,所以第一个指针一直处于不小于x的节点的位置，或者就是两个指针重叠,这时候还是礼貌性地交换一下罢了。</code></p><p> // [1, 4, 3, 2, 5, 2]. prev = 1, cur = 1<br> // [1, 4, 3, 2, 5, 2]. prev = 1, cur = 1 小于,交换二者,没有变化<br> // [1, 4, 3, 2, 5, 2]. prev = 4, cur = 4 继续往后next<br> // [1, 4, 3, 2, 5, 2]. prev = 4, cur = 3 无序交换, 只修改cur指针<br> // [1, 4, 3, 2, 5, 2]. prev = 4, cur = 2 同上<br> // [1, 2, 3, 4, 5, 2]. prev = 2, cur = 4 2 &lt; 3,交换二者<br> // [1, 2, 3, 4, 5, 2]. prev = 3, cur = 5 二者同时往后next<br> // [1, 2, 3, 4, 5, 2]. prev = 3, cur = 2<br> // [1, 2, 2, 4, 5, 3] over</p><p>`</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;        ListNode cur &#x3D; head, prev &#x3D; head;        while (cur !&#x3D; null) &#123;            if (cur.val &lt; x) &#123;                int tmp &#x3D; prev.val;                prev.val &#x3D; cur.val;                cur.val &#x3D; tmp;                prev &#x3D; prev.next;            &#125;            cur &#x3D; cur.next;        &#125;        return head;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><font color = 'MediumSlateBlue' size = 3> 其实有没有感觉这两道题思路挺相像的，都是双指针然后用一个指针表示小于的数或者奇数的位置，当满足条件是做处理然后移动该指针和遍历的指针，如果不满足条件仅仅只是移动遍历的指针；</font><h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h3><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] exchange(int[] nums) &#123;        int i &#x3D; 0 ;         for(int j &#x3D; 0 ; j &lt; nums.length;j++)&#123;             if(nums[j]%2!&#x3D;0)&#123;                 int tmp &#x3D; nums[j];                 nums[j]&#x3D;nums[i];                 nums[i]&#x3D;tmp;                 i++;             &#125;         &#125;         return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️🏷️</p><h3 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode reverseList(ListNode head) &#123;        if(head&#x3D;&#x3D;null) return null;        ListNode pre&#x3D; null;        ListNode cur &#x3D; head;        while(cur!&#x3D;null)&#123;            ListNode tmp &#x3D; cur.next;            cur.next &#x3D; pre ;            pre &#x3D; cur;            cur &#x3D; tmp;        &#125;        return pre ;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="234-回文链表（面试题-02-06-回文链表-）"><a href="#234-回文链表（面试题-02-06-回文链表-）" class="headerlink" title="234. 回文链表（面试题 02.06    回文链表  ）"></a>234. 回文链表（面试题 02.06    回文链表  ）</h3><p>请判断一个链表是否为回文链表。<br>输入: 1-&gt;2<br>输出: false<br>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br><code>整个流程可以分为以下五个步骤</code>：<br><code>找到前半部分链表的尾节点。</code><br><code>反转后半部分链表。</code><br><code>判断是否回文。</code><br><code>恢复链表</code>。<br><code>返回结果。</code></p><p><code>我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</code></p><p><code>若链表有奇数个节点，则中间的节点应该看作是前半部分。</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return true;       &#x2F;&#x2F;找到第一个链表的末尾节点        ListNode last&#x3D;findMid(head);       &#x2F;&#x2F;反转第二个链表,start是第二个链表的首节点        ListNode start&#x3D;reverse(last.next);        ListNode l1 &#x3D; head;        ListNode l2 &#x3D; start;        boolean ans &#x3D; true;        while(ans&amp;&amp;l2!&#x3D;null)&#123;            if(l1.val!&#x3D;l2.val) ans &#x3D; false;            l1&#x3D;l1.next;            l2&#x3D;l2.next;        &#125;        &#x2F;&#x2F;回复链表        last.next &#x3D; reverse(start);        return ans;    &#125;    &#x2F;&#x2F;快慢指针    &#x2F;&#x2F;如果是奇数的话正好是中间的节点    &#x2F;&#x2F;如果是偶数的话-左中位数 比如1234 返回2    public ListNode findMid(ListNode head)&#123;        ListNode slow &#x3D; head;        ListNode fast &#x3D; head;        while(fast.next!&#x3D;null&amp;&amp;fast.next.next!&#x3D;null)&#123;            slow &#x3D; slow.next;            fast &#x3D; fast.next.next;        &#125;        return slow;    &#125;    &#x2F;&#x2F;反转链表 返回首节点    public ListNode reverse(ListNode head)&#123;        ListNode cur &#x3D; head,pre &#x3D; null;        while(cur!&#x3D;null)&#123;            ListNode next &#x3D; cur.next;            cur.next &#x3D; pre;            pre &#x3D; cur;            cur &#x3D; next;        &#125;        return pre;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><hr><p><code>下面两道题参考大佬的图解很明白 </code><br><code>https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-by-ac_fun-zshd/</code><br>💗💗💗💗💗💗💗💗</p><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><p>给定一个链表，判断链表中是否有环。</p><p><code>经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</code><br><code>因为快指针移动速度是慢指针的2倍，那么当链表中有环时，则快指针会在环中与慢指针相遇。</code><br><code>第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）</code><br><img src =https://pic.leetcode-cn.com/1609224521-roALTq-image.png /></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean hasCycle(ListNode head) &#123;        ListNode slow &#x3D; head,fast &#x3D; head;        while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null)&#123;            slow&#x3D;slow.next;            fast&#x3D;fast.next.next;            if(slow&#x3D;&#x3D;fast) return true;        &#125;        return false;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><img src=https://pic.leetcode-cn.com/1609224575-xrjBjO-image.png /><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode detectCycle(ListNode head) &#123;        ListNode slow &#x3D; head,fast &#x3D; head;        while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null)&#123;            fast&#x3D;fast.next.next;            slow&#x3D;slow.next;            if(fast&#x3D;&#x3D;slow) break;        &#125;        if(fast&#x3D;&#x3D;null||fast.next&#x3D;&#x3D;null) return null;        fast &#x3D; head;        while(fast!&#x3D;slow)&#123;            fast&#x3D;fast.next;            slow&#x3D;slow.next;        &#125;        return fast;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p><code>pA走过的路径为A链+B链,pB走过的路径为B链+A链</code><br><code>pA和pB走过的长度都相同，都是A链和B链的长度之和，</code><br><code>相当于将两条链从尾端对齐，</code><br><code>如果相交，则会提前在相交点相遇，如果没有相交点，</code><br><code>则会在最后相遇</code></p><p><img src="1.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        &#x2F;&#x2F;两个链表相交，相交后的长度是相同的。此时需要消除链表的长度差        if(headA&#x3D;&#x3D;null||headB&#x3D;&#x3D;null) return null;        ListNode ha&#x3D;headA,hb&#x3D;headB;        while(ha!&#x3D;hb)&#123;            ha&#x3D;(ha&#x3D;&#x3D;null)?headB:ha.next;            hb&#x3D;(hb&#x3D;&#x3D;null)?headA:hb.next;        &#125;        return ha;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.<br><code>使用快慢指针的思路</code><br><code>一开始快指针和慢指针都指向链表头</code><br><code>然后让快指针先走k步，走完k步之后让快指针和慢指针一起走</code><br><code>最后慢指针所指向的位置就是n-k的位置，即倒数第k个节点</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode getKthFromEnd(ListNode head, int k) &#123;        ListNode fast &#x3D; head;        ListNode slow &#x3D; head;        for(int i &#x3D; 0;i&lt;&#x3D;k-1;i++)&#123;            fast&#x3D;fast.next;        &#125;        while(fast!&#x3D;null)&#123;            fast&#x3D;fast.next;            slow&#x3D;slow.next;        &#125;        return slow;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><font color = 'Red' size = 5 align = 'center'><p>到现在为止呢 ，上面的十三道题目算是入门了叭～～～  </p><p>给自己鼓个掌👏  </p></font><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>剑指 Offer 06. 从尾到头打印链表<br>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。<br>输入：head = [1,3,2]<br>输出：[2,3,1]</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int[] reversePrint(ListNode head) &#123;        LinkedList&lt;Integer&gt; stack &#x3D; new LinkedList&lt;&gt;();        ListNode cur &#x3D; head;        while(cur!&#x3D;null)&#123;            stack.addLast(cur.val);            cur&#x3D;cur.next;        &#125;        int[] ans &#x3D;new int[stack.size()];        for(int i &#x3D; 0 ; i &lt; ans.length;i++)&#123;            ans[i]&#x3D;stack.removeLast();        &#125;        return ans;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与链表的再相识💗</title>
      <link href="2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A81/"/>
      <url>2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A81/</url>
      
        <content type="html"><![CDATA[<hr><font color = 'gold' size = 5 align = 'center'><p>  啦啦啦啦啦啦啦啦啦   </p><p>前面都是比较基础的题目<br>根据上面这些知识再来几道把～<br>学以致用</p><p>～～～<br></font >  </p><hr><p>本文的图参考<br><code>https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/</code><br>–</p><h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h3><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，<strong>这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</strong><br>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p><hr><h4 id="解法1-哑节点的设置"><a href="#解法1-哑节点的设置" class="headerlink" title="解法1: 哑节点的设置"></a>解法1: 哑节点的设置</h4><p><code>类似前面的分割链表  设置哑节点的值  但是注意这里的话需要设置一个evenflag 来判断当前节点是奇数节点还是偶数节点</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode oddEvenList(ListNode head) &#123;        if(head&#x3D;&#x3D;null) return head;        ListNode odddummy &#x3D; new ListNode(-1);        ListNode evendummy &#x3D; new ListNode(-1);        ListNode cur  &#x3D; head;        ListNode odd &#x3D; odddummy;        ListNode even &#x3D; evendummy;        boolean evenflag &#x3D; true;        while(cur!&#x3D;null)&#123;            if(evenflag)&#123;                odd.next &#x3D; cur;                odd&#x3D;odd.next;                evenflag &#x3D; false;            &#125;else&#123;                even.next &#x3D; cur;                even &#x3D; even.next;                evenflag &#x3D; true;            &#125;            cur&#x3D;cur.next;        &#125;        even.next&#x3D;null;        odd.next&#x3D; evendummy.next;        return odddummy.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法2-双指针"><a href="#解法2-双指针" class="headerlink" title="解法2: 双指针"></a>解法2: 双指针</h4><img src = https://pic.leetcode-cn.com/1605227711-BsDKjR-image.png /><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode oddEvenList(ListNode head) &#123;        if(head&#x3D;&#x3D;null) return head;        ListNode odd &#x3D; head;        ListNode even &#x3D; head.next;        ListNode evenHead &#x3D; head.next;        while(even!&#x3D;null&amp;&amp;even.next!&#x3D;null)&#123;            odd.next &#x3D; even.next;            odd &#x3D; even.next;            even.next &#x3D; odd.next;            even &#x3D; odd.next;        &#125;        odd.next &#x3D; evenHead;        return head;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="876-链表的中间结点-快慢指针"><a href="#876-链表的中间结点-快慢指针" class="headerlink" title="876. 链表的中间结点 快慢指针"></a>876. 链表的中间结点 快慢指针</h3><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p><hr><p><code>快指针能继续走的时候继续走就行,区别左中间节点的条件是fast.next!=null&amp;&amp;fast.next.next!=null</code><br><img  src =https://pic.leetcode-cn.com/1606462980-RIpDUY-file_1606462980633 /><br> <pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode middleNode(ListNode head) &#123;        ListNode slow &#x3D; head,fast&#x3D;head;        while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null)&#123;            slow&#x3D;slow.next;            fast&#x3D;fast.next.next;        &#125;        return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><hr><h3 id="24-两两交换链表中的节点-哑节点"><a href="#24-两两交换链表中的节点-哑节点" class="headerlink" title="24. 两两交换链表中的节点 哑节点"></a>24. 两两交换链表中的节点 哑节点</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]<br><img   src= https://pic.leetcode-cn.com/42c91b69e3f38d63a0d0153c440724e69bd2d24b95091b4dcc5c68172f8f4e1e-%E8%BF%AD%E4%BB%A3.gif    /></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode dummy &#x3D; new ListNode(-1);        dummy.next &#x3D; head;        ListNode cur &#x3D; head;        ListNode pre &#x3D; dummy;        while(cur!&#x3D;null&amp;&amp;cur.next!&#x3D;null)&#123;            ListNode first &#x3D; cur;            ListNode second &#x3D; cur.next;            pre.next &#x3D; second;            first.next &#x3D; second.next;            second.next &#x3D; first;            pre &#x3D; first;            cur &#x3D; first.next;&#x2F;&#x2F;为下一轮作准备        &#125;        return dummy.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-删除链表的倒数第N个节点-剑指-Offer-22-链表中倒数第k个节点-快慢指针-哑节点"><a href="#19-删除链表的倒数第N个节点-剑指-Offer-22-链表中倒数第k个节点-快慢指针-哑节点" class="headerlink" title="19. 删除链表的倒数第N个节点(剑指 Offer 22. 链表中倒数第k个节点) 快慢指针 哑节点"></a>19. 删除链表的倒数第N个节点(剑指 Offer 22. 链表中倒数第k个节点) 快慢指针 哑节点</h3><p>给定一个链表，<strong>删除链表的倒数第 n 个节点，</strong>并且返回链表的头结点。<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy &#x3D; new ListNode(-1);        dummy.next &#x3D; head;        ListNode fast &#x3D; dummy;        ListNode slow &#x3D; dummy;        for(int i &#x3D; 0 ; i&lt; n;i++)&#123;            fast &#x3D; fast.next;        &#125;        &#x2F;&#x2F;这里fast.next!&#x3D;null走完的话就找到了倒数第k个节点的前一个节点        while(fast.next!&#x3D;null)&#123;            slow&#x3D;slow.next;            fast&#x3D;fast.next;        &#125;        slow.next&#x3D;slow.next.next;        return dummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><p><strong>反转从位置 m 到 n 的链表</strong>。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。<br><code>第一步：找到待反转节点的前一个节点</code>。<br><code>第二步：反转m到n这部分。</code><br><code>第三步：将反转的起点的next指向反转的后面一部分。</code><br><code>第四步：将第一步找到的节点指向反转以后的头节点。</code><br><img src = https://pic.leetcode-cn.com/3158b23f7e6919d47a11a2f57e921b5645fceb84212450336f2256f5659fa9e7.jpg /><br>参考链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/ji-bai-liao-100de-javayong-hu-by-reedfan-6/">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/ji-bai-liao-100de-javayong-hu-by-reedfan-6/</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode reverseBetween(ListNode head, int m, int n) &#123;        ListNode dummy &#x3D; new ListNode(-1);        dummy.next &#x3D; head;        ListNode node &#x3D; dummy;        for(int i &#x3D; 0 ;i&lt;m-1;i++)&#123;            node&#x3D;node.next;        &#125;        ListNode reverseHead &#x3D; node.next;        ListNode pre &#x3D; null;        ListNode cur &#x3D; reverseHead;        for(int i &#x3D; m ;i &lt;&#x3D;n;i++)&#123;            ListNode next &#x3D; cur.next;            cur.next &#x3D; pre;            pre &#x3D; cur;            cur &#x3D; next;        &#125;         reverseHead.next &#x3D; cur;        node.next &#x3D; pre;        return dummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="83-删除排序链表中的重复元素-双指针"><a href="#83-删除排序链表中的重复元素-双指针" class="headerlink" title="83. 删除排序链表中的重复元素 双指针"></a>83. 删除排序链表中的重复元素 双指针</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode deleteDuplicates(ListNode head) &#123;        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return head;        ListNode cur &#x3D; head;        while(cur!&#x3D;null&amp;&amp;cur.next!&#x3D;null)&#123;            if(cur.val&#x3D;&#x3D;cur.next.val)&#123;                cur.next&#x3D;cur.next.next;            &#125;else&#123;                cur &#x3D; cur.next;            &#125;        &#125;        return head;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h3><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br>示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3<br><code>这道题是自己想的解法  艾码  这段代码调了得有一个多小时  记录一下</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ListNode deleteDuplicates(ListNode head) &#123;        ListNode dummy &#x3D;new ListNode(-1);        ListNode pre &#x3D;dummy;        ListNode cur &#x3D;head;        while(cur!&#x3D;null)&#123;            if(cur.next!&#x3D;null&amp;&amp;cur.val!&#x3D;cur.next.val)&#123;                pre.next &#x3D; new ListNode(cur.val);                pre &#x3D; pre.next;            &#125;            &#x2F;&#x2F;当条件成立是说明当前cur是最后一个值，且和前面的都不相等            if(cur.next&#x3D;&#x3D;null)&#123;                pre.next &#x3D; new ListNode(cur.val);                            &#125;            int val &#x3D; cur.val;            &#x2F;&#x2F;把所有相同的值都跳过去            while(cur!&#x3D;null&amp;&amp;val&#x3D;&#x3D;cur.val)&#123;                cur&#x3D;cur.next;            &#125;                    &#125;        return dummy.next;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p><hr><p><code>参考https://leetcode-cn.com/problems/rotate-list/solution/dong-tu-suan-fa-xuan-zhuan-lian-biao-si-chong-ji-3/</code><br>    <code>当然也可以直接把链表转成环，然后在环中找到k的位置将其打断～</code></p><img src=https://pic.leetcode-cn.com/221a9b004ce8b55e7e190789711850154408609d1af11881e48680c65f5e32f1-file_1597038479852 /><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode rotateRight(ListNode head, int k) &#123;        &#x2F;&#x2F; 思路：先将链表连成一个环，在找断点        &#x2F;&#x2F; 先考虑边界情况        if(head &#x3D;&#x3D; null)&#123;            return null;        &#125;        ListNode tmp &#x3D; head;        &#x2F;&#x2F; 找到链表最后一个节点        int length &#x3D; 1;        while(tmp.next !&#x3D; null)&#123;            tmp &#x3D; tmp.next;            length ++;        &#125;        tmp.next &#x3D; head;  &#x2F;&#x2F; 构成一个环        ListNode c_list &#x3D; head;  &#x2F;&#x2F; 头结点        ListNode prev &#x3D; tmp; &#x2F;&#x2F; 设置尾结点        &#x2F;&#x2F; 通过循环找到新的头结点，向右转n次则需要next length-k%length 次        for(int i&#x3D;1; i&lt;&#x3D;length - k%length; i++)&#123;            c_list &#x3D; c_list.next;            prev &#x3D; prev.next;        &#125;        prev.next &#x3D; null;        return c_list;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h3><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:<br>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.  </p><hr><p><code>寻找链表中点 + 链表逆序 + 合并链表</code><br><code>注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。</code></p><p><code>这样我们的任务即可划分为三步： 找到原链表的中点（参考「876. 链表的中间结点」）。 我们可以使用快慢指针来 O(N)地找到链表的中间节点。 将原链表的右半端反转（参考「206. 反转链表」）。 将原链表的两端合并。 因为两链表长度相差不超过 1，因此直接合并即可。</code><br>`</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public void reorderList(ListNode head) &#123;        if(head&#x3D;&#x3D;null) return ;        ListNode left &#x3D; head;        ListNode mid &#x3D; findMid(head);        ListNode right &#x3D; mid.next;        mid.next&#x3D;null;&#x2F;&#x2F;很重要 别忘了        right &#x3D; reverse(right);        merge(left,right);    &#125;    &#x2F;&#x2F;返回左中节点    public ListNode findMid(ListNode head)&#123;        ListNode fast &#x3D; head;        ListNode slow &#x3D; head;        while(fast.next!&#x3D;null&amp;&amp;fast.next.next!&#x3D;null)&#123;            fast&#x3D;fast.next.next;            slow&#x3D;slow.next;        &#125;        return slow;    &#125;    public ListNode reverse(ListNode head)&#123;        if(head&#x3D;&#x3D;null) return null;        ListNode pre &#x3D; null;        ListNode cur &#x3D; head;        while(cur!&#x3D;null)&#123;            ListNode next &#x3D; cur.next;            cur.next&#x3D; pre;            pre &#x3D;cur;            cur&#x3D;next;        &#125;        return pre;    &#125;    public void merge(ListNode left,ListNode right)&#123;        ListNode l1 &#x3D;left;        ListNode l2&#x3D; right;        while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null)&#123;            ListNode l1next &#x3D; l1.next;            ListNode l2next &#x3D; l2.next;            l1.next &#x3D; l2;            l2.next&#x3D;l1next;            l1 &#x3D; l1next;            l2&#x3D;l2next;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>递归版本</strong> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode sortList(ListNode head) &#123;        &#x2F;&#x2F;归并排序        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return head;        ListNode slow &#x3D; head;        ListNode fast &#x3D; head;        ListNode first &#x3D; head;        while(fast.next!&#x3D;null&amp;&amp;fast.next.next!&#x3D;null)&#123;            fast &#x3D; fast.next.next;            slow &#x3D; slow.next;        &#125;        ListNode second &#x3D; slow.next;        slow.next&#x3D;null;        first &#x3D; sortList(first);        second &#x3D; sortList(second);        ListNode node &#x3D; merge(first,second);        return node;    &#125;    public ListNode merge(ListNode first,ListNode second)&#123;        ListNode l1&#x3D;first;        ListNode l2 &#x3D; second;        ListNode dummy &#x3D; new ListNode(-1);        ListNode cur &#x3D; dummy;        while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null)&#123;            if(l1.val&lt;l2.val)&#123;                cur.next &#x3D; l1;                l1&#x3D;l1.next;            &#125;else&#123;                cur.next&#x3D;l2;                l2&#x3D;l2.next;            &#125;            cur &#x3D; cur.next;        &#125;        cur.next &#x3D; (l1&#x3D;&#x3D;null)?l2:l1;        return dummy.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组刷题笔记</title>
      <link href="2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
      <url>2021/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 4>今天想复习一下以前刷过的数组题目    <p>练练手感  </p><p>找找数组的感觉  </p><p>和数组成为好朋友的第一天，哈哈哈哈<br>～～～<br></font >  </p><hr><font color = 'pink' size = 3>双指针  💗  <p>👇<br></font></p><hr><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。<br>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p><hr><p><strong>思路</strong><br><code>数组其实是有序的， 只不过负数平方之后可能成为最大数了。 那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。 此时可以考虑双指针法了，i指向其实位置，j指向终止位置。 定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。 </code><br>参考大佬动图<br>–原链接<br><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/977-you-xu-shu-zu-de-ping-fang-pai-xu-shuang-zhi-z/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/977-you-xu-shu-zu-de-ping-fang-pai-xu-shuang-zhi-z/</a></p><img src=https://pic.leetcode-cn.com/1602811839-xiaxXW-977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif  /><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int[] sortedSquares(int[] nums) &#123;        int i &#x3D; 0 ,j &#x3D; nums.length -1;        int k &#x3D; nums.length-1;        int[] arr &#x3D; new int[nums.length];        while(i&lt;&#x3D;j)&#123;            if(nums[i]+nums[j]&lt;0)&#123;                arr[k--]&#x3D;nums[i]*nums[i++];            &#125;else&#123;                arr[k--]&#x3D;nums[j]*nums[j--];            &#125;        &#125;        return arr;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><font color = 'pink' size = 3>双指针  💗  <p>👇<br></font></p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><hr><p><code>top题库</code><br>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>输入：<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出：[1,2,2,3,5,6]</p><hr><p><strong>思路</strong><br><code>从后往前遍历数组：</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void merge(int[] nums1, int m, int[] nums2, int n) &#123;       int i &#x3D; nums1.length-1;       m--;n--;       while(m&gt;&#x3D;0&amp;&amp;n&gt;&#x3D;0)&#123;           nums1[i--]&#x3D;nums1[m]&gt;&#x3D;nums2[n]?nums1[m--]:nums2[n--];       &#125;       while(n&gt;&#x3D;0)&#123;           nums1[i--]&#x3D;nums2[n--];       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><strong>思路</strong><br>    <code>参考快速排序 partition过程</code></p><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><p><code>top题库</code><br>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>你能想出一个仅使用<strong>常数空间</strong>的一趟扫描算法吗？<br>示例 1：<br>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]</p><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public void sortColors(int[] nums) &#123;        partition(nums,0,nums.length-1,1);    &#125;    public void partition(int[] nums,int l , int r, int pivot)&#123;        int start &#x3D; l-1;        int end &#x3D; r+1;        int i &#x3D; 0;        while(i&lt;end)&#123;            if(nums[i]&lt;pivot)&#123;                swap(nums,++start,i++);            &#125;else if(nums[i]&#x3D;&#x3D;pivot)&#123;                i++;            &#125;else&#123;                swap(nums,--end,i);            &#125;        &#125;    &#125;    public void swap(int[] nums , int i , int j )&#123;        int tmp &#x3D; nums[i];        nums[i] &#x3D; nums[j];        nums[j] &#x3D; tmp;     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="面试题-16-16-部分排序"><a href="#面试题-16-16-部分排序" class="headerlink" title="面试题 16.16. 部分排序"></a>面试题 16.16. 部分排序</h2><p>给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。<br>输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]<br>输出： [3,9]</p><hr><p><strong>思路</strong><br>    <code>    也是双指针，     l的值就是从后往前遍历数组，找到比min大的元素就更新l的值，找到和min小的元素就更新min的值     r的值就是从左往➡️遍历数组，找到比max大的元素就更新max的值，找到和min小的元素就更新r的值    </code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] subSort(int[] array) &#123;        if(array.length&#x3D;&#x3D;0) return new int[]&#123;-1,-1&#125;;        int l &#x3D; -1;        int r &#x3D; -1;        &#x2F;&#x2F;从左往后找r的值         int max &#x3D; array[0];        for(int i &#x3D; 1; i &lt; array.length ; i ++ )&#123;            if(array[i]&gt;&#x3D;max)&#123;                max &#x3D; array[i];            &#125;else&#123;                r &#x3D; i;            &#125;        &#125;        if(r&#x3D;&#x3D;-1) return new int[]&#123;-1,-1&#125;;        &#x2F;&#x2F;从后往左找l的值         int min &#x3D; array[array.length-1];        for(int j &#x3D; array.length -2;j&gt;&#x3D;0;j--)&#123;            if(array[j]&lt;&#x3D;min)&#123;                min&#x3D;array[j];            &#125;else&#123;                l &#x3D; j;            &#125;        &#125;        return new int[]&#123;l,r&#125;;    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP工作原理以及HTTP1.0-HTTP3版本的改进</title>
      <link href="2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"/>
      <url>2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#http-10">HTTP-1.0</a><ul><li><a href="#http-10%E4%BC%98%E7%BC%BA%E7%82%B9">HTTP-1.0优缺点</a></li><li><a href="#http%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84">Http为什么是无连接和无状态的</a></li></ul></li><li><a href="#http-11">HTTP-1.1</a><ul><li><a href="#http11%E7%9B%B8%E5%AF%B9%E4%BA%8Ehttp10%E6%94%B9%E5%96%84">HTTP/1.1相对于HTTP1.0改善</a></li><li><a href="#http11%E7%BC%BA%E7%82%B9">HTTP1.1缺点</a></li></ul></li><li><a href="#http-2">HTTP-2</a><ul><li><a href="#http2-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96">HTTP/2 做了什么优化</a></li><li><a href="#http2%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%BA%E9%99%B7">HTTP/2有哪些缺陷</a></li></ul></li><li><a href="#http-3">HTTP-3</a><ul><li><a href="#http3%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96">HTTP/3做了哪些优化</a></li></ul></li><li><a href="#http%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86">HTTP基本知识</a><ul><li><a href="#http%E8%AF%B7%E6%B1%82%E7%BB%84%E6%88%90">HTTP请求组成</a></li><li><a href="#get%E4%B8%8Epost">Get与Post</a></li><li><a href="#%E7%8A%B6%E6%80%81%E7%A0%81">状态码</a></li></ul></li><li><a href="#%E4%B8%80%E4%B8%AA-tcp-%E8%BF%9E%E6%8E%A5%E5%90%8E%E6%98%AF%E5%90%A6%E4%BC%9A%E5%9C%A8%E4%B8%80%E4%B8%AA-http-%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%90%8E%E6%96%AD%E5%BC%80%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%96%AD%E5%BC%80">一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</a></li><li><a href="#uri%E5%92%8Curl%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">URI和URL的区别是什么?</a></li><li><a href="#http%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B">http工作流程-输入网址过程</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%9F%E5%90%8D%E8%A6%81%E5%88%86%E7%BA%A7%E8%AE%BE%E8%AE%A1">为什么域名要分级设计</a></li><li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%8E%9F%E5%9B%A0">重定向原因</a></li></ul></li></ul><!-- /TOC --><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP-1.0"></a>HTTP-1.0</h2><h3 id="HTTP-1-0优缺点"><a href="#HTTP-1-0优缺点" class="headerlink" title="HTTP-1.0优缺点"></a>HTTP-1.0优缺点</h3><p><font color=pink size='3'>I.优点</font></p><ol><li>HTTP基本的报⽂格式就是header + body，头部信息也是key-value简单⽂本的形式。</li><li>HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，<br>都允许开发⼈员⾃定义和扩充。</li><li>HTTP由于是⼯作在应⽤层，则它下层可以随意变化。</li><li>应⽤⼴泛和跨平台</li></ol><p><font color=pink size='3'>II.缺点</font></p><ol><li>⽆状态<br>由于⽆状态，它在完成有关联性的操作时会⾮常麻烦。<br>例如登录-&gt;添加购物⻋-&gt;下单-&gt;结算-&gt;⽀付，这系列操作都要知道⽤户的身份才⾏。<br>但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息。</li><li>明⽂传输<br>明⽂意味着在传输过程中的信息，是可⽅便阅读的，<br>通过浏览器的控制台或抓包软件都可以直接⾁眼查看，<br>信息的内容都毫⽆隐私可⾔，很容易就能被窃取。<h3 id="Http为什么是无连接和无状态的"><a href="#Http为什么是无连接和无状态的" class="headerlink" title="Http为什么是无连接和无状态的"></a>Http为什么是无连接和无状态的</h3></li></ol><p>一.无连接<br>每一个访问都是无连接，<br>服务器挨个处理访问队列里的访问，<br>处理完一个就关闭连接，就结束了，<br>然后处理下一个新的<br>无连接的含义是限制每次连接只处理一个请求。<br>服务器处理完客户的请求，并收到客户的应答后，即断开连接</p><p>二.无状态<br>1.协议对于事务处理没有记忆能力<br>2.对同一个url请求没有上下文关系<br>3.每次的请求都是独立的，<br>  它的执行情况和结果与<br>  前面的请求和之后的请求<br>  是无直接关系的，<br>  它不会受前面的请求应答情况<br>  直接影响，<br>  也不会直接影响后面的请求应答情况</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP-1.1"></a>HTTP-1.1</h2><h3 id="HTTP-1-1相对于HTTP1-0改善"><a href="#HTTP-1-1相对于HTTP1-0改善" class="headerlink" title="HTTP/1.1相对于HTTP1.0改善"></a>HTTP/1.1相对于HTTP1.0改善</h3><ol><li>因为早期HTTP/1.0，那就是每发起⼀个请求需要三次握手四次挥手等等操作，<br>增加了通信开销。为了解决这些问题，<br>HTTP/1.1提出了<code>⻓连接</code>的通信⽅式只要任意⼀端没有明确提出断开连接，<br>则保持 TCP 连接状态。</li><li>HTTP/1.1 采⽤了<code>管道传输</code> 的⽅式，<br>可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，<br>只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，<br>可以减少整体的响应时间。</li><li>HTTP1.0中，存在⼀些浪费带宽的现象，<br>例如客户端只是需要某个对象的⼀部分，⽽服务器却将整个对象送过来了，<br>并且不⽀持断点续传功能，HTTP1.1则在请求头引⼊了range头域，<br>它允许只请求资源的某个部分<!-- 3. 错误状态响应码，HTTP1.1新增了很多错误装填响应码，让开发者更加了解错误根源</li><li>在HTTP1.0中主要使⽤header⾥的<br>If-Modified-Since,Expires来做为缓存判断的标准，<br>在HTTP1.1中引⼊了更多的缓存控制策略 –&gt;</li></ol><h3 id="HTTP1-1缺点"><a href="#HTTP1-1缺点" class="headerlink" title="HTTP1.1缺点"></a>HTTP1.1缺点</h3><ol><li>服务器是按请求的顺序响应的，如果服务器响应慢，<br>会招致客户端⼀直请求不到数据，也就是<code>队头阻塞</code>；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ol><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP-2"></a>HTTP-2</h2><h3 id="HTTP-2-做了什么优化"><a href="#HTTP-2-做了什么优化" class="headerlink" title="HTTP/2 做了什么优化"></a>HTTP/2 做了什么优化</h3><p><code>HTTP/2是基于HTTPS的，所以说HTTP2的安全性也是有保障的</code></p><ol><li>HTTP/2 会压缩头如果你同时发出多个请求，<br>他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。<br>使用HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，<br>⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。</li><li>HTTP/2全⾯采⽤了<code>⼆进制格式</code>，头信息和数据体都是⼆进制，<pre><code>  计算机收到报⽂后，直接解析⼆进制报⽂，这增加了数据传输的效率。</code></pre></li><li>HTTP/2的数据包不是按顺序发送的</li><li>HTTP/2是可以在⼀个连接中并发多个请求或回应。</li><li>HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，<pre><code>   服务不再是被动地响应，也可以`主动向客户端发送消息`。</code></pre></li></ol><h3 id="HTTP-2有哪些缺陷"><a href="#HTTP-2有哪些缺陷" class="headerlink" title="HTTP/2有哪些缺陷"></a>HTTP/2有哪些缺陷</h3><p><code>多个HTTP请求在复⽤⼀个TCP连接</code>，<code>下层的TCP协议是不知道有多少个HTTP请求的</code>。<br>所以⼀旦发⽣了<code>丢包</code>现象，就会触发<code>TCP的重传机制，</code><br>这样在⼀个TCP连接中的<code>所有的 HTTP请求都必须等待这个丢了的包被重传回来</code>。</p><h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP-3"></a>HTTP-3</h2><h3 id="HTTP-3做了哪些优化"><a href="#HTTP-3做了哪些优化" class="headerlink" title="HTTP/3做了哪些优化"></a>HTTP/3做了哪些优化</h3><p>HTTP/3使用基于<code>UDP协议</code>的QUIC协议来实现的</p><p>HTTP/3把HTTP下层的TCP协议改成了UDP</p><p> <code>因为UDP发⽣是不管顺序，也不管丢包的，所以不会出现HTTP/1.1的队头阻塞和HTTP/2的⼀个丢包全部重传问题。</code></p><p>但是由于UDP是不可靠传输的，而基于UDP的QUIC协议可以实现类似TCP的可靠性传输。主要是依赖</p><ol><li>当某个流发⽣丢包时，只会阻塞这个流， 其他流不会受到影响。</li><li>更改了头部压缩算法，升级成了 QPack 。</li><li>QUIC 直接把以往的TCP和TLS/1.3的6次交互合并成了3次，减少了交互次数。</li></ol><h2 id="HTTP基本知识"><a href="#HTTP基本知识" class="headerlink" title="HTTP基本知识"></a>HTTP基本知识</h2><h3 id="HTTP请求组成"><a href="#HTTP请求组成" class="headerlink" title="HTTP请求组成"></a>HTTP请求组成</h3><p><code>一个HTTP请求报文由四个部分组成：请求行、请求头、空行、请求数据。</code></p><ol><li><p>请求行<br>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，<br>它们用空格分隔。比如 GET /data/info.html HTTP/1.1</p></li><li><p>请求头部<br>HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。<br>如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，。<br>常见的请求头字段以及他的含义：</p><ol><li><code>Accept</code>：浏览器可接受的MIME类型。</li><li><code>Accept-Charset</code>：浏览器可接受的字符集。</li><li><code>Accept-Encoding</code>：浏览器能够进行解码的数据编码方式，<pre><code>             比如gzip。Servlet能够向支持gzip的浏览器             返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。</code></pre></li><li><code>Accept-Languag</code>e：浏览器语言种类，</li><li>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头应答</li><li><code>Content-Length</code>：表示请求消息正文的长度。</li><li><code>Host</code>： 客户机告诉服务器，想访问的主机名。</li><li>If-Modified-Since：客户机告诉服务器，资源的缓存时间。</li><li><code>Referer</code>：客户机告诉服务器，它是从哪个资源来访问服务器的(防盗链)。</li><li><code>User-Agent</code>：User-Agent头域的内容包含发出请求的用户信息。</li><li>Cookie：客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一。</li></ol></li><li><p>空行<br>它的作用是通过一个空行，<code>告诉服务器请求头部到此为止</code>。</p></li><li><p>请求数据</p><p>若方法字段是<code>POST</code>,则通常来说此处放置的就是要<code>提交的数据</code></p></li></ol><h3 id="Get与Post"><a href="#Get与Post" class="headerlink" title="Get与Post"></a>Get与Post</h3><ol><li>Get是请求从服务器获取资源，Post用于<code>传输实体本体</code></li><li>get和post请求都能使用额外的<code>参数</code>，<br>get参数是以查询字符串出现在URL中，post参数存储在实体主体中</li><li>Http方法不会改变服务器状态，get方法是<code>安全</code>的，<br>而post由于是传送实体主体内容，这个内容可能是用户上传的表单数据，<br>上传成功后，服务器可能把这个数据存储到数据库中，因此状态也就发生了变化</li><li>get在调用多次时，客户端收到的结果是一样的，所以是幂等；<br>post调用多次，会增加多行记录，不是<code>幂等</code></li></ol><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>2xx （3种）</p><ol><li>200 ：表示从客户端发送给服务器的请求被正常处理并返回；</li><li>204 ：表示客户端发送给客户端的请求得到了成功处理，</li><li>206 ：表示客户端进行了范围请求。<br>3xx （5种）</li><li>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</li><li>302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；<br>   301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）</li><li>303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；<br>   302与303的区别：后者明确表示客户端应当采用GET方式获取资源</li><li>304 Not Modified：表示客户端发送附带条件<pre><code>             （是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、               If-None-Match、If-Range、If-Unmodified-Since中任一首部）               的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；</code></pre></li><li>307 Temporary Redirect：临时重定向，与303有着相同的含义，<br>307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；<br>4xx （4种）</li><li>400 Bad Request：表示请求报文中存在语法错误；</li><li>401 Unauthorized：未经许可，需要通过HTTP认证；</li><li>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）</li><li>404 Not Found：表示服务器上无法找到请求的资源，除此之外，<pre><code>           也可以在服务器拒绝请求但不想给拒绝原因时使用；</code></pre>5xx （2种）</li><li>500 Inter Server Error：表示服务器在执行请求时发生了错误，<pre><code>                    也有可能是web应用存在的bug或某些临时的错误时；</code></pre></li><li>503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，<pre><code>                    无法处理请求；</code></pre></li></ol><h2 id="一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？"><a href="#一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？" class="headerlink" title="一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？"></a>一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h2><p>在 HTTP/1.0 中，<code>一个服务器在发送完一个 HTTP 响应后</code>，会断开 TCP 链接。<br>但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，<br>某些服务器对 <code>Connection: keep-alive 的 Header </code>进行了支持。<br>意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。<br>这样的好处是连接可以被重新使用   ， <code>之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，</code><br>以及如果维持连接，那么 SSL 的开销也可以避免</p><h2 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么?"></a>URI和URL的区别是什么?</h2><p><strong>URI(Uniform Resource Identifier) 是<code>统⼀资源标志符</code>，可以唯⼀标识⼀个资源。<br>URL(Uniform Resource Location) 是统⼀资源定位.URL是URI的一个子集。它是⼀种具体的URI，即 URL 可以⽤来标识⼀个资源，<code>⽽且还指明了如何 locate 这个资源</code>。<br>URL一般由三部组成<br>①<code>协议(</code>或称为服务方式)<br>②<code>存有该资源的主机IP地址</code>(有时也包括端口号)<br>③<code>主机资源的具体地址。如目录和文件名等。</code><br>例如：<a href="http://www.jianshu.com/u/606fd5f5448c">http://www.jianshu.com/u/606fd5f5448c</a><br>URL是URI的子集，所有的URL都是URI，但不是每个URI都是URL，还有可能是URN.</strong></p><h2 id="http工作流程-输入网址过程"><a href="#http工作流程-输入网址过程" class="headerlink" title="http工作流程-输入网址过程"></a>http工作流程-输入网址过程</h2><p>域名解析 -&gt; 三次握手 -&gt; 发起HTTP请求 -&gt; 响应HTTP请求并得到HTML代码<br>-&gt; 浏览器解析HTML代码  -&gt; 浏览器对页面进行渲染呈现给用户</p><ol><li>输入地址,对URL进⾏解析，从⽽⽣成发送给Web服务器的请求信息。</li><li>浏览器查找域名的IP地址,因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。　<ol><li>浏览器会首先查看本地硬盘的hosts文件，看看其中有没有和这个域名对应的规则，<br>如果有的话就直接使用hosts文件里面的ip地址。</li><li>如果在本地的hosts文件没有能够找到对应的ip地址，<br>浏览器会发出一个DNS请求到<code>本地DNS服务器</code></li><li>查询你输入的网址的DNS请求到达本地DNS服务器之后，<br>本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，<br>就可以直接返回结果，此过程是递归的方式进行查询。<br>如果没有，本地DNS服务器还要向DNS根服务器进行查询。</li><li>根DNS服务器没有记录具体的域名和IP地址的对应关系，<br>而是告诉本地DNS服务器，你可以到<code>域服务器上</code>去继续查询，<br>并给出域服务器的地址。这种过程是迭代的过程。</li><li>本地DNS服务器继续向域服务器发出请求，比如说请求的对象是.com域服务器。<br>.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，<br>而是告诉本地DNS服务器，<code>你的域名的解析服务器</code>的地址</li><li>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，<br><code>本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，</code><br>以备下次别的用户查询时，可以直接返回结果，<code>加快网络访问。</code></li></ol></li><li>浏览器向web服务器发送一个HTTP请求<br>   通过DNS获取到IP后，就可以把HTTP的传输⼯作交给操作系统中的协议栈。<br>   协议栈的内部分为⼏个部分，分别承担不同的⼯作。<br>   上下关系是有⼀定的规则的，上⾯的部分会向下⾯的部分委托⼯作，<br>   下⾯的部分收到委托的⼯作并执⾏。<br>   应⽤程序也就是浏览器通过调⽤ Socket 库，来委托协议栈⼯作。<br>   协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，<br>   它们两会接受应⽤层的委托执⾏收发数据的操作。<br>   协议栈的下⼀半是⽤IP协议控制⽹络包收发操作，<br>   在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，<br>   ⽽将⽹络包发送给对⽅的操作就是由 IP 负责的。<br>   IP 下⾯的⽹卡驱动程序负责控制⽹卡硬件，<br>   ⽽最下⾯的⽹卡则负责完成实际的收发操作，<br>   也就是对⽹线中的信号执⾏发送和接收操作。<br>   拿到域名对应的IP地址之后，<br>   浏览器会以一个随机端口向服务器的WEB程序80端口发起TCP的连接请求。<br>   这个连接请求到达服务器端后，进入到网卡，然后是进入到内核的TCP/IP协议栈，<br>   还有可能要经过防火墙的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</li><li>服务器处理请求<br>   http请求发送到了服务器，后端从在固定的端口接收到TCP报文开始，<br>   它会对TCP连接进行处理，对HTTP协议进行解析，<br>   并按照报文格式进一步封装成HTTP Request对象，供上层使用。</li><li>服务器返回一个HTTP响应　<br>   服务器收到了我们的请求，也处理我们的请求，<br>   到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。</li><li>浏览器显示 HTML,并请求获取嵌入在HTML的资源</li></ol><h3 id="为什么域名要分级设计"><a href="#为什么域名要分级设计" class="headerlink" title="为什么域名要分级设计"></a>为什么域名要分级设计</h3><p>DNS 中的域名都是⽤句点来分隔的，代表了不同层次之间的界限。</p><p>域名的层级关系类似⼀个树状结构：<br>根 DNS 服务器<br>顶级域 DNS 服务器（com）<br>权威 DNS 服务器（server.com）</p><p>因此，客户端只要能够找到任意⼀台 DNS 服务器，<br>就可以通过它找到根域 DNS 服务器，然后再⼀路顺<br>藤摸⽠找到位于下层的某台⽬标 DNS 服务器。</p><h3 id="重定向原因"><a href="#重定向原因" class="headerlink" title="重定向原因"></a>重定向原因</h3><ol><li>网站调整（如改变网页目录结构）；</li><li>网页被移到一个新地址；</li><li>网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</li></ol><p>这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中<br>旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；<br>还有就是某些注册了多个域名的网站，<br>也需要通过重定向让访问这些域名的用户自动跳转到主站点等</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
      <url>2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>class Solution {<br>    public int[] getLeastNumbers(int[] nums, int k) {<br>        int[] arr = new int[k];<br>        if(k==0) return arr;<br>        PriorityQueue<Integer> queue= new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1);</p><pre><code>    for(int num :nums)&#123;        queue.add(num);        if(queue.size()&gt;k)&#123;            queue.poll();        &#125;    &#125;    for(int i = 0 ; i &lt; arr.length;i++)&#123;        arr[i]=queue.poll();    &#125;    return arr;&#125;</code></pre><p>}<br>时间复杂度：O(nlogk)，其中 nn 是数组 arr 的长度。由于大根堆实时维护前 kk 小值，所以插入删除都是 O(\log k)O(logk) 的时间复杂度，最坏情况下数组里 nn 个数都会插入，所以一共需要 O(nlogk) 的时间复杂度。</p><p>空间复杂度：O(k)，因为大根堆里最多 k 个数。</p><h2 id="quickselect"><a href="#quickselect" class="headerlink" title="quickselect"></a>quickselect</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
      <url>2020/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/offer/-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>调整数组顺序使奇数位于偶数前面</p><p>类比快速排序paitition</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] exchange(int[] nums) &#123;        int cur &#x3D; 0;        for(int i &#x3D; 0 ; i &lt;nums.length;i++)&#123;            if(nums[i]%2&#x3D;&#x3D;1)&#123;                int tmp &#x3D; nums[cur];nums[cur] &#x3D; nums[i];nums[i]&#x3D;tmp;                cur++;            &#125;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序--颜色分类问题(荷兰国旗),数组中的第K个最大元素,</title>
      <link href="2020/12/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2020/12/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><hr><p><code>示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5</code></p><hr><h3 id="先排序再查找"><a href="#先排序再查找" class="headerlink" title="先排序再查找"></a>先排序再查找</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;        Arrays.sort(nums);        return nums[nums.length-k];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用最小堆"><a href="#使用最小堆" class="headerlink" title="使用最小堆"></a>使用最小堆</h3><p>我们可以使用最小堆来解决，一个个遍历原数组的值，添加到堆中，如果堆中元素的个数小于等于k的时候，我们就往堆中添加，添加之后如果堆中元素个数大于k的时候，我们就把最顶端的元素给移除掉，因为是最小堆，所以移除的就是堆中最小的值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;       &#x2F;&#x2F;最小堆       PriorityQueue&lt;Integer&gt; queue &#x3D; new PriorityQueue&lt;&gt;();       for(int num : nums)&#123;           queue.add(num);           if(queue.size()&gt;k)&#123;               queue.poll();           &#125;       &#125;       return queue.peek();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>快速排序是先选择一个中枢（一般我们选第一个），然后遍历后面的元素，最终会把数组分为两部分，前面部分比中枢值小，后面部分大于或等于中枢值，如果交换之后中枢值所在的位置就是从后面数第k个，我们直接返回中枢值即可，如果从后面数大于第k个，我们只需按照同样的方式从后面部分开始找即可。如果从后面数小于第k个，我们同样从前面部分开始查找，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int findKthLargest(int[] nums, int k) &#123;       &#x2F;&#x2F;快速选择       int lo &#x3D; 0;       int hi &#x3D; nums.length-1;       int target &#x3D; nums.length-k;       while(lo &lt;&#x3D; hi)&#123;           int pivot &#x3D; partition(nums,lo,hi);           if(target&lt;pivot)&#123;               hi &#x3D; pivot-1;           &#125;else if(target &gt; pivot)&#123;               lo &#x3D; pivot+1;           &#125;else &#123;               return nums[pivot];           &#125;       &#125;       return -1;    &#125;    public int partition(int[] nums,int l,int r)&#123;        int cur &#x3D; l;        int end &#x3D; r;        for(int i &#x3D; l;i&lt;end;i++)&#123;            if(nums[i]&lt;nums[end])&#123;                swap(nums,i,cur);                cur++;            &#125;        &#125;        swap(nums,cur,end);        return cur;    &#125;    public void swap(int[] nums, int i, int j)&#123;        int tmp &#x3D; nums[i];        nums[i]&#x3D;nums[j];        nums[j]&#x3D;tmp;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="颜色分类-荷兰国旗问题"><a href="#颜色分类-荷兰国旗问题" class="headerlink" title="颜色分类 荷兰国旗问题"></a>颜色分类 荷兰国旗问题</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。</p><p><code>要求额外空间复杂度O(1)，时间复杂度O(N)</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public void sortColors(int[] nums) &#123;        &#x2F;&#x2F;partition        partition(nums,0,nums.length-1,1);    &#125;    public void partition(int[] nums,int l, int r,int pivot)&#123;        int start &#x3D; l-1;        int end &#x3D; r+1;        while(l&lt;end)&#123;            if(nums[l]&lt;pivot)&#123;                swap(nums,++start,l++);            &#125;else if(nums[l]&gt;pivot)&#123;                swap(nums,--end,l);            &#125;else &#123;                l++;            &#125;        &#125;    &#125;    public void swap(int[] nums,int i, int j)&#123;        int tmp &#x3D; nums[i];        nums[i]&#x3D;nums[j];        nums[j]&#x3D;tmp;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] exchange(int[] nums) &#123;        int cur &#x3D; 0;        for(int i &#x3D; 0 ; i &lt;nums.length;i++)&#123;            if(nums[i]%2&#x3D;&#x3D;1)&#123;                int tmp &#x3D; nums[cur];nums[cur] &#x3D; nums[i];nums[i]&#x3D;tmp;                cur++;            &#125;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leedcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> leedcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/24/%E9%9B%86%E5%90%88/hashmap/"/>
      <url>2020/12/24/%E9%9B%86%E5%90%88/hashmap/</url>
      
        <content type="html"><![CDATA[<p>而<code>加载因子就是表示Hash表中元素的填满程度。</code></p><p><code>加载因子 = 填入表中的元素个数 / 散列表的长度</code></p><p><code>如果负载因子设置过大或过小会有什么问题？</code></p><p>首先知道负载因子的大小是主要就是决定了HashMap的数据密度的嘛<br>如果负载因子越大数据密度越大，<br><strong>加载因子越大</strong>，填满的元素越多，空间利用率越高，但发生冲突的机会变大了；<br>就会可能发生碰撞的几率越高，数组中的链表也会越容易长， 这样的话造成查询和插入时的比较次数增多，性能会下降。（可能又引出一个面试题：如何解决Hash碰撞问题？）</p><p><strong>加载因子越小，</strong>填满的元素越少，冲突发生的机会减小，但空间浪费了更多了，而且还会提高扩容rehash操作的次数。<br>如果负载因子越小，就会越容易触发扩容，虽然数据密度也越小，发生碰撞几率小，数组中链表越短对于查询和插入时比较次数也会少一些，性能也会提高。<br>但是扩容会影响性能，<br>HashMap 初始容量大小默认是16，这是为了减少冲突发生的概率，当HashMap的数组长度到达一个临界值的时候，就会触发扩容，把所有元素rehash之后再放在扩容后的容器中，这是一个相当耗时的操作，所以扩容是件影响性能的。</p><p>冲突的机会越大，说明需要查找的数据还需要通过另一个途径查找，这样查找的成本就越高。因此，必须在“冲突的机会”与“空间利用率”之间，寻找一种平衡与折衷。</p><p>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少扩容rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，以便减少扩容操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="2020/12/23/test/"/>
      <url>2020/12/23/test/</url>
      
        <content type="html"><![CDATA[<p><img src="a.png" alt=" 这里输入图片描述"></p><p><img src="1.png" alt=" 这里输入图片描述"></p><!-- ![](/img/a.png) --><p><img src="a.png" alt=" 这里输入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2020/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/01/redis/LRU%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>2020/12/01/redis/LRU%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/01/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>2020/12/01/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>命令不区分大小写<br>Key区分大小写</p><p>help @命令 帮助文档</p><p><code>string</code> ：<br>set mset get mget incr incrby decr decrby strlen<br>setnx – 分布式锁</p><p>set key value [EX seconds] [PX milliseconds]  [NX |XX]</p><p>EX多少秒过期<br>PX多少毫秒过期<br>NX–setnx等价<br>XX  key存在的时候覆盖<br><code>应用场景：</code><br>订单号码，商品编号用incr生成<br>喜欢的文章数<br>incr items:001</p><p><code>hash</code>:    对应Java MAP&lt;String,Map(Object,Object)&gt;<br>hset  hget hmset hmget<br>hset person id 1<br>hgetall person<br>hlen hdel<br><code>应用场景购物车早期</code><br><code>购物车加几个</code> hincrby </p><p>hset shopcar:uid  33222 1 新增<br>hincrby shopcar:uid  33222 1 增加数量<br>商品总数 hlen shopcar:uid<br>全选 hgetall shopcar:uid</p><p><code>list</code><br>lpush  rpush lrange llen<br>    <code>微信文章订阅公众号码</code></p><p>lpush likeauthor:uid1024 11 22</p><p>lrange likeauthor:uid1024 0 -1</p><p><code>set</code> sadd srem smembers scard sismember srandmember spop<br>sdiff sinter  sunion<br><code>微信抽奖小程序</code>：spop（删除元素）/srandmember（不删除元素）<br>sadd choujiang:1001 1 2 3<br>显示有多少人参加了：scard choujiang:1001<br>任意抽奖N个：spop choujiang:1001 N<br><code>微信朋友圈点赞</code><br>新增点赞  sadd pub:msgID 点赞用户id<br>取消点赞  srem pub:msgID 点赞用户id<br>展现所有点赞过的用户：smembers pub:msgID<br>点赞用户数目统计 ：  scard pub:msgID<br>判断是否点赞过    sismembers pub:msgID 点赞用户id</p><p><code>好友关注社交关系</code>：<br>    <code>共同关注</code>  sinter s1 s2<br>    <code>我关注的人也关注了他</code>：<br><code>可能认识的人</code> sdiff s1 s2<br>            sdiff s2 s1</p><p><code>zset</code>:<br>zadd zrem zrange zrevrange zincrby zcars zrank从小到大 zrevrank 从大到小获取元素的排名<br><code>根据商品的销售对商品进行排序显示</code><br>商品销量zadd goods:sellsort 9 1001 15 1002<br>1011商品又增加了两件zincrby goods:sellsort 2 1001<br>商品销量的前十名：zrange goods:sellsort 0 10 withscores<br><code>抖音热搜</code> ：<br>点击视频 zincrby hot:20201009 1 易洋千玺<br>展示前10    zrevrange hot:20201009 0 10 withscores</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/"/>
      <url>2020/12/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃 自己需要的同步资源，就形成了线程的死锁<br>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于`阻塞状态</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/29/spring/"/>
      <url>2020/11/29/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1.Spring概述"></a>1.Spring概述</h1><h2 id="1-1：什么是spring"><a href="#1-1：什么是spring" class="headerlink" title="1-1：什么是spring?"></a>1-1：什么是spring?</h2><p>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。<br>Spring使你能够编写更干净、更可管理、并且更易于测试的代码。</p><h2 id="1-2：Spring的优缺点是什么？"><a href="#1-2：Spring的优缺点是什么？" class="headerlink" title="1-2：Spring的优缺点是什么？"></a>1-2：Spring的优缺点是什么？</h2><p><code>优点：</code><br>   整个 Spring 优势，传达出⼀个信号，Spring 是⼀个综合性，且有很强的思想性框架，每学习⼀ 天，就能体会到它的⼀些优势。</p><h3>⽅便解耦，简化开发</h3>通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进⾏控制，避免硬编码所造成的 过度程序耦合。⽤户也不必再为单例模式类、属性⽂件解析等这些很底层的需求编写代码，可以更 专注于上层的应⽤。<h3>AOP编程的⽀持</h3>通过Spring的AOP功能，⽅便进⾏⾯向切⾯的编程，许多不容易⽤传统OOP实现的功能可以通过 AOP轻松应付。<h3>声明式事务的⽀持</h3>@Transactional可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式⽅式灵活的进⾏事务的管理，提⾼ 开发效率和质量。<h3>⽅便程序的测试</h3>可以⽤⾮容器依赖的编程⽅式进⾏⼏乎所有的测试⼯作，测试不再是昂贵的操作，⽽是随⼿可做的 事情。<h3>⽅便集成各种优秀框架</h3>Spring可以降低各种框架的使⽤难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、 Quartz等）的直接⽀持。<h3>降低JavaEE API的使⽤难度</h3>Spring对JavaEE API（如JDBC、JavaMail、远程调⽤等）进⾏了薄薄的封装层，使这些API的使⽤ 难度⼤为降低。<h3>源码是经典的 Java 学习范例</h3>Spring的源代码设计精妙、结构清晰、匠⼼独⽤，处处体现着⼤师对Java设计模式灵活运⽤以及对 Java技术的⾼深造诣。它的源代码⽆意是Java技术的最佳实践的范例。<p><code>缺点</code><br>   使用了大量的反射机制，反射机制非常占用内存。</p><h2 id="1-3：Spring-有哪些配置方式"><a href="#1-3：Spring-有哪些配置方式" class="headerlink" title="1-3：Spring 有哪些配置方式"></a>1-3：Spring 有哪些配置方式</h2><p><code>1、XML 配置文件。</code></p><p>Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。<br>这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。<br>它们通常以 bean 标签开头。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>2、注解配置。</code></p><p>可以通过在相关的类，方法或字段声明上使用注解，<br>将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。<br>默认情况下，Spring 容器中未打开注解装配。<br>因此，需要在使用它之前在 Spring 配置文件中启用它。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;beans&gt;&lt;context:annotation-config&#x2F;&gt;&lt;!-- bean definitions go here --&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>3、Java Config 配置。</code></p><p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<br>@Bean 注解扮演与 <bean /> 元素相同的角色。<br>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 Bean 间依赖关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class StudentConfig &#123;        @Bean    public StudentBean myStudent() &#123;        return new StudentBean();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-Spring用到的设计模式有哪些"><a href="#2-Spring用到的设计模式有哪些" class="headerlink" title="2.Spring用到的设计模式有哪些"></a>2.Spring用到的设计模式有哪些</h1><ol><li>工厂模式:通过 BeanFactory 或 ApplicationContext 创建 bean 对象。</li><li>单例模式:Bean默认为单例模式。<br> xml : <bean id="userService" class="top.snailclimb.UserService" scope="singleton"/><br> 注解：@Scope(value = “singleton”)</li><li>代理模式:Spring 的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术;</li><li>模板模式:<br>Spring 中 jdbcTemplate、hibernateTemplate 等<br>以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。<br>一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，<br>而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</li><li>观察者模式:<br>Spring 事件驱动模型就是观察者模式，<br>比如我们每次添加商品的时候都需要重新更新商品索引，<br>这个时候就可以利用观察者模式来解决这个问题。</li><li>适配器模式<ul><li>在SpringAOP和SpringMVC中都有适配器模式<br>虽然Spring AOP 的实现是基于代理模式，<br>但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，<br>比如说Spring预定义要通过对应的适配器，<br>适配成 MethodInterceptor接口(方法拦截器)类型的对象<br>如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice</li></ul></li></ol><ul><li>spring MVC中的适配器模式<br>在Spring MVC中，DispatcherServlet根据请求信息<br>调用HandlerMapping，<br>解析请求对应的Handler。<br>解析到对应的 Handler,也就是我们平常说的 Controller 控制器后，<br>开始由HandlerAdapter 适配器处理。<br>HandlerAdapter 作为期望接口，<br>具体的适配器实现类用于对目标类进行适配，<br>Controller 作为需要适配的类。<br>因为Spring MVC 中的 Controller 种类众多，<br>不同类型的 Controller 通过不同的方法来对请求进行处理。<br>如果不利用适配器模式的话，<br>DispatcherServlet 直接获取对应类型的 Controller，<br>需要的自行来判断</li></ul><ol start="7"><li>装饰者模式<br>当我们需要修改原有的功能，<br>但我们又不愿直接去修改原有的代码时，<br>设计一个Decorator套在原有代码外面<br>Spring 中配置 DataSource 的时候，<br>DataSource 可能是不同的数据库和数据源。<br>我们能否根据客户的需求在少<br>修改原有类的代码下动态切换不同的数据源<br>这个时候就要用到装饰者模式。<br>Spring 中用到的包装器模式<br>在类名上含有 Wrapper或者 Decorator。<br>这些类基本上都是动态地给一个对象添加一些额外的职责</li></ol><h1 id="3-循环依赖"><a href="#3-循环依赖" class="headerlink" title="3. 循环依赖"></a>3. 循环依赖</h1><h2 id="3-1：什么是Spring的循环依赖"><a href="#3-1：什么是Spring的循环依赖" class="headerlink" title="3-1：什么是Spring的循环依赖"></a>3-1：什么是Spring的循环依赖</h2><p>就是有一个 A 对象，创建 A 的时候发现 A 对象依赖 B，<br>然后去创建 B 对象的时候，又发现 B 对象依赖 C，<br>然后去创建 C 对象的时候，又发现 C 对象依赖 A。</p><h2 id="3-2：什么是三级缓存"><a href="#3-2：什么是三级缓存" class="headerlink" title="3-2：什么是三级缓存"></a>3-2：什么是三级缓存</h2><ol><li>第一级缓存：单例缓存池 singletonObjects。</li><li>第二级缓存：早期提前暴露的对象缓存 earlySingletonObjects。</li><li>第三级缓存：singletonFactories 单例对象工厂缓存</li></ol><p>先从一级缓存singletonObjects中去获取，<br>如果获取到 Bean 就直接返回。<br>如果获取不到或者对象正在创建中，<br>那就再从二级缓存earlySingletonObjects中获取，<br>如果获取到就直接返回。<br>如果前两级缓存都没成功返回，<br>且允许 singletonFactories(allowEarlyReference=true)<br>通过getObject()获取。就从三级缓存singletonFactory.getObject()获取。<br>如果获取到了就从singletonFactories中移除，<br>并且放进earlySingletonObjects。<br>其实也就是从三级缓存移动到了二级缓存。是剪切、不是复制。</p><h2 id="3-3：什么是早期暴露的对象"><a href="#3-3：什么是早期暴露的对象" class="headerlink" title="3-3：什么是早期暴露的对象"></a>3-3：什么是早期暴露的对象</h2><p>你是一个不完整的对象，你的属性还没有值，<br>你的对象也没有被初始化。这就是早期暴露的对象，<br>只是提前拿出来给你认识认识。但他非常重要。<br>这是多级缓存解决循环依赖问题的一个巧妙的地方。</p><h2 id="3-4：如何解决循环依赖"><a href="#3-4：如何解决循环依赖" class="headerlink" title="3-4：如何解决循环依赖"></a>3-4：如何解决循环依赖</h2><p>主要是用三级缓存来解决循环依赖问题</p><p>比如说A、B类的互相依赖注入，使用属性field注入循环依赖来解决</p><ol><li>使用context.getBean(A.class)，<br>旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，<br>显然初次获取A是不存在的，因此走A的创建之路~</li><li>实例化A（注意此处仅仅是实例化），<br>并将它放进缓存（此时A已经实例化完成，已经可以被引用了）</li><li>初始化A：@Autowired依赖注入B（此时需要去容器内获取B）</li><li>为了完成依赖注入B，会通过getBean(B)去容器内找B。<br>但此时B在容器内不存在，就走向B的创建之路~</li><li>实例化B，并将其放入缓存。（此时B也能够被引用了）</li><li>初始化B，@Autowired依赖注入A（此时需要去容器内获取A）</li><li>此处重要：初始化B时会调用getBean(A)去容器内找到A，<br>因为A已经实例化完成了并且放进了缓存里，<br>所以这个时候去看缓存里是已经存在A的引用了的，<br>所以getBean(A)能够正常返回</li><li>B初始化成功（此时已经注入A成功了，已成功持有A的引用了），<br>return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中</li><li> 因为B实例已经成功返回了，因此最终A也初始化成功</li><li>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，</li></ol><h1 id="4-IOC"><a href="#4-IOC" class="headerlink" title="4.IOC"></a>4.IOC</h1><h2 id="4-1：IOC原理"><a href="#4-1：IOC原理" class="headerlink" title="4-1：IOC原理"></a>4-1：IOC原理</h2><p>ioc也叫控制反转，是一种设计思想。<br>就是将对象的创建和管理交由spring管理。<br>ioc容器本质上是一个map，存放着各种bean对象，<br>key是bean对象名，value是bean配置信息。<br>bean对象的创建、依赖关系都交由ioc容器完成，<br>使用时不需要关心bean对象什么时候创建<br>也不需要手动维护对象间的关系。<br>ioc容器相当于一个第三方的容器，<br>关联着使用资源的双方。<br>比如一个user类和userinfo类，<br>user类要使用userinfo类的属性，<br>需要调用时创建user类和userinfo类的的对象，<br>然后进行属性注入。<br>但是如果将user和userinfo都交由ioc容器管理，<br>调用时只需要从ioc容器中取出user对象，<br>那么user对象需要的userinfo属性会在ioc容器中进行注入，<br>取出的user对象是已经完成依赖注入的对象。</p><h3 id="4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）"><a href="#4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）" class="headerlink" title="4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）"></a>4-1-1：自己设计SpringIOC，如何设计（IOC初始化过程）（132期）</h3><p>首先初始化上下文，<br>生成ClassPathXmlApplicationContext对象，<br>在获取resourcePatternResolver对象将xml解析成Resource对象。<br>利用生成的 context、resource 初始化工厂，<br>并将 resource 解析成 beandefinition,<br>再将 beandefinition 注册到 beanfactory 中。</p><h3 id="4-1-2：IOC好处"><a href="#4-1-2：IOC好处" class="headerlink" title="4-1-2：IOC好处"></a>4-1-2：IOC好处</h3><p>它将最小化应用程序中的代码量。<br>它以最小的影响和最少的侵入机制促进松耦合。<br>它支持即时的实例化和延迟加载 Bean 对象。<br>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</p><h2 id="4-2：IOC的实现机制（继续扩产—芋头）"><a href="#4-2：IOC的实现机制（继续扩产—芋头）" class="headerlink" title="4-2：IOC的实现机制（继续扩产—芋头）"></a>4-2：IOC的实现机制（继续扩产—芋头）</h2><p>Spring 中的 IoC 的实现原理，就是工厂模式加反射机制</p><p>a. 加载配置文件，解析成 BeanDefinition 放在 Map 里。<br>b. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，<br>   拿出 Class 对象进行实例化，同时，如果有依赖关系，<br>   将递归调用 getBean 方法 —— 完成依赖注入。</p><h2 id="4-2：IOC容器种类"><a href="#4-2：IOC容器种类" class="headerlink" title="4-2：IOC容器种类"></a>4-2：IOC容器种类</h2><p>一共是两种</p><h3 id="4-2-1：BeanFactory与ApplicationContext区别"><a href="#4-2-1：BeanFactory与ApplicationContext区别" class="headerlink" title="4-2-1：BeanFactory与ApplicationContext区别"></a>4-2-1：BeanFactory与ApplicationContext区别</h3><p>ApplicationContext和BeanFactory是Spring的两大核心接口。<br>都可以当做Spring的容器<br>其中ApplicationContext是 BeanFactory的子接口。<br>(1）BeanFactory:是Spring里面最底层的接口，包含了各种Bean的定义，读取bean<br>配置文档，管理 bean 的加载、实例化，控制 bean的生命周期，维护 bean之间的依赖关系。<br>ApplicationContext 接口作为 BeanFactory的派生，除了提供BeanFactory所具有的功能外，<br>还提供了更完整的框架功能:继承MessageSource，因此支持国际化。统一的资源文件访问<br>方式。提供在监听器中注册bean的事件。同时加载多个配置文件。载入多个(有继承关系）<br>上下文，使得每个上下文都专注于一个特定的层次，比如应用web层<br>(2）BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时<br>(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring<br>的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用<br>getBean方法才会抛出异常。<br>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动<br>时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注<br>入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当<br>你需要的时候，你就不用等待，因为它们已经创建好了。相对于基本的 BeanFactory，<br>ApplicationContext唯一的不足是占用内存空间。当应用程序配置Bean较多时，<br>程序启动较慢。<br>(3)BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，<br>如使用 ContextLoader。<br>（4） BeanFactory和 ApplicationContext 都支持 BeanPostProcessor、<br>BeanFactoryPostProcessor的使用，但两者之间的区别是: BeanFactory需要手动注册，而<br>ApplicationContext则是自动注册。</p><h4 id="4-2-1-1：请介绍下常用的-BeanFactory-容器？"><a href="#4-2-1-1：请介绍下常用的-BeanFactory-容器？" class="headerlink" title="4-2-1-1：请介绍下常用的 BeanFactory 容器？"></a>4-2-1-1：请介绍下常用的 BeanFactory 容器？</h4><p>BeanFactory 最常用的是 XmlBeanFactory 。<br>它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p><h4 id="4-2-1-2：请介绍下常用的-ApplicationContext-容器？"><a href="#4-2-1-2：请介绍下常用的-ApplicationContext-容器？" class="headerlink" title="4-2-1-2：请介绍下常用的 ApplicationContext 容器？"></a>4-2-1-2：请介绍下常用的 ApplicationContext 容器？</h4><p>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，<br>                                    并生成上下文定义。应用程序上下文从程序环境变量中取得。<br>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。示<br>3、XmlWebApplicationContext ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</p><p>第四种 ApplicationContext 容器，ConfigServletWebServerApplicationContext 。</p><h3 id="4-2-2：BeanFactory和FactoryBean的区别（51期）"><a href="#4-2-2：BeanFactory和FactoryBean的区别（51期）" class="headerlink" title="4-2-2：BeanFactory和FactoryBean的区别（51期）"></a>4-2-2：BeanFactory和FactoryBean的区别（51期）</h3><p>BeanFactory是个Factory，也就是IOC容器或对象工厂，<br>FactoryBean是个Bean。在Spring中，<br>所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。<br>但对FactoryBean而言，这个Bean不是简单的Bean，<br>而是一个能生产或者修饰对象生成的工厂Bean,<br>它的实现与设计模式中的工厂模式和修饰器模式类似</p><h4 id="4-2-2-1：BeanFactory"><a href="#4-2-2-1：BeanFactory" class="headerlink" title="4-2-2-1：BeanFactory"></a>4-2-2-1：BeanFactory</h4><p>以Factory结尾，表示它是一个工厂类(接口)，<br>它负责生产和管理bean的一个工厂。<br>在Spring中，BeanFactory是IOC容器的核心接口，<br>它的职责包括：实例化、定位、配置<br>应用程序中的对象及建立这些对象间的依赖。</p><h4 id="4-2-2-2：FactoryBean"><a href="#4-2-2-2：FactoryBean" class="headerlink" title="4-2-2-2：FactoryBean"></a>4-2-2-2：FactoryBean</h4><p>一般情况下，Spring通过反射机制利用<bean><br>的class属性指定实现类实例化Bean，<br>在某些情况下，实例化Bean过程比较复杂，<br>如果按照传统的方式，<br>则需要在<bean>中提供大量的配置信息。<br>配置方式的灵活性是受限的，<br>这时采用编码的方式可能会得到一个简单的方案。</p><h2 id="4-3：依赖注入"><a href="#4-3：依赖注入" class="headerlink" title="4-3：依赖注入"></a>4-3：依赖注入</h2><h3 id="4-3-1：依赖注入概念"><a href="#4-3-1：依赖注入概念" class="headerlink" title="4-3-1：依赖注入概念"></a>4-3-1：依赖注入概念</h3><p>在依赖注入中，不必主动、手动创建对象，但必须描述如何创建它们。<br>不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。<br>然后，再由 IoC 容器将它们装配在一起。</p><h3 id="4-3-2：有哪些不同类型的IOC（依赖注入）方式？"><a href="#4-3-2：有哪些不同类型的IOC（依赖注入）方式？" class="headerlink" title="4-3-2：有哪些不同类型的IOC（依赖注入）方式？"></a>4-3-2：有哪些不同类型的IOC（依赖注入）方式？</h3><p><code>构造器依赖注入</code>： 构造器依赖注入通过容器触发一个类的构造器来实现的，<br>                  该类有一系列参数，每个参数代表一个对其他类的依赖。<br><code>Setter方法注入</code>： Setter方法注入是容器通过调用无参构造器或无参static工厂<br>                  方法实例化bean之后，调用该bean的setter方法，<br>                  即实现了基于setter的依赖注入。<br><code>接口注入</code>：       定义接口</p><h4 id="4-3-2-1：三种方式的区别小结"><a href="#4-3-2-1：三种方式的区别小结" class="headerlink" title="4-3-2-1：三种方式的区别小结"></a>4-3-2-1：三种方式的区别小结</h4><ol><li>基于构造器的注入，会固定依赖注入的顺序；<br>该方式不允许我们创建bean对象之间的循环依赖关系，<br>这种限制其实是一种利用构造器来注入的益处<br>没有注意到使用setter注入的时候，Spring能解决循环依赖的问题；</li><li>基于setter的注入，只有当对象是需要被注入的时候它才会帮助我们注入依赖，<br>而不是在初始化的时候就注入；另一方面如果你使用基于constructor注入，<br>CGLIB不能创建一个代理，迫使你使用基于接口的代理或虚拟的无参数构造函数。</li><li>使用直接在成员变量上写上注解来注入这种方式<br>看起来非常好，精短，可读性高，不需要多余的代码，也方便维护；</li></ol><h2 id="4-4：IOC与DI的的区别（修改）"><a href="#4-4：IOC与DI的的区别（修改）" class="headerlink" title="4-4：IOC与DI的的区别（修改）"></a>4-4：IOC与DI的的区别（修改）</h2><p>IOC:  控制反转,将类的对象的创建交给Spring类管理创建.<br>DI:   依赖注入,将类里面的属性在创建类的过程中给属性赋值. </p><h2 id="4-5：Spring-框架中有哪些不同类型的事件？"><a href="#4-5：Spring-框架中有哪些不同类型的事件？" class="headerlink" title="4-5：Spring 框架中有哪些不同类型的事件？"></a>4-5：Spring 框架中有哪些不同类型的事件？</h2><ol><li>上下文更新事件（ContextRefreshedEvent）：<br>该事件会在ApplicationContext 被初始化或者更新时发布。<br>也可以在调用ConfigurableApplicationContext 接口中的 #refresh() 方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：<br>当容器调用ConfigurableApplicationContext 的 #start()<br>方法开始/重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：<br>当容器调用 ConfigurableApplicationContext 的<br>#stop() 方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：<br>当ApplicationContext 被关闭时触发该事件。<br>容器被关闭时，其管理的所有单例 Bean 都被销毁。</li><li>请求处理事件（RequestHandledEvent）：<br>在 We b应用中，当一个HTTP 请求（request）结束触发该事件。</li><li>通过扩展 ApplicationEvent 类来开发自定义的事件</li></ol><h1 id="5-AOP"><a href="#5-AOP" class="headerlink" title="5.AOP"></a>5.AOP</h1><h2 id="5-1：什么是aop"><a href="#5-1：什么是aop" class="headerlink" title="5-1：什么是aop"></a>5-1：什么是aop</h2><p>AOP面向切面编程, 它与OOP我认为是共同作用的，<br>他所提供了与 OOP 不同的抽象软件结构的视角。<br>   在 OOP 中，以类( Class )作为基本单元<br>   在 AOP 中，以切面( Aspect )作为基本单元。<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:<br>   如何通过 PointCut 和 Advice 定位到特定的 JoinPoint 上。<br>   如何在 Advice 中编写切面代码。</p><h3 id="5-1-1：什么是-Aspect"><a href="#5-1-1：什么是-Aspect" class="headerlink" title="5-1-1：什么是 Aspect"></a>5-1-1：什么是 Aspect</h3><p>@Aspect 注解的类就是切面<br>Aspect 由 PointCut 和 Advice 组成。<br>   它既包含了横切逻辑的定义，也包括了连接点的定义。<br>   Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</p><h3 id="5-1-2：什么是-JoinPoint"><a href="#5-1-2：什么是-JoinPoint" class="headerlink" title="5-1-2：什么是 JoinPoint"></a>5-1-2：什么是 JoinPoint</h3><p>JoinPoint ，切点，程序运行中的一些时间点, 例如：<br>一个方法的执行。<br>或者是一个异常的处理。<br>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p><h3 id="5-1-3：什么是-PointCut"><a href="#5-1-3：什么是-PointCut" class="headerlink" title="5-1-3：什么是 PointCut"></a>5-1-3：什么是 PointCut</h3><p>PointCut 是匹配 JoinPoint 的条件。</p><p>Advice 是和特定的 PointCut 关联的，<br>并且在 PointCut 相匹配的 JoinPoint 中执行。<br>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，<br>但是我们并不希望在所有的方法上都添加 Advice 。<br>而 PointCut 的作用，就是提供一组规则 来匹配 JoinPoint ，<br>给满足规则的 JoinPoint 添加 Advice 。</p><h3 id="5-1-3-4：关于-JoinPoint-和-PointCut-的区别"><a href="#5-1-3-4：关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="5-1-3~4：关于 JoinPoint 和 PointCut 的区别"></a>5-1-3~4：关于 JoinPoint 和 PointCut 的区别</h3><ol><li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。<br>而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，<br>通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li><li>Advice 是在 JoinPoint 上执行的，<br>而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li></ol><p>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。<br>然后，Advice 在查询到 JoinPoint 上执行逻辑。</p><h3 id="5-1-5：什么是-Advice-？"><a href="#5-1-5：什么是-Advice-？" class="headerlink" title="5-1-5：什么是 Advice ？"></a>5-1-5：什么是 Advice ？</h3><p>通知。<br>比如说特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。<br>Spring AOP 使用一个 Advice 作为拦截器，<br>在 JoinPoint “周围”维护一系列的拦截器。</p><h4 id="5-1-5-1：有哪些类型的-Advice？"><a href="#5-1-5-1：有哪些类型的-Advice？" class="headerlink" title="5-1-5-1：有哪些类型的 Advice？"></a>5-1-5-1：有哪些类型的 Advice？</h4><ol><li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，<pre><code>     并使用 @Before 注解标记进行配置。</code></pre></li><li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，<pre><code>              并使用 @AfterReturning 注解标记进行配置。</code></pre></li><li>After Throwing - 这些类型的 Advice 仅在 JoinPoint <pre><code>             方法通过抛出异常退出并使用              @AfterThrowing 注解标记配置时执行。</code></pre></li><li>After Finally - 这些类型的 Advice 在连接点方法之后执行，<pre><code>            无论方法退出是正常还是异常返回，            并使用 @After 注解标记进行配置。</code></pre></li><li>Around - 这些类型的 Advice 在连接点之前和之后执行，<pre><code>     并使用 @Around 注解标记进行配置。</code></pre></li></ol><h3 id="5-1-6：什么是-Target"><a href="#5-1-6：什么是-Target" class="headerlink" title="5-1-6：什么是 Target"></a>5-1-6：什么是 Target</h3><p>Target ，织入 Advice 的目标对象。目标对象也被称为 Advised Object 。</p><p>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，<br>因此 Advised Object 总是一个代理对象(Proxied Object) 。<br>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象。<br>Advice + Target Object = Advised Object = Proxy 。</p><h3 id="5-1-7：什么是编织（Weaving）"><a href="#5-1-7：什么是编织（Weaving）" class="headerlink" title="5-1-7：什么是编织（Weaving）"></a>5-1-7：什么是编织（Weaving）</h3><p>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，叫做编织。<br>在 Spring AOP 中，编织在运行时执行，即动态代理</p><h3 id="5-1-8：AOP中的切面、切点、连接点、通知，四者的关系"><a href="#5-1-8：AOP中的切面、切点、连接点、通知，四者的关系" class="headerlink" title="5-1-8：AOP中的切面、切点、连接点、通知，四者的关系"></a>5-1-8：AOP中的切面、切点、连接点、通知，四者的关系</h3><p>切面，一定要给spring 管理<br>切点，目的是为了将注解写在上面而已<br>pointcut是连接点的集合<br>通知—》配置切点</p><h2 id="5-2：aop有哪些实现方式"><a href="#5-2：aop有哪些实现方式" class="headerlink" title="5-2：aop有哪些实现方式"></a>5-2：aop有哪些实现方式</h2><p>实现 AOP 的技术，主要分为两大类：</p><ol><li>静态代理 - 指使用 AOP 框架提供的命令进行编译，<pre><code>      从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</code></pre>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，<br>  实现类加载时编织时增强，从而实现链路追踪的透明埋点。</li><li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，<pre><code>     因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：     JDK 动态代理     CGLIB</code></pre></li></ol><h3 id="5-2-1：Spring-什么时候使用-JDK-动态代理，什么时候使用-CGLIB-呢"><a href="#5-2-1：Spring-什么时候使用-JDK-动态代理，什么时候使用-CGLIB-呢" class="headerlink" title="5-2-1：Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢"></a>5-2-1：Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢</h3><ol><li>JDK 动态代理<br>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。<br>JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</li><li>CGLIB 动态代理<br>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。<br>当然，Spring 也支持配置，强制使用CGLIB动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，<br>可以在运行时动态的生成某个类的子类，CGLIB 是通过继承的方式做的动态代理，<br>因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的。</li></ol><h3 id="5-2-2：是编译时期进行织入，还是运行期进行织入"><a href="#5-2-2：是编译时期进行织入，还是运行期进行织入" class="headerlink" title="5-2-2：是编译时期进行织入，还是运行期进行织入"></a>5-2-2：是编译时期进行织入，还是运行期进行织入</h3><p>运行期，生成字节码，再加载到虚拟机中，<br>JDK是利用反射原理，CGLIB使用了ASM原理。</p><h3 id="5-2-3：初始化时期织入还是获取对象时织入"><a href="#5-2-3：初始化时期织入还是获取对象时织入" class="headerlink" title="5-2-3：初始化时期织入还是获取对象时织入"></a>5-2-3：初始化时期织入还是获取对象时织入</h3><p>初始化的时候，已经将目标对象进行代理，放入到spring 容器中</p><h3 id="5-2-4：spring-AOP-默认使用jdk动态代理还是cglib"><a href="#5-2-4：spring-AOP-默认使用jdk动态代理还是cglib" class="headerlink" title="5-2-4：spring AOP 默认使用jdk动态代理还是cglib"></a>5-2-4：spring AOP 默认使用jdk动态代理还是cglib</h3><p>要看条件，如果实现了接口的类，是使用jdk。<br>如果没实现接口，就使用cglib。</p><h3 id="5-2-5：动态代理步骤"><a href="#5-2-5：动态代理步骤" class="headerlink" title="5-2-5：动态代理步骤"></a>5-2-5：动态代理步骤</h3><h4 id="5-2-5-1：JDK动态代理的步骤"><a href="#5-2-5-1：JDK动态代理的步骤" class="headerlink" title="5-2-5-1：JDK动态代理的步骤"></a>5-2-5-1：JDK动态代理的步骤</h4><ol><li>先检查委托类是否实现了相应接口，保证被访问方法在接口中也要有定义</li><li>创建一个实现InvocationHandler接口的类</li><li>在类中定义一个被代理对象的成员属性，为了扩展方便可以直接使用Object类，<br>也可以根据需求定义相应的接口</li><li>在invoke方法中实现对委托对象的调用，根据需求对方法进行增强</li><li>使用Proxy.newProxyInstance(…)方法创建代理对象，并提供要给获取代理对象的方法</li></ol><h4 id="5-2-5-2：cglib动态代理实现步骤"><a href="#5-2-5-2：cglib动态代理实现步骤" class="headerlink" title="5-2-5-2：cglib动态代理实现步骤"></a>5-2-5-2：cglib动态代理实现步骤</h4><ol><li>创建一个实现MethodInterceptor接口的类</li><li>在类中定义一个被代理对象的成员属性，<br>为了扩展方便可以直接使用Object类，也可以根据需求定义相应的接口</li><li>在invoke方法中实现对委托对象的调用，根据需求对方法进行增强</li><li>使用Enhancer创建生成代理对象，并提供要给获取代理对象的方法</li></ol><h3 id="5-2-6：jdk动态代理-VS-cglib"><a href="#5-2-6：jdk动态代理-VS-cglib" class="headerlink" title="5-2-6：jdk动态代理 VS cglib"></a>5-2-6：jdk动态代理 VS cglib</h3><h4 id="5-2-6-1：两种代理模式的比较"><a href="#5-2-6-1：两种代理模式的比较" class="headerlink" title="5-2-6-1：两种代理模式的比较"></a>5-2-6-1：两种代理模式的比较</h4><ol><li>JDK Proxy 的优势：<ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，<br>JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，<br>而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul></li><li>cglib 优势：<ul><li>有的时候调用目标可能不便实现额外接口，<br>从某种角度看，限定调用者实现接口是有些侵入性的实践，<br>类似 cglib 动态代理就没有这种限制。</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li></ul></li></ol><h4 id="5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？"><a href="#5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？" class="headerlink" title="5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？"></a>5-2-6-2：jdk动态代理性能远比cglib要差，如果是，依据是什么？</h4><p>JDK有一个限制，就是它只能为接口创建代理实例，<br>而对于没有通过接口定义业务方法的类,需要通过CGLib创建动态代理实例  </p><h4 id="5-2-6-3：JDK的动态代理为什么需要接口"><a href="#5-2-6-3：JDK的动态代理为什么需要接口" class="headerlink" title="5-2-6-3：JDK的动态代理为什么需要接口"></a>5-2-6-3：JDK的动态代理为什么需要接口</h4><ol><li>在需要继承proxy类获得有关方法和InvocationHandler构造方法传参的同时,<br>java不能同时继承两个类，我们需要和想要代理的类建立联系，只能实现一个接口   </li><li>需要反射获得代理类的有关参数，必须要通过某个类，<br>反射获取有关方法，</li><li>成功返回的是object类型，要获取原类，<br>只能继承/实现，或者就是那个代理类</li><li>对具体实现的方法内部并不关心，<br>这个交给InvocationHandler.invoke那个方法里去处理就好了，<br>我只想根据你给我的接口反射出对我有用的东西。</li><li>考虑到设计模式，以及proxy编者编写代码的逻辑</li></ol><h2 id="5-3：Spring-AOP-and-AspectJ-AOP-有什么区别"><a href="#5-3：Spring-AOP-and-AspectJ-AOP-有什么区别" class="headerlink" title="5-3：Spring AOP and AspectJ AOP 有什么区别"></a>5-3：Spring AOP and AspectJ AOP 有什么区别</h2><ol><li>代理方式不同<br>   Spring AOP 基于动态代理方式实现。<br>   AspectJ AOP 基于静态代理方式实现。</li><li>PointCut 支持力度不同<br>   Spring AOP 仅支持方法级别的 PointCut 。<br>   AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li></ol><h2 id="5-4：Spring-如何使用-AOP-切面"><a href="#5-4：Spring-如何使用-AOP-切面" class="headerlink" title="5-4：Spring 如何使用 AOP 切面"></a>5-4：Spring 如何使用 AOP 切面</h2><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p><p>基于 XML 方式的切面实现。<br>基于 注解 方式的切面实现。<br>目前，主流喜欢使用 注解 方式。</p><h2 id="5-5：aop的应用场景有哪些"><a href="#5-5：aop的应用场景有哪些" class="headerlink" title="5-5：aop的应用场景有哪些"></a>5-5：aop的应用场景有哪些</h2><p>1、日志记录<br>2、权限验证<br>3、效率检查<br>4、事务管理</p><h1 id="6-Spring-Bean"><a href="#6-Spring-Bean" class="headerlink" title="6.Spring Bean"></a>6.Spring Bean</h1><h2 id="6-1：什么是SpringBean"><a href="#6-1：什么是SpringBean" class="headerlink" title="6-1：什么是SpringBean"></a>6-1：什么是SpringBean</h2><p>Bean 由 Spring IoC 容器实例化，配置，装配和管理。</p><h2 id="6-1：Bean的五种作用域"><a href="#6-1：Bean的五种作用域" class="headerlink" title="6-1：Bean的五种作用域"></a>6-1：Bean的五种作用域</h2><p>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。<br>prototype : 每次请求都会创建一个新的 bean 实例。<br>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。<br>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。<br>global-session： 全局session作用域，<br>                 仅仅在基于portlet的web应用中才有意义，</p><h3 id="6-1-2：Spring中的单例bean的线程安全问题了解吗？"><a href="#6-1-2：Spring中的单例bean的线程安全问题了解吗？" class="headerlink" title="6-1-2：Spring中的单例bean的线程安全问题了解吗？"></a>6-1-2：Spring中的单例bean的线程安全问题了解吗？</h3><p>单例 bean 存在线程问题，<br>主要是因为当多个线程操作同一个对象的时候，<br>对这个对象的非静态成员变量的写操作会存在线程安全问题。</p><h4 id="6-1-2-1：常见的有两种解决办法"><a href="#6-1-2-1：常见的有两种解决办法" class="headerlink" title="6-1-2-1：常见的有两种解决办法"></a>6-1-2-1：常见的有两种解决办法</h4><ol><li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中定义一个ThreadLocal成员变量，<br>将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li></ol><h2 id="6-2：Bean的生命周期"><a href="#6-2：Bean的生命周期" class="headerlink" title="6-2：Bean的生命周期"></a>6-2：Bean的生命周期</h2><p>（1）实例化（必须的）构造函数构造对象<br>（2）装配（可选的）为属性赋值<br>（3）回调（可选的）（容器-控制类和组件-回调类）<br>（4）初始化(init-method=” “)<br>（5）就绪<br>（6）销毁（destroy-method=” “） </p><p>（1）实例化Bean：<br>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，<br>或初始化bean的时候需要注入<br>另一个尚未初始化的依赖时，<br>容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，<br>当容器启动结束后，<br>通过获取BeanDefinition对象中的信息，实例化所有的bean。<br>（2）设置对象属性（依赖注入）：<br>实例化后的对象被封装在BeanWrapper对象中，紧接着，<br>Spring根据BeanDefinition中的信息<br>以及通过BeanWrapper提供的设置属性的接口完成依赖注入。<br>（3）处理Aware接口：<br>接着，Spring会检测该对象是否实现了xxxAware接口，<br>并将相关的xxxAware实例注入给Bean：<br>①如果这个Bean已经实现了BeanNameAware接口，<br>会调用它实现的setBeanName(String beanId)方法，<br>此处传递的就是Spring配置文件中Bean的id值；<br>②如果这个Bean已经实现了BeanFactoryAware接口，<br>会调用它实现的setBeanFactory()方法，<br>传递的是Spring工厂自身。<br>③如果这个Bean已经实现了ApplicationContextAware接口，<br>会调用setApplicationContext(ApplicationContext)方法，<br>传入Spring上下文；<br>（4）BeanPostProcessor：<br>如果想对Bean进行一些自定义的处理，<br>那么可以让Bean实现了BeanPostProcessor接口，<br>那将会调用postProcessBeforeInitialization(Object obj, String s)方法。<br>（5）InitializingBean 与 init-method：<br>如果Bean在Spring配置文件中配置了 init-method 属性，<br>则会自动调用其配置的初始化方法。<br>（6）如果这个Bean实现了BeanPostProcessor接口，<br>将会调用postProcessAfterInitialization(Object<br>obj, String s)方法；由于这个方法是在Bean初始化结束时使用的，<br>所以可以被应用于内存或缓存技术；<br>以上几个步骤完成后，Bean就已经被正确创建了，<br>之后就可以使用这个Bean了。<br>（7）DisposableBean：<br>当Bean不再需要时，会经过清理阶段，<br>如果Bean实现了DisposableBean这个接口，会调用其实现的<br>destroy()方法；<br>（8）destroy-method：<br>最后，如果这个Bean的Spring配置中<br>配置了destroy-method属性，<br>会自动调用其配置的销毁方法。<br>方法二：实现org.springframework.beans.factory.DisposableBean接口。<br>执行它的destroy()方法。<br>如果一个Bean实现了org.springframework.beans.factory.DisposableBean接口，<br>则会自动装配</p><h2 id="6-3：Spring的Bean注入方式"><a href="#6-3：Spring的Bean注入方式" class="headerlink" title="6-3：Spring的Bean注入方式"></a>6-3：Spring的Bean注入方式</h2><ol><li>set方法注入</li><li>构造器注入</li><li>静态工厂注入</li><li>实例工厂注入 </li><li><code>set注入</code><br>如果我们需要使用set注入，那么必须要为属性提供set方法，<br>Spring容器就是通过调用bean的set方法为属性注入值的。<br>而在xml文件中，使用set注入的方式就是通过property标签，</li><li><code>构造器注入</code><br>   就是通过调用bean所属类的带参构造器为bean的属性注入值。<br>我们如果需要使用构造器注入，就得为类提供包含参数的构造方法。<br>构造器注入，实际上有多种匹配属性值的方式，比如说<br>（一）匹配构造器的参数名称<br>  我们需要通过constructor-arg标签为构造器传入参数值，<br>每个constructor-arg标签对应直接匹配参数名<br>（二）匹配构造器的参数下标<br>  通过参数在参数列表中的下标进行匹配的方式。<br>通过参数的下标为构造器的参数赋值，<br>参实的下标从0开始。使用第一种方式配置，若赋值的类型与参数的类型不一致，<br>将会在容器初始化bean的时候抛出异常。<br>如果bean存在多个参数数量一样的构造器，<br>Spring容器会自动找到类型匹配的那个进行调用。<br>比如说，Car有如下两个构造器，Spring容器将会调用第二个，<br>因为上面的配置中，index = 1对应的value是double类型，<br>与第二个构造器匹配，而第一个不匹配：<br>（三）匹配构造器的参数类型<br>  直接通过匹配构造器的参数类型，<br>从而选择一个能够完全匹配的构造器，调用这个构造器完成bean的创建和属性注入。<br>类型并不需要按构造器中声明的顺序编写，Spring也能进行匹配。</li><li><code>静态工厂注入</code><br>  静态工厂注入就是我们编写一个静态的工厂方法，<br>这个工厂方法会返回一个我们需要的值，然后在配置文件中，<br>我们指定使用这个工厂方法创建bean。首先我们需要一个静态工厂，</li><li> <code>实例工厂</code>与静态工厂类似，不同的是，<br>静态工厂调用工厂方法不需要先创建工厂类的对象，<br>因为静态方法可以直接通过类调用，<br>所以在上面的配置文件中，并没有声明工厂类的bean。<br>但是，实例工厂，需要有一个实例对象，才能调用它的工厂方法。</li></ol><h2 id="6-4：接口与bean"><a href="#6-4：接口与bean" class="headerlink" title="6-4：接口与bean"></a>6-4：接口与bean</h2><h3 id="6-4-1：没有注入接口，使用时怎么能获取的接口"><a href="#6-4-1：没有注入接口，使用时怎么能获取的接口" class="headerlink" title="6-4-1：没有注入接口，使用时怎么能获取的接口"></a>6-4-1：没有注入接口，使用时怎么能获取的接口</h3><p>@Autowired是Spring的注解，Autowired默认先按byType，<br>如果发现找到多个bean，则，又按照byName方式比对，<br>如果还有多个，则报出异常；@Resource<br>默认按照名称(Byname)进行装配, 如果没有指定name属性，<br>当注解写在字段上时，默认取字段名，按照名称查找，<br>如果注解写在setter方法上默认取属性名进行装配。<br>当找不到与名称匹配的bean时才按照类型进行装配。<br>如果name属性一旦指定，就只会按照名称进行装配。<br>对于Controller获取实例的过程，使用@Autowired，<br>程序在spring的容器中查找类型是TestService的bean，<br>刚好找到有且只有一个此类型的bean，即testServiceImpl，<br>所以就把testServiceImpl自动装配到了controller<br>的实例testService中，testService其实就是TestServiceImpl实现类；<br>如果使用的是@Resource，<br>则是先在容器中查找名字为testService的bean，<br>但并没有找到，因为容器中的bean名字是TestServiceImpl<br>如果@Service没指定bean的value属性，<br>则注入bean的名字就是类名，如果指定了则是指定的名字，<br>然后再通过类型查找TestService类型的bean，<br>找到唯一的了个TestService类型bean（即TestServiceImpl），<br>所以就自动装配实例成功了。</p><h3 id="6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？"><a href="#6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？" class="headerlink" title="6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？"></a>6-4-2：如果一个接口有多个实现类时，通过注解获取实例时怎么知道应该获取的是哪一个实现类serviceImpl呢？</h3><p>1、 通过指定bean的名字来明确到底要实例哪一个类<br>2、 通过在实现类上添加@Primary注解来指定默认加载类</p><h3 id="6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？"><a href="#6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？" class="headerlink" title="6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？"></a>6-4-3：为什么非要调用接口，而不直接调用实现类serviceImpl的bean来得简单明了呢？</h3><p>1、 直接获取实现类serviceImpl的bean也是可以的；<br>2、 至于加一层接口的原因：一是AOP程序设置思想指导，<br>    给别人调用的接口，调用者只想知道方法和功能，<br>    而对于这个方法内部逻辑怎么实现的并不关心；<br>    二是可以降低各个模块间的关联，<br>    实现松耦合、程序分层、高扩展性，使程序更加灵活，<br>    他除了在规范上有卓越贡献外，最精髓的是在多态上的运用；<br>    继承只能单一继承，接口却可以多实现<br>3、 当业务逻辑简单，变更较少，项目自用时，<br>    省略掉接口直接使用实现类更简单明了；反之则推荐使用接口;</p><h2 id="6-5：什么是-Spring-的内部-bean？"><a href="#6-5：什么是-Spring-的内部-bean？" class="headerlink" title="6-5：什么是 Spring 的内部 bean？"></a>6-5：什么是 Spring 的内部 bean？</h2><p>只有将 Bean 仅用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。</p><p>为了定义Bean，Spring 提供基于 XML 的配置元数据在<br><property>或 <constructor-arg> 中提供了 <bean>元素的使用。<br>内部 Bean 总是匿名的，并且它们总是作为原型 Prototype 。<br>例如，假设我们有一个 Student 类，其中引用了 Person 类。<br>这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;!-- bean.xml --&gt;&lt;bean id&#x3D;“StudentBean&quot; class&#x3D;&quot;com.edureka.Student&quot;&gt;    &lt;property name&#x3D;&quot;person&quot;&gt;        &lt;!--This is inner bean --&gt;        &lt;bean class&#x3D;&quot;com.edureka.Person&quot;&gt;            &lt;property name&#x3D;&quot;name&quot; value&#x3D;“Scott&quot;&gt;&lt;&#x2F;property&gt;            &lt;property name&#x3D;&quot;address&quot; value&#x3D;“Bangalore&quot;&gt;&lt;&#x2F;property&gt;        &lt;&#x2F;bean&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-Spring事务"><a href="#7-Spring事务" class="headerlink" title="7.Spring事务"></a>7.Spring事务</h1><h2 id="7-1：spring事务种类"><a href="#7-1：spring事务种类" class="headerlink" title="7-1：spring事务种类"></a>7-1：spring事务种类</h2><p>spring支持编程式事务管理和声明式事务管理两种方式<br>①编程式事务管理使用TransactionTemplate.<br>②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，<br>将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完<br>目标方法之后根据执行情况提交或者回滚事务。</p><h3 id="7-1-1：-Transactional原理"><a href="#7-1-1：-Transactional原理" class="headerlink" title="7-1-1：@Transactional原理"></a>7-1-1：@Transactional原理</h3><p>@Transactional 的工作机制是基于 AOP 实现的，<br>AOP 又是使用动态代理实现的。如果目标对象实现了接口，<br>默认情况下会采用 JDK 的动态代理，<br>如果目标对象没有实现了接口,会使用 CGLIB 动态代理。<br>通过createAopProxy() 方法决定了是使用 JDK 还是 Cglib 来做动态代理<br>如果一个类或者一个类中的 public 方法上<br>被标注@Transactional 注解的话，<br>Spring 容器就会在启动的时候为其创建一个代理类，<br>在调用被@Transactional 注解的 public 方法的时候，<br>实际调用的是，TransactionInterceptor 类中的 invoke()方法。<br>这个方法的作用就是在目标方法之前开启事务方法<br>执行过程中如果遇到异常的时候回滚事务，<br>方法调用完成之后提交事务。</p><h4 id="7-1-1-1：注解使用详解"><a href="#7-1-1-1：注解使用详解" class="headerlink" title="7-1-1-1：注解使用详解"></a>7-1-1-1：注解使用详解</h4><p>方法 ：将注解使用于方法上，不过需要注意的是：<br>      该注解只能应用到 public 方法上，否则不生效。<br>类 ：如果这个注解使用在类上的话，<br>     表明该注解对该类中所有的 public 方法都生效。<br>接口 ：不推荐在接口上使用。</p><h4 id="7-1-1-2：注解常用属性"><a href="#7-1-1-2：注解常用属性" class="headerlink" title="7-1-1-2：注解常用属性"></a>7-1-1-2：注解常用属性</h4><ol><li>propagation    事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过</li><li>isolation    事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过</li><li>timeout        事务的超时时间，默认值为-1（不会超时）。<pre><code>         如果超过该时间限制但事务还没有完成，则自动回滚事务。</code></pre></li><li>readOnly        指定事务是否为只读事务，默认值为 false。</li><li>rollbackFor    用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</li></ol><h3 id="7-1-2：Spring两种事务区别"><a href="#7-1-2：Spring两种事务区别" class="headerlink" title="7-1-2：Spring两种事务区别"></a>7-1-2：Spring两种事务区别</h3><p>1）声明式事务最大的优点就是不需要<br>   在业务逻辑代码中掺杂事务管理的代码，<br>   只需在配置文件中做相关的事务<br>   规则声明或通过@Transactional注解的方式，<br>   便可以将事务规则应用到业务逻辑中。<br>2）声明式事务管理要优于编程式事务管理，<br>   这正是 spring倡导的非侵入式的开发方式，<br>   使业务代码不受污染，<br>   只要加上注解就可以获得完全的事务支持。<br>   唯一不足地方是，最细粒度只能作用到方法级别，<br>   无法做到像编程式事务那样可以作用到代码块级别。</p><h2 id="7-2：事务管理接口"><a href="#7-2：事务管理接口" class="headerlink" title="7-2：事务管理接口"></a>7-2：事务管理接口</h2><ol><li>PlatformTransactionManager： （平台）事务管理器，Spring 事务策略的核心。</li><li>TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li><li>TransactionStatus： 事务运行状态。</li></ol><p>我们可以把 PlatformTransactionManager 接口可以被看作是事务上层的管理者，<br>而 TransactionDefinition 和 TransactionStatus 这两个接口可以看作是事物的描述。<br>PlatformTransactionManager 会根据 TransactionDefinition<br>的定义比如事务超时时间、隔离界别、传播行为等来进行事务管理 ，<br>而 TransactionStatus 接口则提供了<br>一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p><h2 id="7-3：事务属性详解"><a href="#7-3：事务属性详解" class="headerlink" title="7-3：事务属性详解"></a>7-3：事务属性详解</h2><p>事务属性主要包括五部分：隔离级别、传播行为、回滚规则、是否只读、事务超时</p><h3 id="7-3-1：事务隔离级别"><a href="#7-3-1：事务隔离级别" class="headerlink" title="7-3-1：事务隔离级别"></a>7-3-1：事务隔离级别</h3><p>ISOLATION_DEFAULT:这是个PlatfromTransactionManager默认的隔离级别，<br>                   使用数据库默认的事务隔离级别。<br>ISOLATION_READ_UNCOMMITTED:读未提交，<br>                           允许另外一个事务可以看到这个事务未提交的数据。<br>ISOLATION_READ_COMMITTED:读已提交，<br>                         保证一个事务修改的数据提交后<br>                         才能被另一事务读取，<br>                         而且能看到该事务对已有记录的更新。<br>ISOLATION_REPEATABLE_READ:可重复读，<br>                          保证一个事务修改的数据提交后<br>                          才能另一事务读取，<br>                          但是不能看到该事务对已有记录的更新。<br>ISOLATION_SERIALIZABLE:一个事务在执行的过程中<br>                       完全看不到其他事务对数据库所</p><h3 id="7-3-2：事务传播行为（为什么要有）"><a href="#7-3-2：事务传播行为（为什么要有）" class="headerlink" title="7-3-2：事务传播行为（为什么要有）"></a>7-3-2：事务传播行为（为什么要有）</h3><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题。<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如<br>我们在 A 类的aMethod（）方法中调用了 B 类的 bMethod() 方法。<br>这个时候就涉及到业务层方法之间互相调用的事务问题。<br>如果我们的 bMethod()如果发生异常需要回滚，<br>如何配置事务传播行为才能让 aMethod()也跟着回滚呢<br>这个时候就需要事务传播行为的知识了，</p><h4 id="7-3-2-1：传播行为级别"><a href="#7-3-2-1：传播行为级别" class="headerlink" title="7-3-2-1：传播行为级别"></a>7-3-2-1：传播行为级别</h4><p><code>PROPAGATION_REQUIRED</code>:如果当前没有事务，<br>                     就创建一个新事务，<br>                     如果当前存在事务，<br>                     就加入该事务，<br>                     该设置是最常用的设置。<br><code>PROPAGATION_SUPPORTS</code>:支持当前事务，<br>                     如果当前存在事务，<br>                     就加入该事务，<br>                     如果当前不存在事务，<br>                     就以非事务执行。<br><code>PROPAGATION_MANDATORY</code>:支持当前事务，<br>                      如果当前仔在事分，<br>                      影果当前不存在事务，<br>                      就抛出异常。<br><code>PROPAGATION_REOUIRES NEW</code>:创建新事务，<br>                         无论当前存不存在事务，<br>                         都创建新事务。<br><code>PROPAGATION_NOT_SUPPORTED</code>:以非事务方式执行操作，<br>                          如果当前存在事务，<br>                          就把当前事务挂起。<br><code>PROPAGATION_NEVER</code>:以非事务方式执行，<br>                  如果当前存在事务，<br>                  则抛出异常。<br><code>PROPAGATION_NESTED</code>:如果当前存在事务，<br>                   则在嵌套事务内执行。<br>                   如果当前没有事务，<br>                   则按 REQUIRED属性执行。</p><h3 id="7-3-3：事务的回滚规则"><a href="#7-3-3：事务的回滚规则" class="headerlink" title="7-3-3：事务的回滚规则"></a>7-3-3：事务的回滚规则</h3><p>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</p><p>默认情况下，事务只有遇到运行期异常时才会回滚，<br>而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。<br>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。<br>同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p><h3 id="7-3-4：事务的只读属性"><a href="#7-3-4：事务的只读属性" class="headerlink" title="7-3-4：事务的只读属性"></a>7-3-4：事务的只读属性</h3><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</p><h5 id="7-3-4-1：什么是事务性资源"><a href="#7-3-4-1：什么是事务性资源" class="headerlink" title="7-3-4-1：什么是事务性资源"></a>7-3-4-1：什么是事务性资源</h5><p>事务性资源就是指那些被事务管理的资源，<br>比如数据源、JMS 资源，以及自定义的事务性资源等等。<br>如果确定只对事务性资源进行只读操作，<br>那么我们可以将事务标志为只读的，<br>以提高事务处理的性能。</p><h3 id="7-3-5：事务的超时属性"><a href="#7-3-5：事务的超时属性" class="headerlink" title="7-3-5：事务的超时属性"></a>7-3-5：事务的超时属性</h3><p>就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。<br>在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。<br>当然，这个属性，貌似我们基本也没用过。</p><h2 id="7-4：Spring的事务和数据库的事务隔离是一个概念么？"><a href="#7-4：Spring的事务和数据库的事务隔离是一个概念么？" class="headerlink" title="7-4：Spring的事务和数据库的事务隔离是一个概念么？"></a>7-4：Spring的事务和数据库的事务隔离是一个概念么？</h2><p>Spring 并不直接管理事务，而是提供了多种事务管理器 。<br>Spring 事务管理器的接口是： PlatformTransactionManager 。<br>通过这个接口，Spring 为各个平台如<br>JDBC(DataSourceTransactionManager)、<br>Hibernate(HibernateTransactionManager)、<br>JPA(JpaTransactionManager)等都提供了<br>对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><h2 id="7-5：Spring事务底层原理"><a href="#7-5：Spring事务底层原理" class="headerlink" title="7-5：Spring事务底层原理"></a>7-5：Spring事务底层原理</h2><ol><li>划分处理单元 IOC<br> 之前在看源码，发现Spring 解决的问题是对单个数据库进行局部事务处理的，<br> 具体的实现首先使用 Spring 中的 IOC 划分了事务处理单元。<br> 并且将对事务的各种配置放到了 IOC 容器中<br> （设置事务管理器，设置事务的传播特性及隔离机制）。</li><li>AOP 拦截需要进行事务处理的类<br> Spring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，<br> 具体操作（比如事务实行的配置和读取，事务对象的抽象），<br> 用 TransactionProxyFactoryBean 接口来使用 AOP 功能，<br> 生成 proxy 代理对象，通过 TransactionInterceptor 完成对代理方法的拦截，<br> 将事务处理的功能编织到拦截的方法中。读取 IOC 容器事务配置属性，<br> 转化为 Spring 事务处理需要的内部数据结构<br> （TransactionAttributeSourceAdvisor），<br> 转化为 TransactionAttribute 表示的数据对象。</li><li>对事物处理实现（事务的生成、提交、回滚、挂起）<br> Spring 委托给具体的事务处理器实现。实现了一个抽象和适配。<br> 适配的具体事务处理器：DataSource 数据源支持、<br> Hibernate 数据源事务处理支持、JDO 数据源事务处理支持，<br> JPA、JTA 数据源事务处理支持。<br> 这些支持都是通过设计 PlatformTransactionManager、<br> AbstractPlatforTransaction 一系列事务处理的支持。<br> 为常用数据源支持提供了一系列的 TransactionManager。</li></ol><h2 id="7-6：为什么在-Spring-事务中不能切换数据源？"><a href="#7-6：为什么在-Spring-事务中不能切换数据源？" class="headerlink" title="7-6：为什么在 Spring 事务中不能切换数据源？"></a>7-6：为什么在 Spring 事务中不能切换数据源？</h2><p>因为，在 Spring 的事务管理中，<br>所使用的数据库连接会和当前线程所绑定，<br>即使我们设置了另外一个数据源，使用的还是当前的数据源连接。<br>另外，多个数据源且需要事务的场景，<br>本身会带来多事务一致性的问题，暂时的话，可能没有太好的解决方案<br>所以一般一个应用，推荐除非了读写分离所带来的多数据源，<br>其它情况下，建议只有一个数据源。</p><h1 id="8-Spring的装配"><a href="#8-Spring的装配" class="headerlink" title="8.Spring的装配"></a>8.Spring的装配</h1><h2 id="8-1：什么是Spring装配"><a href="#8-1：什么是Spring装配" class="headerlink" title="8-1：什么是Spring装配"></a>8-1：什么是Spring装配</h2><p>当 Bean 在 Spring 容器中组合在一起时，它被称为装配或 Bean 装配</p><h2 id="8-2：自动装配有哪些方式"><a href="#8-2：自动装配有哪些方式" class="headerlink" title="8-2：自动装配有哪些方式"></a>8-2：自动装配有哪些方式</h2><p>Spring 容器能够自动装配 Bean 。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 Bean 的协作者。<br>自动装配的不同模式：</p><p>no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。<br>byName - 它根据 Bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。<br>【最常用】byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。<br>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。<br>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="2020/11/28/%E5%8F%8D%E5%B0%84/"/>
      <url>2020/11/28/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<font color = gold ><p>都说框架=反射+注解+设计模式<br>那么今天就来总结一下关于反射的知识把～～</p></font><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><hr><h2 id="反射是什么"><a href="#反射是什么" class="headerlink" title="反射是什么"></a>反射是什么</h2><p>加载完类之后，在运行时数据取区就产生了一个Class类型的对象，Class对象包含了完整的类的结构信息。<br>我们可以通过这个Class对象可以看到类的结构，我们形象的称之为<code>反射</code>；</p><p>JAVA 反射机制被看作是<code>动态语言</code>的关键（<strong>运行期间可以改变其结构的语言</strong>）</p><p>Java不是动态语言 ，但Java可以称之为“准动态语言”。即Java有一定的动 态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。 Java的动态性让编程的时候更加灵活！<br><strong>允许程序在执行期间<br>获取任何类的内部信息<br>并且能直接操作任意对象的内部属性和方法</strong><br>正常情况下 是通过引入包类的名称–new–取得实例化对象<br>反射 ： 实例化对象-getClass()–得到完整的包类名称</p><hr><h2 id="反射优缺点"><a href="#反射优缺点" class="headerlink" title="反射优缺点"></a>反射优缺点</h2><p>优点： 运行期间可以改变其结构的语言<br>      解耦以及提高代码的灵活性。  —反射 AOP</p><p>缺点： 1、性能瓶颈：反射相当于一系列解释操作，<br>          通知 JVM 要做的事情，<br>          性能比直接的 java 代码要慢很多。<br>      2、安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</p><hr><h2 id="反射能做什么"><a href="#反射能做什么" class="headerlink" title="反射能做什么"></a>反射能做什么</h2><p>在运行时判断一个对象所属的类<br>在运行的时候构造一个类的对象<br>在运行时候调用任意一个类所拥有的成员变量和方法<br>在运行时候获取泛型信息<br>在运行时候调用任意一个对象的成员变量和方法<br>在运行时处理注解<br>生成动态代理<br><code> java.lang.Class 代表一个类  java.lang.reflect.Method 代表类的方法  java.lang.reflect.Field 代表类的成员变量  java.lang.reflect.Constructor 代表类的构造器</code></p><hr><h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><h3 id="java-lang-Class类–反射的源头"><a href="#java-lang-Class类–反射的源头" class="headerlink" title="java.lang.Class类–反射的源头"></a>java.lang.Class类–反射的源头</h3><h3 id="java-lang-Class类的理解"><a href="#java-lang-Class类的理解" class="headerlink" title="java.lang.Class类的理解"></a>java.lang.Class类的理解</h3><p><code>加载</code>完类之后，在运行时数据取区就产生了一个Class类型的对象，Class对象包含了完整的类的结构信息。可以通过Class类的方法进行对象的实例化操作，调用任意一个类所拥有的成员变量和方法</p><p>Class主要是`反射的源头``，<br>一个加载的类在 JVM 中只会有一个Class实例<br>一个Class对象对应的是一个加载到JVM中的一个.class文件</p><h3 id="如何获取Class对象"><a href="#如何获取Class对象" class="headerlink" title="如何获取Class对象"></a>如何获取Class对象</h3><ol><li>Object类的getClass();</li><li>任何数据类型（包括基本数据类型）都有一个“静态”的class属性</li><li>通过Class类的静态方法：forName(常用)</li><li>类加载器<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;----Class&lt;Person&gt; personClass &#x3D; Person.class;System.out.println(personClass);&#x2F;&#x2F;------Person person &#x3D; new Person();Class&lt;? extends Person&gt; aClass &#x3D; person.getClass();System.out.println(aClass);Class&lt;?&gt; personClz &#x3D; Class.forName(&quot;com.as.Person&quot;);System.out.println(personClz);ClassLoader classLoader &#x3D; ReflectionTest.class.getClassLoader();Class&lt;?&gt; loadClass &#x3D; classLoader.loadClass(&quot;com.as.Person&quot;);System.out.println(loadClass);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;    private String name;    public int age;    public Person() &#123;    &#125;    public Person(String name, int age) &#123;        this.name &#x3D; name;        this.age &#x3D; age;    &#125;    private Person(String name) &#123;        this.name &#x3D; name;    &#125;    public String getName() &#123;        return name;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age&#x3D;&quot; + age +                &#39;&#125;&#39;;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age &#x3D; age;    &#125;    public void show()&#123;        System.out.println(&quot;hello reflection&quot;);    &#125;    private String showNation(String nation)&#123;        System.out.println(&quot;国籍：&quot;+nation);        return nation;    &#125;&#125;public class ReflectionTest &#123;    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException, NoSuchFieldException &#123;        &#x2F;&#x2F;反射创建对象        Class&lt;Person&gt; personClass &#x3D; Person.class;        Constructor&lt;Person&gt; constructor &#x3D; personClass.getConstructor(String.class, int.class);        Person person &#x3D; constructor.newInstance(&quot;加多&quot;, 24);        System.out.println(person.toString());        &#x2F;&#x2F;反射操作对象的属性        Field age &#x3D; personClass.getDeclaredField(&quot;age&quot;);        age.set(person,21);        System.out.println(person.toString());        &#x2F;&#x2F;反射操作对象的方法        Method show &#x3D; personClass.getMethod(&quot;show&quot;);        show.invoke(person);        System.out.println(&quot;**********&quot;);        &#x2F;&#x2F;通过反射可以调用Person的私有的结构        Constructor&lt;Person&gt; declaredConstructor &#x3D; personClass.getDeclaredConstructor(String.class);        declaredConstructor.setAccessible(true);        Person instance &#x3D; declaredConstructor.newInstance(&quot;加多宝&quot;);        System.out.println(instance);        Field name &#x3D; personClass.getDeclaredField(&quot;name&quot;);        name.setAccessible(true);        name.set(person,&quot;佳铎&quot;);        System.out.println(person);        Method showNation &#x3D; personClass.getDeclaredMethod(&quot;showNation&quot;, String.class);        showNation.setAccessible(true);        showNation.invoke(person,&quot;China&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象"></a>哪些类型可以有Class对象</h3><p>类：<br>接口<br>数组 只要元素类型与纬度一样就是同一个class<br>枚举<br>注解<br>基本数据类型<br>void<br><code>数组 只要元素类型与纬度一样就是同一个class</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] a &#x3D; new int[10];int[] b &#x3D; new int[100];System.out.println(a.getClass()&#x3D;&#x3D;b.getClass()); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="有了Class对象，能做什么？"><a href="#有了Class对象，能做什么？" class="headerlink" title="有了Class对象，能做什么？"></a>有了Class对象，能做什么？</h3><h4 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h4><ol><li>调用Class对象的newInstance()方法<br>要 求：<br> 1）类必须有一个无参数的构造器。<br> 2）类的构造器的访问权限需要足够。通常设置为public<br> 所以在javabean中要求提供public的空参构造器：</li><li>通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器<h4 id="获取运行时类的完-整结构"><a href="#获取运行时类的完-整结构" class="headerlink" title="获取运行时类的完 整结构"></a>获取运行时类的完 整结构</h4>Field、Method、Constructor、Superclass、Interface、Annotation</li></ol><ol><li>实现的全部接口<br><code>public Class&lt;?&gt;[] getInterfaces()</code><br>确定此对象所表示的类或接口实现的接口。</li></ol><ol start="2"><li>所继承的父类  全部的方法 全部的Field<br><code>public Class&lt;? Super T&gt; getSuperclass()</code></li></ol><p>3.全部的构造器<br><code>public Constructor&lt;T&gt;[] getConstructors()</code><br>当前运行时类中所有public构造方法。<br><code>public Constructor&lt;T&gt;[] getDeclaredConstructors()</code><br>返回此 Class 对象表示的类声明的所有构造方法。</p><p>Constructor类中：<br>取得修饰符: <code>public int getModifiers()</code>;<br>取得方法名称: <code>public String getName()</code>;<br>取得参数的类型：<code>public Class&lt;?&gt;[] getParameterTypes()</code>;</p><ol><li>全部的方法<br><code>public Method[] getDeclaredMethods()</code><br>获得当前运行时类中类中的声明的所有方法，包含所有的权限，<strong>（不包括父类中声明的）</strong><br><code>public Method[] getMethods()</code><br>返回此Class对象所表示的<strong>类和父类</strong>中的<strong>public</strong>的方法。<br>Method类中：<br><code>public Class&lt;?&gt; getReturnType()</code>取得全部的返回值<br><code>public Class&lt;?&gt;[] getParameterTypes()</code>取得全部的参数<br><code>public int getModifiers()</code>取得修饰符<br><code>public Class&lt;?&gt;[] getExceptionTypes()</code>取得异常信息</li></ol><p>通过反射，调用类中的方法，通过Method类完成。步骤：<br>1.通过Class类的<code>getMethod(String name,Class…parameterTypes)</code>方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。<br>2.之后使用<code>Object invoke(Object obj, Object[] args)</code>进行调用，并向方法中 传递要设置的obj对象的参数信息。<br>说明：<br>a. Object 对应原方法的返回值，若原方法无返回值，此时返回null<br>b. 若原方法若为静态方法，此时形参Object obj可为null<br>c. 若原方法形参列表为空，则Object[] args为null<br>d. 若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可修改private的方法。</p><p>5.全部的Field<br><code>public Field[] getFields()</code><br>返回此Class对象所表示的<strong>类和父类</strong>中的<strong>public</strong>的Field。<br><code>public Field[] getDeclaredFields()</code><br>获得当前运行时类中类中的声明的所有属性，包含所有的权限，<strong>（不包括父类中声明的属性）</strong><br>Field方法中：<br><code>public int getModifiers()</code> 以整数形式返回此Field的修饰符<br><code>public Class&lt;?&gt; getType()</code> 得到Field的属性类型<br><code>public String getName()</code> 返回Field的名称。</p><p>在Field中：<br><code>public Object get(Object obj)</code> 取得指定对象obj上此Field的属性内容 <code>public void set(Object obj,Object value)</code> 设置指定对象obj上此Field的属性内容</p><ol><li>Annotation相关</li></ol><p><code>get Annotation(Class&lt;T&gt; annotationClass)</code><br><code>getDeclaredAnnotations()</code></p><p>7.泛型相关</p><p>获取父类泛型类型：<code>Type getGenericSuperclass()</code><br>泛型类型：<code>ParameterizedType</code><br>获取实际的泛型类型参数数组：<code>getActualTypeArguments()</code></p><p>8.类所在的包<br><code>Package getPackage()</code></p><hr><h2 id="反射实际的应用"><a href="#反射实际的应用" class="headerlink" title="反射实际的应用"></a>反射实际的应用</h2><h3 id="使用-JDBC-连接数据库"><a href="#使用-JDBC-连接数据库" class="headerlink" title="使用 JDBC 连接数据库"></a>使用 JDBC 连接数据库</h3><p>使用 Class.forName()通过反射加载数据库的驱动程序；</p><h3 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h3><p>IOC（动态加载管理 Bean）创建对象 ：程序启动的时候Spring读取配置文件applicationContext.xml兵解析成标签，反射实例化对象到容器中<br>AOP（动态代理）功能都和反射有联系；</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><pre><code>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原 始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</code></pre><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理，<br>特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。<br>同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。<br>最好可以通过一个代理类完成全部的代理功能。<br>那这个通用的代理类只能是在运行期间才能确定，根据运行过程中看你加载到内存中的的被代理类是谁，动态地帮你去创建代理类，所以的话体现了动态性，要用到反射</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface CloFactory &#123;    public void geneCloth();&#125;&#x2F;&#x2F;被代理类class DressFactory implements CloFactory&#123;    @Override    public void geneCloth() &#123;        System.out.println(&quot;生产Dress&quot;);    &#125;&#125;&#x2F;&#x2F;代理类class ProxyDress implements CloFactory&#123;    private CloFactory cloFactory;    public ProxyDress(CloFactory cloFactory) &#123;        this.cloFactory &#x3D; cloFactory;    &#125;    @Override    public void geneCloth() &#123;        System.out.println(&quot;买材料&quot;);        cloFactory.geneCloth();        System.out.println(&quot;开始售卖&quot;);    &#125;&#125;public class StaticProxyTest&#123;    public static void main(String[] args) &#123;        DressFactory dressFactory &#x3D; new DressFactory();        ProxyDress proxyDress &#x3D; new ProxyDress(dressFactory);        proxyDress.geneCloth();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DynasticProxyTest &#123;    public static void main(String[] args) &#123;        DressFactory dressFactory &#x3D; new DressFactory();        CloFactory proxyInstance &#x3D; (CloFactory) ProxyGeneric.getProxyInstance(dressFactory);        proxyInstance.geneCloth();    &#125;&#125;interface CloFactory &#123;    public void geneCloth();&#125;&#x2F;&#x2F;被代理类class DressFactory implements CloFactory&#123;    @Override    public void geneCloth() &#123;        System.out.println(&quot;生产Dress&quot;);    &#125;&#125;class ProxyGeneric &#123;    &#x2F;&#x2F;得到被代理对象    public static Object getProxyInstance(Object obj)&#123;        MyInvocationHandler handler &#x3D;new MyInvocationHandler();        handler.bind(obj) ;        Object o &#x3D; Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(),handler);        return o ;    &#125;&#125;&#x2F;&#x2F;当我们使用代理类的对象时，调用方法的时候，就会自动调用invoke()class MyInvocationHandler implements InvocationHandler&#123;    Object obj;&#x2F;&#x2F;被代理对象    public void bind(Object obj)&#123;        this. obj &#x3D; obj;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;准备材料&quot;);        Object returnValue &#x3D; method.invoke(obj, args);        System.out.println(&quot;完工&quot;);        return returnValue;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="关于反射的疑问"><a href="#关于反射的疑问" class="headerlink" title="关于反射的疑问"></a>关于反射的疑问</h2><h3 id="怎么看待反射和封装性？？"><a href="#怎么看待反射和封装性？？" class="headerlink" title="怎么看待反射和封装性？？"></a>怎么看待反射和封装性？？</h3><p>封装：解决的是建议怎么调用的问题：表示建议你去调用公共的属性和方法，私有的就使用get set方法去调用<br>反射： 解决的是能不能调用的问题<br>不矛盾</p><h3 id="什么时候使用反射？"><a href="#什么时候使用反射？" class="headerlink" title="什么时候使用反射？"></a>什么时候使用反射？</h3><p>编译的时候确定不下来用那个对象 ，既不能通过new对象的方式来做。这是就可以用反射的方式，反射的特征：动态性（运行期间可以改变其结构的语言）</p><hr><h2 id="类的加载-与ClassLoader的理解"><a href="#类的加载-与ClassLoader的理解" class="headerlink" title="类的加载 与ClassLoader的理解"></a>类的加载 与ClassLoader的理解</h2><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进行初始化。<br>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。</p><p>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<br> 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题<br> 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存 都将在方法区中进行分配。<br> 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</p><p>初始化：执行类构造器<clinit>()方法的过程。<br>类构造器<clinit>()方法是由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的。<br>（类构造器是构造类信息的，不是构造该类对象的构造器）。<br> 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。<br> 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</p><h3 id="什么时候会发生类初始化？"><a href="#什么时候会发生类初始化？" class="headerlink" title="什么时候会发生类初始化？"></a>什么时候会发生类初始化？</h3><p>类的主动引用（一定会发生类的初始化）</p><p>当虚拟机启动，先初始化main方法所在的类<br>new一个类的对象<br>调用类的静态成员（除了final常量）和静态方法<br>使用java.lang.reflect包的方法对类进行反射调用<br>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</p><p>类的被动引用（不会发生类的初始化）</p><p>当访问一个静态域时，只有真正声明这个域的类才会被初始化  当通过子类引用父类的静态变量，不会导致子类初始化</p><p>通过数组定义类引用，不会触发此类的初始化<br>引用常量不会触发此类的初始化（<strong>常量在链接阶段就存入调用类的常量池中了</strong>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ClassLoadingTest &#123;public static void main(String[] args) &#123; &#x2F;&#x2F; 主动引用：一定会导致A和Father的初始化&#x2F;&#x2F; A a &#x3D; new A();&#x2F;&#x2F; System.out.println(A.m); &#x2F;&#x2F; Class.forName(&quot;com.atguigu.java2.A&quot;);&#x2F;&#x2F; 被动引用 A[] array &#x3D; new A[5];&#x2F;&#x2F;不会导致A和Father的初始化&#x2F;&#x2F; System.out.println(A.b);&#x2F;&#x2F;只会初始化 Father&#x2F;&#x2F; System.out.println(A.M);&#x2F;&#x2F;不会导致A和 Father的初始化 &#125;static &#123; System.out.println(&quot;main所在的类&quot;); &#125;class Father &#123;     static int b &#x3D; 2;     static &#123; System.out.println(&quot;父类被加载&quot;);     &#125;     &#125;class A extends Father &#123;static &#123;     System.out.println(&quot;子类被加载&quot;);    m &#x3D; 300;&#125; static int m &#x3D; 100; static final int M &#x3D; 1;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><h3 id="ClassLoader作用"><a href="#ClassLoader作用" class="headerlink" title="ClassLoader作用"></a>ClassLoader作用</h3><p>类加载的作用：将class 文件字节码内容加载到内存中 ，并将这些静态数据 转换成方 法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为 方法区中类数据的访问入口。<br>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</p><p>JVM 规范定义了如下类的加载器。<br>引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，<br><strong>用来装载核心类库</strong>。<strong>该加载器无法直接获取</strong><br>扩展类加载器：负责jre/lib/ext目录下的jar包或 D java.ext.dirs 指定目录下的jar包装入工作库<br>系统类加载器：负责java –classpath 或 –D java.class.path所指的目录下的类与jar包装入工作 ，是最常用的加载器</p><h3 id="ClassLoader获取"><a href="#ClassLoader获取" class="headerlink" title="ClassLoader获取"></a>ClassLoader获取</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;1.获取一个系统类加载器• ClassLoader classloader &#x3D; ClassLoader.getSystemClassLoader();• System.out.println(classloader);• &#x2F;&#x2F;2.获取系统类加载器的父类加载器，即扩展类加载器• classloader &#x3D; classloader.getParent();• System.out.println(classloader);• &#x2F;&#x2F;3.获取扩展类加载器的父类加载器，即引导类加载器• classloader &#x3D; classloader.getParent();• System.out.println(classloader);  &#x2F;&#x2F;null 没有办法获取到• &#x2F;&#x2F;4.测试当前类由哪个类加载器进行加载• classloader &#x3D; Class.forName(&quot;exer2.ClassloaderDemo&quot;).getClassLoader();  • System.out.println(classloader);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于类加载器的一个主要方法：<br><code>getResourceAsStream(String str)</code>:<strong>获取类路径下的指定文件的输入流</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">• InputStream in &#x3D; null;• in &#x3D; this.getClass().getClassLoader().getResourceAsStream(&quot;test.properties&quot;);• System.out.println(in);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Class-forName和classloader-loadClass的区别"><a href="#Class-forName和classloader-loadClass的区别" class="headerlink" title="Class.forName和classloader.loadClass的区别"></a>Class.forName和classloader.loadClass的区别</h3><ol><li>初始化不同:<ul><li>Class.forName()会对类初始化，而loadClass()只会装载或链接。</li><li>foranme在类加载的时候会执行静态代码块，loadclass只有在调用newInstance方法的时候才会执行静态代码块</li></ul></li><li>类加载器不同:<ul><li>Class.forName(String)方法(只有一个参数)，哪个调用了forname就用那个类加载器</li><li>ClassLoader.loadClass()方法是一个实例方法，调用时需要自己指定类加载器</li></ul></li></ol><h2 id="反射会导致性能问题呢？"><a href="#反射会导致性能问题呢？" class="headerlink" title="反射会导致性能问题呢？"></a>反射会导致性能问题呢？</h2><h3>java反射效率低主要是因为：</h3><font color = "orange">Method invoke 会对参数做封装和解封的操作</font>可以看到， invoke方法的参数是object类型的，也就是说。当我们传入的参数是简单类型的话，需要转化为object类型比如说我们传入long类型的话  ，就需要Long.valueOf转型，就生成了Lon的Object,同时传入的是OBject数组的时候，就要额外的封装object数组<p><strong>在反射调用的时候因为封装和解封，这样就产生了不必要的内存的浪费<br>当调用的系数达到一定值的时候，还会导致GC</strong><br><font color = "orange">需要检查方法的可见性</font><br>每次调用都会检查方法的可见性<br><font color = "orange">需要校验参数：</font><br>对参数做校验，就涉及到了参数的解封的操作</p><p><font color = "orange">JIT无法优化：</font><br>反射涉及到动态加载的类型，无法就行JIT优化</p><h2 id="如何避免反射导致的性能问题？"><a href="#如何避免反射导致的性能问题？" class="headerlink" title="如何避免反射导致的性能问题？"></a>如何避免反射导致的性能问题？</h2><ol><li>m.setAccessible(true);<br>由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的</li></ol><ol start="2"><li>用缓存，比如redis, 这个方法提高效率是显而易见的。<br>将反射得到元数据保存起来，使用时，只需从内存中调用即可</li><li>利用一些高性能的反射库，如ReflectASM<br>ReflectASM <strong>使用字节码生成的方式实现了更为高效的反射机制</strong>。执行时会生成一个存取类来 set/get 字段，访问方法或创建实例。一看到 ASM 就能领悟到 ReflectASM 会用字节码生成的方式，而不是依赖于 Java 本身的反射机制来实现的，所以它更快，**并且避免了访问原始类型因自动装箱而产生的问题</li></ol><p>**</p><h2 id="哪些类不能反射"><a href="#哪些类不能反射" class="headerlink" title="哪些类不能反射"></a>哪些类不能反射</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public enum  EnumSingleton &#123;    INSTANCE;    public EnumSingleton getInstance()&#123;        return INSTANCE;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class  EnumSingleton extends Enum&lt; EnumSingleton&gt; &#123;        public static final  EnumSingleton  ENUMSINGLETON;        public static  EnumSingleton[] values();        public static  EnumSingleton valueOf(String s);        static &#123;&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>反射创建，枚举Enum是个抽象类，其实一旦一个类声明为枚举，实际上就是继承了Enum，</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;            implements Comparable&lt;E&gt;, Serializable &#123;        private final String name;        public final String name() &#123;            return name;        &#125;        private final int ordinal;        public final int ordinal() &#123;            return ordinal;        &#125;        protected Enum(String name, int ordinal) &#123;            this.name &#x3D; name;            this.ordinal &#x3D; ordinal;        &#125;        &#x2F;&#x2F;余下省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>会发现并没有我们所设置的无参构造器</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;        EnumSingleton singleton1&#x3D;EnumSingleton.INSTANCE;        EnumSingleton singleton2&#x3D;EnumSingleton.INSTANCE;        System.out.println(&quot;正常情况下，实例化两个实例是否相同：&quot;+(singleton1&#x3D;&#x3D;singleton2));        Constructor&lt;EnumSingleton&gt; constructor&#x3D; null;&#x2F;&#x2F;        constructor &#x3D; EnumSingleton.class.getDeclaredConstructor();        constructor &#x3D; EnumSingleton.class.getDeclaredConstructor(String.class,int.class);&#x2F;&#x2F;其父类的构造器        constructor.setAccessible(true);        EnumSingleton singleton3&#x3D; null;        &#x2F;&#x2F;singleton3 &#x3D; constructor.newInstance();        singleton3 &#x3D; constructor.newInstance(&quot;testInstance&quot;,66);        System.out.println(singleton1+&quot;\n&quot;+singleton2+&quot;\n&quot;+singleton3);        System.out.println(&quot;通过反射攻击单例模式情况下，实例化两个实例是否相同：&quot;+(singleton1&#x3D;&#x3D;singleton3));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">正常情况下，实例化两个实例是否相同：trueException in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects    at java.lang.reflect.Constructor.newInstance(Constructor.java:417)    at com.lxp.pattern.singleton.EnumSingleton.main(EnumSingleton.java:25)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>我们看下Constructor类的newInstance方法源码：</strong></p><pre><code class="java">@CallerSensitive    public T newInstance(Object ... initargs)        throws InstantiationException, IllegalAccessException,               IllegalArgumentException, InvocationTargetException    &#123;        if (!override) &#123;            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;                Class&lt;?&gt; caller = Reflection.getCallerClass();                checkAccess(caller, clazz, null, modifiers);            &#125;        &#125;        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);        ConstructorAccessor ca = constructorAccessor;   // read volatile        if (ca == null) &#123;            ca = acquireConstructorAccessor();        &#125;        @SuppressWarnings(&quot;unchecked&quot;)        T inst = (T) ca.newInstance(initargs);        return inst;    &#125;```**说明反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。**</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="2020/11/28/%E6%B3%9B%E5%9E%8B/"/>
      <url>2020/11/28/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="30-泛型"><a href="#30-泛型" class="headerlink" title="30.泛型"></a>30.泛型</h1><h2 id="30-1：什么是泛型"><a href="#30-1：什么是泛型" class="headerlink" title="30-1：什么是泛型"></a>30-1：什么是泛型</h2><h2 id="泛型好处："><a href="#泛型好处：" class="headerlink" title="泛型好处："></a>泛型好处：</h2><p>编译器检查 ，类型安全<br>减少了数据类型转换<br>泛型可以提⾼代码的复⽤性</p><h2 id="泛型的本质就是参数化类型，也就是所操作的数组类型设计为一个参数"><a href="#泛型的本质就是参数化类型，也就是所操作的数组类型设计为一个参数" class="headerlink" title="泛型的本质就是参数化类型，也就是所操作的数组类型设计为一个参数"></a>泛型的本质就是参数化类型，也就是所操作的数组类型设计为一个参数</h2><h2 id="泛型类，接口"><a href="#泛型类，接口" class="headerlink" title="泛型类，接口"></a>泛型类，接口</h2><p>class 类名&lt;泛型标识，泛型标识&gt;{<br>  private 泛型标识 变量名</p><p>}<br>常见的泛型标识：  T E K V<br>za<br>在创建对象的时候<br>—-  指定具体的数据类型<br>—–  没有指定类型  按照Object来处理</p><p>泛型类不支持基本数据类型，<br>—-因为在使用泛型的时候，真正被编译的时候会把T转换为Object，然后在使用成员的时候在适当的实际转换为T类型<br>                      int 并不是继承自object，<br>同一个泛型类：根据不同的数据类型创建的对象，本质上是统一类型，<br>List<Integer> listint List<String> liststr  .getClass()相同</p><h2 id="泛型类派生子类"><a href="#泛型类派生子类" class="headerlink" title="泛型类派生子类"></a>泛型类派生子类</h2><p>子类是泛型类，子类和父类的泛型类型要一致 ，也可以进行扩展</p><p>子类不是泛型类的时候，父类要明确泛型的具体类型</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>修饰符 &lt;泛型标识&gt;  返回值类型 方法名（形参列表）<br>&lt;泛型标识&gt;表明该方法使用的泛型类型，，这样才可以在方法中使用泛型类型<br>调用方法的时候才能明确具体要使用的数据类型</p><p>泛型方法支持static 但是泛型类和接口不支持</p><p>泛型方法能是方法独立与类而产生变化</p><h2 id="类型通配符-？"><a href="#类型通配符-？" class="headerlink" title="类型通配符 ？"></a>类型通配符 ？</h2><p>一般是以？代替具体的类型实参<br>所以类型通配符是类型实惨 而不是类型的形参</p><p> 上限  ？ extends 类型  该泛型的类型只能是实惨类型或者是实惨类型的子类类型<br> get 能用类型接受<br> add 不能添加 比如是minicat 但是却add了cat就不行</p><p>下限  ？ super 类型  该泛型的类型只能是实惨类型或者是实惨类型的父类类型</p><h2 id="30-2：编译器如何处理泛型"><a href="#30-2：编译器如何处理泛型" class="headerlink" title="30-2：编译器如何处理泛型"></a>30-2：编译器如何处理泛型</h2><ol><li>Code specialization：在实例化一个泛型类或泛型方法时<pre><code>                 都产生一份新的字节码or二进制代码。</code></pre></li><li>Code sharing：对每个泛型类只生成唯一的一份目标代码；<pre><code>          该泛型类的所有实例都映射到这份目标代码上，          在需要的时候执行类型检查和类型转换。</code></pre></li></ol><h3 id="30-2-1：为什么Java要用这种编译器"><a href="#30-2-1：为什么Java要用这种编译器" class="headerlink" title="30-2-1：为什么Java要用这种编译器"></a>30-2-1：为什么Java要用这种编译器</h3><ol><li>C++和C#是使用Code specialization的处理机制，他有几个缺点:<ul><li>导致代码膨胀。</li><li>在引用类型系统中，浪费空间</li></ul></li><li>Java编译器通过Code sharing方式为每个泛型类型创建唯一的字节码表示，<br>并且将该泛型类型的实例都映射到这个唯一的字节码表示上。<br>将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</li></ol><h2 id="30-3-什么是类型擦除"><a href="#30-3-什么是类型擦除" class="headerlink" title="30-3: 什么是类型擦除"></a>30-3: 什么是类型擦除</h2><p>泛型是jdk1.5才引进的概念，在这之前是没有泛型的，<br>但是泛型的代码能够很好地和之前版本的版本兼容。<br>**那是因为，泛型的信息只存在与代码的编译阶段，在进入到JVM之前，与泛型相关的信息回被擦除掉，我们就称之为是泛型擦除<br>**</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> listInt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> listStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listInt<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>listStr<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="无限制类型擦除"><a href="#无限制类型擦除" class="headerlink" title="无限制类型擦除"></a>无限制类型擦除<T></h3><pre><code>    T在生成字节码文件的过程中用Object代替了</code></pre><h3 id="有限制类型擦除"><a href="#有限制类型擦除" class="headerlink" title="有限制类型擦除"></a>有限制类型擦除<T extends Number></h3><pre><code>    T用Number代替</code></pre><h3 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h3><h2 id="30-3-1：类型擦除过程"><a href="#30-3-1：类型擦除过程" class="headerlink" title="30-3-1：类型擦除过程"></a>30-3-1：类型擦除过程</h2><ol><li>将所有的泛型参数用最顶级的父类型进行替换。 </li><li>移除所有的类型参数</li></ol><p>Java的泛型基本上都是在编译器这个层次上实现的，<br>在生成的字节码中是不包含泛型中的类型信息的，<br>使用泛型的时候加上类型参数，<br>在编译器编译的时候会去掉，<br>这个过程成为类型擦除。</p><h2 id="30-4：泛型带来的问题"><a href="#30-4：泛型带来的问题" class="headerlink" title="30-4：泛型带来的问题"></a>30-4：泛型带来的问题</h2><ol><li>虚拟机中没有泛型，只有普通类和普通方法,<br>所有泛型类的类型参数在编译时都会被擦除,<br>泛型类并没有自己独有的Class类对象。<br>比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。 </li><li>创建泛型对象时需要指明类型，让编译器尽早的做参数检查</li><li>不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你。 </li><li>静态变量是被泛型类的所有实例所共享的。 </li><li>泛型的类型参数不能用在Java异常处理的catch语句中。</li></ol><h2 id="30-5：泛型应用"><a href="#30-5：泛型应用" class="headerlink" title="30-5：泛型应用"></a>30-5：泛型应用</h2><h3 id="30-5-1：List泛型和原始类型List之间的区别"><a href="#30-5-1：List泛型和原始类型List之间的区别" class="headerlink" title="30-5-1：List泛型和原始类型List之间的区别?"></a>30-5-1：List泛型和原始类型List之间的区别?</h3><p> List<Object>和原始类型List之间的区别?</p><ol><li>在编译时编译器不会对原始类型进行类型安全检查，会对带参数的类进行检查</li><li>你可以把任何带参数的类型传递给原始类型List，但是list会产生编译错误</li></ol><h3 id="30-5-2：List泛型和原始类型List泛型之间的区别"><a href="#30-5-2：List泛型和原始类型List泛型之间的区别" class="headerlink" title="30-5-2：List泛型和原始类型List泛型之间的区别?"></a>30-5-2：List泛型和原始类型List泛型之间的区别?</h3><p>List&lt;?&gt;和原始类型List<Object>之间的区别?</p><p>List<?>是一个未知类型的List，而List<Object> 其实是任意类型的List。你可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给 List<Object>。</p><h3 id="30-5-3-子类继承父类的public可以写成private吗"><a href="#30-5-3-子类继承父类的public可以写成private吗" class="headerlink" title="30-5-3:子类继承父类的public可以写成private吗"></a>30-5-3:子类继承父类的public可以写成private吗</h3><p>可以写，但是变为private之后，需要对方法重写写get/set方法</p><h3 id="30-5-4：多态时是否会出现类型擦除"><a href="#30-5-4：多态时是否会出现类型擦除" class="headerlink" title="30-5-4：多态时是否会出现类型擦除"></a>30-5-4：多态时是否会出现类型擦除</h3><p>会出现类型擦除<br>编译器在编译一个继承自泛型类的子类时，<br>为了方法覆盖的签名匹配，保留泛型类型的多态性，会生成一个桥接方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="2020/11/28/%E6%B3%A8%E8%A7%A3/"/>
      <url>2020/11/28/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<font color = gold ><p>都说框架=反射+注解+设计模式<br>那么接着就来总结一下关于注解的知识把～～</p></font><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="元注解以及分类"><a href="#元注解以及分类" class="headerlink" title="元注解以及分类"></a>元注解以及分类</h2><p>定义其他注解的注解 ，共四个</p><ol><li>@Target（表示该注解可以用于什么地方）</li><li>@Retention（表示再什么级别保存该注解信息）</li><li>@Documented（将此注解包含再javadoc中）</li><li>@Inherited（允许子类继承父类中的注解）</li></ol><h2 id="Java常用注解"><a href="#Java常用注解" class="headerlink" title="Java常用注解"></a>Java常用注解</h2><ol><li>@Override 表示当前方法覆盖了父类的方法</li><li>@Deprecation 表示方法已经过时,方法上有横线，使用时会有警告。</li><li>@SuppressWarnings 表示关闭一些警告信息(通知java编译器忽略特定的编译警告)</li><li>SafeVarargs (jdk1.7更新) 表示：专门为抑制“堆污染”警告提供的。</li><li>@FunctionalInterface (jdk1.8更新) 表示：用来指定某个接口必须是函数式接口，否则就会编译出错。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建线程？几种方式？</title>
      <link href="2020/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%9F/"/>
      <url>2020/11/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么创建线程"><a href="#怎么创建线程" class="headerlink" title="怎么创建线程"></a>怎么创建线程</h2><p><strong>JDK1.5之前</strong>创建新执行线程有两种方法：</p><h3 id="继承Thread类的方式"><a href="#继承Thread类的方式" class="headerlink" title="继承Thread类的方式"></a>继承Thread类的方式</h3><p><strong>方式一：继承Thread类</strong></p><ol><li><p>定义子类继承Thread类。</p></li><li><p>子类中重写Thread类中的run方法。</p></li><li><p>创建Thread子类对象，即创建了线程对象。</p></li><li><p>调用线程对象start方法</p></li></ol><h3 id="实现Runnable接口的方式"><a href="#实现Runnable接口的方式" class="headerlink" title="实现Runnable接口的方式"></a>实现Runnable接口的方式</h3><p>方式二：实现Runnable接口</p><ol><li><p>定义子类，实现Runnable接口。</p></li><li><p>子类中重写Runnable接口中的run方法。</p></li><li><p>通过Thread类含参构造器创建线程对象。</p></li><li><p>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</p></li><li><p>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</p></li></ol><p>public class Thread extends Object implements Runnable<br>都需要重写run方法，</p><h2 id="实现方式的好处"><a href="#实现方式的好处" class="headerlink" title="实现方式的好处"></a><code>实现方式的好处</code></h2><ol><li>避免了单继承的局限性s extends Thread就不能继承其他的父类了</li><li><code>多个线程可以共享同一个接口实现类的对象</code>，非常适合多个相同线程来处理同一份资源。 </li><li><code>以继承的方式的共享数据的话就需要写static</code></li></ol><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与使用Runnable相比， Callable功能更强大些</p><p><strong>run()方法，<br>可以有返回值<br>方法可以抛出异常<br>支持泛型的返回值</strong><br>需要借助FutureTask类，比如获取返回结果<br>FutureTask 同时实现了Runnable, Future接口。它既可以作为 Runnable被线程执行，又可以作为Future得到Callable的返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;Integer&gt;(new MyThread03());        new Thread(futureTask).start();        try &#123;            Integer value &#x3D; futureTask.get();&#x2F;&#x2F;            System.out.println(value);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; catch (ExecutionException e) &#123;            e.printStackTrace();        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h3><p>比如并发情况下请求树多，且每个线程的执行时间端的情况下，经常创建和销毁线程 对性能影响很大。<br>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完 放回池中。可以避免频繁创建销毁、实现重复利用。<br>好处：</p><p>提高响应速度（减少了创建新线程的时间）<br>降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>便于线程管理<br> corePoolSize：核心池的大小<br> maximumPoolSize：最大线程数<br> keepAliveTime：线程没有任务时最多保持多长时间后会终止</p><p>JDK 5.0起提供了线程池相关API：<br>ExecutorService 和 Executors<br>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor</p><p><code>void execute(Runnable command)</code> ：执行任务/命令，没有返回值，一般用来执行 Runnable<br><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务，有返回值，一般又来执行 Callable<br><code>void shutdown() ：关闭连接池</code></p><p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p><p><code>Executors.newCachedThreadPool()</code>：创建一个可根据需要创建新线程的线程池<br><code>Executors.newFixedThreadPool(n)</code>; 创建一个可重用固定线程数的线程池<br><code>Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池<br><code>Executors.newScheduledThreadPool(n)</code>：创建一个线程池，它可安排在给定延迟后运 行命令或者定期地执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;&#x2F;&#x2F;创建并使用多线程的第四种方法：使用线程池class MyThread implements Runnable &#123;@Overridepublic void run() &#123;for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);&#125;&#125;&#125;public class ThreadPool &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 1.调用Executors的newFixedThreadPool(),返回指定线程数量的ExecutorServiceExecutorService pool &#x3D; Executors.newFixedThreadPool(10);&#x2F;&#x2F; 2.将Runnable实现类的对象作为形参传递给ExecutorService的submit()方法中，开启线程&#x2F;&#x2F; 并执行相关的run()pool.execute(new MyThread());pool.execute(new MyThread());pool.execute(new MyThread());&#x2F;&#x2F; 3.结束线程的使用pool.shutdown();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><h3 id="使用两个线程打印-1-100。线程1-线程2-交替打印"><a href="#使用两个线程打印-1-100。线程1-线程2-交替打印" class="headerlink" title="使用两个线程打印 1-100。线程1, 线程2 交替打印"></a>使用两个线程打印 1-100。线程1, 线程2 交替打印</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu;public class ThreadCommunication&#123;    public static void main(String[] args) &#123;        PrintNumber printNumber &#x3D; new PrintNumber();        Thread thread &#x3D; new Thread(printNumber, &quot;分线程1&quot;);        Thread thread1 &#x3D; new Thread(printNumber, &quot;分线程11&quot;);        thread.start();        thread1.start();    &#125;&#125;class PrintNumber implements Runnable&#123;    int number &#x3D; 1;    @Override    public void run() &#123;        while(true)&#123;            synchronized (this)&#123;                notify();                if (number&lt;&#x3D;100)&#123;                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+number);                    number++;                &#125;else &#123;                    break;                &#125;                try &#123;                    wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="wait-与-notify-和-notifyAll"><a href="#wait-与-notify-和-notifyAll" class="headerlink" title="wait() 与 notify() 和 notifyAll()"></a>wait() 与 notify() 和 notifyAll()</h3><p>wait()：令当前线程阻塞，并释放锁，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</p><p>notify()：唤醒被wait的一个线程， 如果说有多个线程被阻塞的话。就唤醒优先级最高的那个<br>notifyAll ()：唤醒所有wait线程</p><p><code>这三个方法只有在synchronized方法或synchronized代码块中才能使用</code>，</p><p><code>这三个方法的调用者必须是同步监视器</code>，否则会报 java.lang.`IllegalMonitorStateException异常。</p><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处 取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如 果店中有产品了再通知消费者来取走产品。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Clerk &#123;     &#x2F;&#x2F; 售货员     private int product &#x3D; 0;     public synchronized void addProduct() &#123;         if (product &gt;&#x3D; 20) &#123;             try &#123;                 wait();             &#125; catch (InterruptedException e) &#123;                e.printStackTrace(); &#125;&#125; else &#123;     product++;     System.out.println(&quot;生产者生产了 第&quot; + product + &quot;个产品&quot;);     notifyAll();public synchronized void getProduct() &#123;     if (this.product &lt;&#x3D; 0) &#123;         try &#123;             wait();             &#125; catch (InterruptedException e) &#123;                 e.printStackTrace();                 &#125;                 &#125; else &#123;                     System.out.println(&quot;消费者取走了第&quot; + product + &quot;个产品&quot;); product--; notifyAll();                     &#125;                &#125;             &#125;    &#125;&#125;class Productor implements Runnable &#123; &#x2F;&#x2F; 生产者     Clerk clerk;    public Productor(Clerk clerk) &#123; this.clerk &#x3D; clerk; &#125;    public void run() &#123;    System.out.println(&quot;生产者开始生产产品&quot;);     while (true) &#123;         try &#123;         Thread.sleep((int) Math.random() * 1000);         &#125; catch (InterruptedException e) &#123;             e.printStackTrace(); &#125;              clerk.addProduct();              &#125;    &#125;&#125;class Consumer implements Runnable &#123; &#x2F;&#x2F; 消费者     Clerk clerk; public Consumer(Clerk clerk) &#123; this.clerk &#x3D; clerk; &#125;    public void run() &#123;    System.out.println(&quot;消费者开始取走产品&quot;);     while (true) &#123; try &#123;         Thread.sleep((int) Math.random() * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;         clerk.getProduct(); &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><h2 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a><code>synchronized 与 Lock 的对比</code></h2><ol><li><p>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），<br>synchronized是 隐式锁，出了作用域自动释放<br>当前线程的同步方法、同步代码块执行结束。<br>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、 该方法的继续执行。<br>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。<br>当前线程在同步代码块、同步方法中执行了线程对象的<code>wait()</code>方法，<code>当前线程暂停，并释放锁。</code></p></li><li><p>Lock只有代码块锁，<br>synchronized有代码块锁和方法锁</p></li><li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性（提供更多的子类）</p></li></ol><h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><ol start="5"><li>run()方法由JVM调用，<strong>什么时候调用，执行的过程控制都有操作系统的CPU 调度决定。</strong></li></ol><ol start="6"><li><strong>一个线程对象只能调用一次start()方法</strong>启动，如果重复调用了，则将抛出以上 的异常“<code>IllegalThreadStateException</code>”。<br>常用方法：<br><code>static Thread yield()</code>:释放当前线程cpu的执行权 ，下一时刻还可以再获取到<br><code>join()</code>:当a线程调用b线程的 join() 方法时，<code>a线程将被阻塞</code>，直到b线程执行完为止,a线程才结束阻塞<br><code>static void sleep(long millis)</code>：(指定时间:毫秒)<br>令当前活动线程在<strong>指定时间段内放弃对CPU控制</strong>,使其他线程有机会被执行,<strong>时间到后重排队</strong>。 抛出InterruptedException异常<br>stop(): 强制线程生命期结束，不推荐使用<br>boolean isAlive()：返回boolean，判断线程是否还活着</li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/23/javaweb%E7%AC%94%E8%AE%B0-----javascript/"/>
      <url>2020/11/23/javaweb%E7%AC%94%E8%AE%B0-----javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li><p>变量声明，javascript弱类型语言，动态类型语言运行期间可以任意赋值<br> var i = 0;<br> i = true;<br> i = “hi”;<br> alert(i);<br> var str= “helloworld”;<br> alert(str);</p></li><li><p>变量赋值</p></li><li><p>变量严格区分大写小写</p></li><li><p>数据类型<br> String ， number 布尔 数组  对象 null Undefined(只声明不赋值)</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用function声明</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/22/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/cookie--session/"/>
      <url>2020/11/22/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/cookie--session/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81-id%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81-id%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单体项目--准备工作</title>
      <link href="2020/11/20/%E7%94%B5%E5%95%86%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
      <url>2020/11/20/%E7%94%B5%E5%95%86%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="电商项目：单体架构设计于项目开发"><a href="#电商项目：单体架构设计于项目开发" class="headerlink" title="电商项目：单体架构设计于项目开发"></a>电商项目：单体架构设计于项目开发</h1><h1 id="基于SpringBoot2-x"><a href="#基于SpringBoot2-x" class="headerlink" title="基于SpringBoot2.x"></a>基于SpringBoot2.x</h1><p>实现单体电商项目核心功能开发</p><p>实现单体电商项目个人中心功能</p><p>项目部署上线</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>项目展示以及主要的功能：轮播图<br>                    主页不同分类<br>                    根据页面的滚动慢慢的进行加载：在前端设计的调用模式<br>                    首页搜索功能：输入关键词 页面跳转<br>                    分页功能<br>                    默认排序 销量排序 价格有限 排序规则<br>                    购物车<br>                    支付<br>                    没有登录的话就登录<br>                    登录功能 回调到购物车<br>                    结算页面  地址 可以进行编辑 选择<br>                    微信支付 支付宝支付<br>                    查看我的订单 跳转到个人中心<br>                    个人中心：代发货<br>                    其中就是订单<br>                    我的评价<br>                    我的信息<br>                    收货地址</p><h2 id="前后段主要技术选型"><a href="#前后段主要技术选型" class="headerlink" title="前后段主要技术选型"></a>前后段主要技术选型</h2><p>后段技术选型<br><code>SpringBoot Spring Mybatis</code> 框架整合</p><p>SpringBoot还是SpringMVC??<br>SpringMVC是框架  配置项很多就很繁琐<br>                还得自己下载tomcat<br>SpringBoot是框架：主要实现了自动配置，<br>                从xml配置繁琐到yml，<br>                还集成了很多的中间件，用starter依赖和引用，简化了maven配置<br>                从外置的tomcat变为内置的tomcat，在yaml就可以配置</p><p>前端技术选型：<br>        Jquery<br>        VUE本身是渐进式框架，方便。在渐进式过程中可以逐步逐步去替换掉原来的代码<br>        html<br>        css</p><p>技术选型要考虑到的：<br>    切合业务<br>    社区活跃度：代表使用率高，优缺点<br>    团队技术水平<br>    版本更新迭代的周期：以前Dubbo中间停更了一段时间，那么这段时间就会影响业务的使用<br>    安全性<br>    成功案例：口碑不错的</p><h2 id="前后端分离开发模式："><a href="#前后端分离开发模式：" class="headerlink" title="前后端分离开发模式："></a>前后端分离开发模式：</h2><p>早起传统的JAVAweb开发模式：<br>                      用户 – 浏览器 -url–服务器 war包(后段model,view,controller 前端html(jsp渲染成html)cssjs)  只要有用户访问服务器，所有请求的页面都在服务器进行渲染。当用户越来越多的话， 所有页面都在服务器进行渲染，服务器压力太大了了。<br>                      需要注意的是  传统web开发 ，浏览器请求到的服务器的所有页面都是基于url来进行跳转的</p><p>前后端单页面的交互：mvvm前端开发模式<br>                        手机  – 小程序/安卓—- ———–服务器model,view<br>                      用户—-浏览器–h5–nginx（html css js）–Restful webservice&gt;-服务器model,view,controller静态资源在静态资源服务器上，<br>                      前端龟前端，后端代码只要一套极好了</p><h2 id="数据库表设计："><a href="#数据库表设计：" class="headerlink" title="数据库表设计："></a>数据库表设计：</h2><p>全局的规划，数据库表设计工具设计库以及表，前期就设计好的<br><code>PDMan</code>:<br>            数据库建模工具<br>            设置：预处理的模版， 每次新建表的时候都会生成<br>            数据库设置：<br>            如何把关系图和数据库的表进行对应：模型版本–初始化基线写版本号-点击同步，注意同步配置里选的必须是增量</p><hr><h3 id="我们的设计库表中没有使用数据库外键"><a href="#我们的设计库表中没有使用数据库外键" class="headerlink" title="我们的设计库表中没有使用数据库外键"></a>我们的设计库表中没有使用数据库外键</h3><p>1，性能影响</p><p>对于数据的完整性会做检查操作，特别是在大并发的时候，会影响性能</p><p>2，热更新（不停机维护）<br>如果有外键的话，是强一致性的，使的新更新的代码无法运行，需要重启服务。而我们希望不停机维护。</p><p>3 降低耦合度</p><p>物理外键不存在，逻辑外键还是存在的，比如说cghtb有htbh字段，htmxb也有htbh字段</p><p>4 数据库分库发表<br>有外键关系的两张表，难以做到分到两个不同的数据库，因为耦合度是在是太高了。</p><hr><h2 id="项目结构搭建"><a href="#项目结构搭建" class="headerlink" title="项目结构搭建"></a>项目结构搭建</h2><h3 id="项目拆分与聚合："><a href="#项目拆分与聚合：" class="headerlink" title="项目拆分与聚合："></a>项目拆分与聚合：</h3><p>后段分层架构模式：基于maven分层与拆分<br>项目分层设计原则<br>前期拆分：根据业务拆分为不同的子模块<br>后期聚合：通过<code>maven</code>项目的聚合</p><p>jar                             common.jar子模块/工程  pojo.jar(数据库表逆向生成)  mapper.jar<br>或者        —-                service.jar  controller.jar     。。。<br>war<br>最终运行的包                      pom聚合工程  所有子模块都在聚合工程里面</p><p>这样的话就可以很多人进行开发<br>多个不同的项目可以都导入common的依赖不用多次写代码，</p><h3 id="Idea构建：具体操作的话可以参考https-blog-csdn-net-weixin-43434182-article-details-108017186"><a href="#Idea构建：具体操作的话可以参考https-blog-csdn-net-weixin-43434182-article-details-108017186" class="headerlink" title="Idea构建：具体操作的话可以参考https://blog.csdn.net/weixin_43434182/article/details/108017186"></a>Idea构建：具体操作的话可以参考<a href="https://blog.csdn.net/weixin_43434182/article/details/108017186">https://blog.csdn.net/weixin_43434182/article/details/108017186</a></h3><pre><code> 1. 拆分：        父工程由于构建的是聚合工程，所以打包方式选择pom        构建pojo，pojo引用common        构建mapper，mapper引用pojo，        构建service，service引用mapper，        构建api，api引用service    聚合：root --install 之后依赖关系才会真正的建立2. 父工程整合spring boot   pom.xml引入spring boot基础依赖</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.imooc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>foodie-dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--        1.聚合工程可以分顶级项目（顶级工程，父工程）和子工程，两者之间为继承关系        子工程在maven中称之为module，模块之间时平级的，可以相互依赖        2.子工程可以使用父工程所有的资源（依赖），子工程之间如果需要相互之间使用资源，需要构建依赖（构建关系）        3.父工程可以由多个子工程组合而成    --></span>    <span class="token comment" spellcheck="true">&lt;!--所有的子工程都会在这里出现--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-common<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-pojo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-mapper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 聚合工程打包方式选择pom--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--引入依赖parent,统一管理版本--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--设置资源属性--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--设置源码编码格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--设置编译后文件编码格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!--排除这一块依赖，后续引入其他依赖--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--spring boot可以解析yml文件，如果想解析xml等非yml配置文件，需要此依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-configuration-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span>然后在controller层就可以在resource下创建application.yml</code></pre><p>然后编写启动类<br>    <code>java     @SpringBootApplication     public class Application &#123;         public static void main(String[] args) &#123;             SpringApplication.run(Application.class,args);         &#125;     &#125;     </code></p><p>然后，因为是聚合项目，需要先install子项目，使其成为主项目的依赖，然后启动项目</p><hr><p>mybatis mysql mapper<br>导入依赖<br>写配置文件<br>mybatis逆向生成工具:打开项目，主要修改generatorConfig.xml文件,然后GeneratorDisplay，右键运行，生成相应的文件，<br>复制到项目中，因为引用了通用mapper，需要在项目中进行相应的配置</p><p>Restful<br>api service 层开发<br><code>Postman</code>调试Restful接口</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8 9 10新特性</title>
      <link href="2020/11/20/java8910%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>2020/11/20/java8910%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p><code>Lambda 表达式</code>：在Java 8 语言中引入的一种新的语法元素和操 作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符 或箭头操作符。它将 Lambda 分为两个部分：<br><code>接口中有且仅有一个抽象方法，但是允许有其他实现的default方法</code><br><code>左侧</code>：指定了 Lambda 表达式需要的参数列表<br><strong>数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</strong><br><strong>Lambda 若只需要一个参数时，参数的小括号可以省略</strong><br><code>右侧</code>：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。<br><strong>当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</strong></p><h2 id="函数式-Functional-接口"><a href="#函数式-Functional-接口" class="headerlink" title="函数式(Functional)接口"></a>函数式(Functional)接口</h2><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h2 id="强大的Stream-API"><a href="#强大的Stream-API" class="headerlink" title="强大的Stream API"></a>强大的Stream API</h2><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者---线程通信</title>
      <link href="2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      
        <content type="html"><![CDATA[<p>题目：现在两个线程，可以操作初始值为零的变量，<br>实现一个线程+1，一个线程减1；<br>交替打印 来10轮 变量初始值为零</p><font color='orange' ><ol><li><p><code>线程操作资源类</code>：高内聚低耦合</p></li><li><p>通信：不符合条件判断等待，业务逻辑，唤醒；</p></li><li><p>多线程交互中，必须要防止多线程的<code>虚假唤醒</code>，也即在多线程判断中不许用if，就要用while</p></li></ol></font><hr><h2 id="synchronized-wait-notifyAll"><a href="#synchronized-wait-notifyAll" class="headerlink" title="synchronized+wait+notifyAll"></a>synchronized+wait+notifyAll</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Opera&#123;    private int num &#x3D; 0;    public synchronized void incrnum() throws InterruptedException &#123;        while(num!&#x3D;0)&#123;            this.wait();        &#125;        num++;        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num);        this.notifyAll();    &#125;    public synchronized void decrnum() throws InterruptedException &#123;        while(num&#x3D;&#x3D;0)&#123;            this.wait();        &#125;        num--;        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num);        this.notifyAll();    &#125;    public static void main(String[] args) &#123;        Opera op &#x3D; new Opera();        Thread b &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.decrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;b&quot;);        Thread a &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.incrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;a&quot;);        Thread c &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.incrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;c&quot;);        Thread d &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.decrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;d&quot;);        a.start();        b.start();        c.start();        d.start();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Lock-await-signalAll"><a href="#Lock-await-signalAll" class="headerlink" title="Lock+await+signalAll"></a>Lock+await+signalAll</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Opera1&#123;    private int num &#x3D; 0;    private  Lock lock &#x3D;new ReentrantLock();    private Condition condition &#x3D; lock.newCondition();    public void incrnum() throws InterruptedException &#123;        lock.lock();        try &#123;            while(num!&#x3D;0)&#123;                condition.await();            &#125;            num++;            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num);            condition.signalAll();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public  void decrnum() throws InterruptedException &#123;        lock.lock();        try &#123;            while(num&#x3D;&#x3D;0)&#123;                condition.await();            &#125;            num--;            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+num);            condition.signalAll();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;public static void main(String[] args) &#123;        Opera1 op &#x3D; new Opera1();        Thread b &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.decrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;b&quot;);        Thread a &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.incrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;a&quot;);        Thread c &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.incrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;c&quot;);        Thread d &#x3D; new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                try &#123;                    op.decrnum();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;d&quot;);        a.start();        b.start();        c.start();        d.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="精确通知顺序访问"><a href="#精确通知顺序访问" class="headerlink" title="精确通知顺序访问"></a>精确通知顺序访问</h2><font color='orange' ><ol><li><p><code>线程操作资源类</code>：高内聚低耦合</p></li><li><p>通信：不符合条件判断等待，业务逻辑，唤醒；</p></li><li><p>多线程交互中，必须要防止多线程的<code>虚假唤醒</code>，也即在多线程判断中不许用if，就要用while</p></li><li><p>标识位</p></li></ol></font><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class OrderCommunition &#123;    public static void main(String[] args) &#123;        OrderPrint orderPrint &#x3D; new OrderPrint();        new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 3; i++) &#123;                try &#123;                    orderPrint.print1();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();        new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 3; i++) &#123;                try &#123;                    orderPrint.print2();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();        new Thread(()-&gt;&#123;            for (int i &#x3D; 0; i &lt; 3; i++) &#123;                try &#123;                    orderPrint.print3();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;A&quot;).start();    &#125;&#125;class OrderPrint&#123;    private  int number &#x3D; 1;    private Lock lock &#x3D; new ReentrantLock();    private Condition condition1&#x3D; lock.newCondition();    private Condition condition2&#x3D; lock.newCondition();    private Condition condition3&#x3D; lock.newCondition();    public void print1() throws InterruptedException &#123;        lock.lock();        try &#123;            while(number!&#x3D;1)&#123;                condition1.await();            &#125;            for (int i &#x3D; 0; i &lt; 5; i++) &#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;            number&#x3D;2;            condition2.signal();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void print2() throws InterruptedException &#123;        lock.lock();        try &#123;            while(number!&#x3D;2)&#123;                condition2.await();            &#125;            for (int i &#x3D; 0; i &lt; 10; i++) &#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;            number&#x3D;3;            condition3.signal();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void print3() throws InterruptedException &#123;        lock.lock();        try &#123;            while(number!&#x3D;3)&#123;                condition3.await();            &#125;            for (int i &#x3D; 0; i &lt; 5; i++) &#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;            number&#x3D;1;            condition1.signal();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全如何保证？</title>
      <link href="2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="线程的安全"><a href="#线程的安全" class="headerlink" title="线程的安全"></a>线程的安全</h2><ol><li><code>synchronized</code><h3 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h3><code>同步方法的锁</code>：静态方法（类名.class）、非静态方法（this）<br><code>同步代码块</code>：自己指定，很多时候也是指定为this或类名.class<br>必须确保使用<code>同一个资源的多个线程共用一把锁</code> ，这个非常重要 ，否则就无法保证共享资源的安全<br><code>一个线程类中的所有静态方法共用同一把锁（类名.class）</code>，<br><code>所有非静态方法共用同一把锁（this）</code><br>同步代码块（指定需谨慎）<br>必须是同一把锁<br> <code>注意的是</code><br>在Thread中要谨慎使用this作为同步监视器 ，因为都是new thread() 多线程调用的时候不是同一把锁<br>而在Runnable的时候， 多个线程通过共同实现Runnable接口，所以的话可以使用this作为同步监视器</li></ol><h3 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h3><p>当前线程的同步方法、同步代码块执行结束。<br>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、 该方法的继续执行。<br>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。<br>当前线程在同步代码块、同步方法中执行了线程对象的<code>wait()</code>方法，<code>当前线程暂停，并释放锁。</code><br> 2.  Lock(锁)</p><p>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。<br>java.util.concurrent.locks.<code>Lock接口</code>是控制多个线程对共享资源进行访问的 工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p><p><code>ReentrantLock </code>类实现了 Lock ，它拥有与 synchronized 相同的并发性和 内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以 显式加锁、释放锁。<br>非公平锁：十分不公平：可以插队 （默认）</p><p>严格按照规范来写   lock.lock(); 在try外面</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class A&#123;private final ReentrantLock lock &#x3D; new ReenTrantLock(); public void m()&#123;lock.lock(); try&#123;&#x2F;&#x2F;保证线程安全的代码; &#125; finally&#123;lock.unlock(); &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁的学习案例--理解</title>
      <link href="2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B--%E7%90%86%E8%A7%A3/"/>
      <url>2020/11/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B--%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a><code>加深理解</code></h2><ol><li>如果说同一个类中有多个非static的synchronized的时候，某一个时刻内，只能一个线程去调用其中的一个Synchronized方法</li><li>sleep是不会释放锁的</li><li>不同点的线程可以同时访问synchronized方法和普通方法</li><li>如果锁的不是同一个对象时，可以同时访问</li><li>静态同步方法，多个线程都是锁的同一个字节码</li><li>静态同步方法和对象不是同一个锁</li></ol>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="2020/11/20/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>2020/11/20/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>redis  6.0.8</p><p><code>分布式锁</code> ： 在分布式架构中 拆分哥哥微服务之后 为了避免冲突和数据故障而加入的一种锁</p><p>mysql<br>zookeeper<br>redis<br>一班大家都习惯redis分布式锁</p><p>redis—redlock ====redission lock  unlock</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="2020/11/20/maven/%E4%BB%80%E4%B9%88%E6%98%AFmaven/"/>
      <url>2020/11/20/maven/%E4%BB%80%E4%B9%88%E6%98%AFmaven/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用maven"><a href="#为什么要使用maven" class="headerlink" title="为什么要使用maven"></a>为什么要使用maven</h2><p>Maven是干什么用的？们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。<br>1.1 添加第三方jar包<br>在今天的JavaEE开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些jar包最简单的方法就是复制粘贴到 <code>WEB-INF目录下的lib目录</code>下。但是这会导致每次创建一个新的工程就需要将jar包重复复制到lib目录下，从而造成工作区中存在<code>大量重复</code>的件。<br>使用Maven后每个jar包只在<code>本地仓库</code>中保存<code>一份</code>，需要jar包的工程只需要维护一个文本形式的jar包的引用——我们称之为“<code>坐标</code>”。不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。<br>1.2 jar包之间的依赖关系<br>jar包往往不是孤立存在的，很多jar包都需要在其他jar包的支持下才能够正常工作，我们称之为jar包之间的依赖关系。<br>那么问题来了，你知道你所使用的所有jar包的依赖关系吗？<br>当你拿到一个新的从未使用过的jar包，你如何得知他需要哪些jar包的支持呢？如果不了解这个情况，导入的jar包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个jar包时，你还会人为的，手工的逐一确认它们依赖的其他jar包吗？这简直是不可想象的。<br><strong>引入Maven后</strong>，Maven就可<strong>以替我们自动的将当前jar包所依赖的其他所有jar包全部导入进来，无需人工参与，</strong>节约了我们大量的时间和精力<br>1.3 处理jar包之间的冲突<br>上一点说的是jar包不足项目无法正常工作，但其实有的时候jar包多了项目仍然无法正常工作，这就是jar包之间的冲突。<br>举个例子：我们现在有三个工程MakeFriend、HelloFriend、和Hello。MakeFriend依赖HelloFriend，HelloFriend依赖Hello。而Hello依赖log4j.1.2.17.jar，HelloFriend依赖log4j.1.2.14.jar。<br>那么MakeFriend工程的运行时环境中该导入log4j.1.2.14.jar呢还是log4j.1.2.17.jar呢？<br>这样的问题一个两个还可以手工解决，但如果系统中存在几十上百的jar包，他们之间的依赖关系会非常复杂，几乎不可能手工实现依赖关系的梳理。<br>使用Maven就可以自动的处理jar包之间的冲突问题。因为Maven中内置了两条依赖原则：   **<code>最短路径者优先和先声明者优先</code>**，上述问题MakeFriend工程会自动使用log4j.1.2.14.jar。<br>1.4 获取第三方jar包<br>JavaEE开发中需要使用到的jar包种类繁多，几乎每个jar包在其本身的官网上的获取方式都不尽相同。为了查找一个jar包找遍互联网，身心俱疲，没有经历过的人或许体会不到这种折磨。不仅如此，费劲心血找的jar包里有的时候并没有你需要的那个类，又或者又同名的类没有你要的方法——以不规范的方式获取的jar包也往往是不规范的。<br>使用Maven我们可以享受到一个完全统一规范的jar包管理体系。你只需要在你的项目中以坐标的方式依赖一个jar包，Maven就会自动从<code>中央仓库</code>进行下载，并同时下载这个jar包所依赖的其他jar包——规范、完整、准确！一次性解决所有问题！<br>1.5 将项目拆分成多个工程模块<br>随着JavaEE项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于JavaEE项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个Web工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过package结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是Java工程，有的是Web工程。<br>那么<code>工程拆分后又如何进行互相调用和访问呢</code>？这就需要用到Maven的<code>依赖管理机制</code>。大家请看我们的Survey调查项目拆分的情况：</p><p>上层模块依赖下层，所以下层模块中定义的API都可以为上层所调用和访问。<br>1.6 实现项目的分布式部署<br>在实际生产环境中，项目规模增加到一定程度后，可能每个模块都需要运行在独立的服务器上，我们称之为`分布式部署，这里同样需要用到Maven。</p><h2 id="什么是maven"><a href="#什么是maven" class="headerlink" title="什么是maven"></a>什么是maven</h2><p> Maven是一款自动化构建工具，专注服务于Java平台的项目构建和依赖管理。</p><h3 id="那么什么是构建呢？"><a href="#那么什么是构建呢？" class="headerlink" title="那么什么是构建呢？"></a>那么什么是构建呢？</h3><p>构建并不是创建，创建一个工程并不等于构建一个项目。要了解构建的含义我们应该由浅入深的从以下三个层面来看：<br>①纯Java代码<br>大家都知道，我们Java是一门编译型语言，.java扩展名的源文件需要编译成.class扩展名的字节码文件才能够执行。所以编写任何Java代码想要执行的话就必须经过编译得到对应的.class文件。<br>②Web工程<br>当我们需要通过浏览器访问Java程序时就必须将包含Java程序的Web工程编译的结果“拿”到服务器上的指定目录下，并启动服务器才行。这个“拿”的过程我们叫部署。<br>我们可以将未编译的Web工程比喻为一只生的鸡，编译好的Web工程是一只煮熟的鸡，编译部署的过程就是将鸡炖熟。<br>Web工程和其编译结果的目录结构对比见下图：</p><p>③实际项目<br>在实际项目中整合第三方框架，Web工程中除了Java程序和JSP页面、图片等静态资源之外，还包括第三方框架的jar包以及各种各样的配置文件。所有这些资源都必须按照正确的目录结构部署到服务器上，项目才可以运行。<br>所以综上所述：构建就是以我们编写的Java代码、框架配置文件、国际化等其他资源文件、JSP页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。<br>那么项目构建的全过程中都包含哪些环节呢？</p><h3 id="构建环节"><a href="#构建环节" class="headerlink" title="构建环节"></a>构建环节</h3><p>①清理：删除以前的编译结果，为重新编译做好准备。<br>②编译：将Java源程序编译为字节码文件。<br>③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。<br>④报告：在每一次测试后以标准的格式记录和展示测试结果。<br>⑤打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应jar包，Web工程对应war包。<br>⑥安装：在Maven环境下特指将打包的结果——jar包或war包安装到本地仓库中。<br>⑦部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>当A jar包需要用到B jar包中的类时，我们就说A对B有依赖。<br>通过第二个Maven工程我们已经看到，当前工程会到本地仓库中根据坐标查找它所依赖的jar包。<br>配置的基本形式是使用dependency标签指定目标jar包的坐标。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">   &lt;dependencies&gt;&lt;dependency&gt;&lt;!—坐标 --&gt;&lt;groupId&gt;junit&lt;&#x2F;groupId&gt;&lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;&lt;version&gt;4.10&lt;&#x2F;version&gt;&lt;!-- 依赖的范围 --&gt;&lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="直接依赖和间接依赖"><a href="#直接依赖和间接依赖" class="headerlink" title="直接依赖和间接依赖"></a>直接依赖和间接依赖</h3><p>如果A依赖B，B依赖C，那么A→B和B→C都是直接依赖，而A→C是间接依赖。</p><h3 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h3><p>当一个Maven工程添加了对某个jar包的依赖后，这个被依赖的jar包可以对应下面几个可选的范围：<br>①compile<br>[1]<strong>main目录下的Java代码可以访问这个范围的依赖</strong><br>[2]<strong>test目录下的Java代码可以访问这个范围的依赖</strong><br>[3]<strong>部署到Tomcat服务器上运行时要放在WEB-INF的lib目录下</strong><br>例如：对Hello的依赖。主程序、测试程序和服务器运行时都需要用到。<br>②test<br>[1]<strong>main目录下的Java代码不能访问这个范围的依赖<br>[2]test目录下的Java代码可以访问这个范围的依赖<br>[3]部署到Tomcat服务器上运行时不会放在WEB-INF的lib目录下</strong><br>例如：对junit的依赖。仅仅是测试程序部分需要。<br>③provided<br>[1]main目录下的Java代码可以访问这个范围的依赖<br>[2]test目录下的Java代码可以访问这个范围的依赖<br>[3]部署到Tomcat服务器上运行时不会放在WEB-INF的lib目录下<br>例如：servlet-api在服务器上运行时，Servlet容器会提供相关API，所以部署的时候不需要。</p><h3 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h3><p>当存在间接依赖的情况时，主工程对间接依赖的jar可以访问吗？这要看间接依赖的jar包引入时的依赖范围——<code>只有依赖范围为compile时可以访问</code>。例如：</p><h3 id="依赖的原则：解决jar包冲突"><a href="#依赖的原则：解决jar包冲突" class="headerlink" title="依赖的原则：解决jar包冲突"></a>依赖的原则：解决jar包冲突</h3><p><code>路径最短者优先</code><br> 举个例子：我们现在有三个工程MakeFriend、HelloFriend、和Hello。MakeFriend依赖HelloFriend，HelloFriend依赖Hello。而Hello依赖log4j.1.2.17.jar，HelloFriend依赖log4j.1.2.14.jar。<br><code>路径相同时先声明者优先</code></p><p>这里“声明”的先后顺序指的是<code>dependency标签配置的先后顺序。</code></p><h3 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h3><p>有的时候为了确保程序正确可以将有可能重复的间接依赖排除。</p><pre class="line-numbers language-none"><code class="language-none">&lt;exclusions&gt;&lt;exclusion&gt;&lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt;&lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt;&lt;&#x2F;exclusion&gt;&lt;&#x2F;exclusions&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="统一管理目标jar包的版本"><a href="#统一管理目标jar包的版本" class="headerlink" title="统一管理目标jar包的版本"></a>统一管理目标jar包的版本</h3><p>以对Spring的jar包依赖为例：Spring的每一个版本中都包含spring-core、spring-context等jar包。我们应该导入版本一致的Spring jar包</p><pre class="line-numbers language-none"><code class="language-none">      &lt;properties&gt;          &lt;spring.version&gt;4.1.1.RELEASE&lt;&#x2F;spring.version&gt;      &lt;&#x2F;properties&gt;      &lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;&lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h2><p>创建父工程和创建一般的Java工程操作一致，唯一需要注意的是：<code>打包方式处要设置为pom。</code><br>在子工程中引用父工程<br>`<parent><br>    <!-- 父工程坐标 --><br>    <groupId>…</groupId><br>    <artifactId>…</artifactId><br>    <version>…</version><br>    <relativePath>从当前目录到父项目的pom.xml文件的相对路径</relativePath><br></parent></p><parent>    <groupId>com.atguigu.maven</groupId>    <artifactId>Parent</artifactId>    <version>0.0.1-SNAPSHOT</version><pre><code>&lt;!-- 指定从当前子工程的pom.xml文件出发，查找父工程的pom.xml的路径 --&gt;&lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;</code></pre><p></parent><code>在父工程中管理依赖 将Parent项目中的dependencies标签，用dependencyManagement标签括起来</code><dependencyManagement><br>    <dependencies><br>        <dependency><br>            <groupId>junit</groupId><br>            <artifactId>junit</artifactId><br>            <version>4.9</version><br>            <scope>test</scope><br>        </dependency><br>    </dependencies><br></dependencyManagement><code>在子项目中重新指定需要的依赖，删除范围和版本号</code><dependencies><br>    <dependency><br>        <groupId>junit</groupId><br>        <artifactId>junit</artifactId><br>    </dependency><br></dependencies>`</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC简介</title>
      <link href="2020/11/20/springmvc/springmvc%E5%BA%94%E7%94%A8/"/>
      <url>2020/11/20/springmvc/springmvc%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-what"><a href="#1-what" class="headerlink" title="1.what"></a>1.what</h2><p>1）    Spring 为基于 <code>MVC 设计理念</code>的优秀的Web 框架，是目前最主流的MVC 框架之一 ，是应用  <code>表现层</code>的框架</p><p><strong><code>MVC设计模式</code></strong></p><p>MVC 全名是 Model View Controller，是 模型(model)－视图(view)－控制器(controller) 的缩写， 是⼀ 种⽤于设计创建 Web 应⽤程序表现层的模式。MVC 中每个部分各司其职：</p><p>Model（模型）：模型包含<code>业务模型和数据模型</code>，数据模型⽤于封装数据[pojo vo前台传递数据 po想数据库持久化数据]，业务模型⽤于处理业务。</p><p>View（视图）： 通常指的就是我们的 jsp 或者 html。作⽤⼀般就是展示数据的。通常视图是<code>依据 模型数据创建</code>的。</p><p>Controller（控制器）： 是应⽤程序中处理⽤户交互的部分。作⽤⼀般就是处理程序逻辑的。</p><p>MVC提倡：每⼀层只编写⾃⼰的东⻄，不编写任何其他的代码；分层是为了<code>解耦</code>，解耦是为了维 护⽅便和<code>分⼯协作</code>。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>它通过⼀套注解，让⼀个简单的Java类成为处理请求的控制器，⽽⽆须实现任何接⼝。</p><p>同时它还⽀持 RESTful 编程⻛格的请求。</p><p><code>Spring MVC 本质可以认为是对servlet的封装</code>，简化了我们serlvet的开发<br><code>作⽤：1）接收请求 2）返回响应，跳转⻚⾯</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>url-pattern配置原理及对静态资源的支持</title>
      <link href="2020/11/20/springmvc/url%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/"/>
      <url>2020/11/20/springmvc/url%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;&#x2F;param-value&gt;    &lt;&#x2F;init-param&gt;  &lt;&#x2F;servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;        &lt;!--拦截匹配规则的url请求，进入springmvc框架处理--&gt;    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;  &lt;&#x2F;servlet-mapping&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①    解释配置文件的名称定义规则:<br>②    DispatcherServlet自动加载的配置文件的位置及名称：<br>实际上也可以不通过 contextConfigLocation 来配置 SpringMVC 的配置文件, 而使用默认的.默认的配置文件为: <code>/WEB-INF/&lt;servlet-name&gt;-servlet.xml</code><br>3）    加入 Spring MVC 的配置文件：springmvc.xml<br> <init-param><br>      <param-name>contextConfigLocation</param-name><br>      <param-value>classpath:springmvc.xml</param-value><br>    </init-param></p><h2 id="1：-不会拦截-jsp，"><a href="#1：-不会拦截-jsp，" class="headerlink" title="1：/ 不会拦截 .jsp，"></a>1：<code>/ 不会拦截 .jsp，</code></h2><p>   <code>但是会拦截.html等静态资源</code>（静态资源：除了servlet和jsp之外的<code>js、css、png</code>等）</p><h3 id="为什么配置为-会拦截静态资源？？？"><a href="#为什么配置为-会拦截静态资源？？？" class="headerlink" title="为什么配置为/ 会拦截静态资源？？？"></a><strong>为什么配置为/ 会拦截静态资源？？？</strong></h3><p>因为tomcat容器中有一个web.xml，你的项目中也有一个web.xml<br>父web.xml中有一个DefaultServlet,  url-pattern 是一个 /<br>此时我们自己的web.xml中也配置了一个 / ,<strong>覆写了父web.xml的配置</strong></p><p>当开发人员设置的url-pattern与tomcat的一样时，开发人员的优先被处理<br>所以客户端发送请求的时候，优先通过DispatcherServlet去处理请求，找该请求是否有对应的处理器.<br>因此对于静态资源的请求, SpringMVC 会将他们当成一个普通请求处理,<code>因找不到对应处理器将导致错误</code>。</p><h3 id="为什么不拦截-jsp呢？"><a href="#为什么不拦截-jsp呢？" class="headerlink" title="为什么不拦截.jsp呢？"></a><strong>为什么不拦截.jsp呢？</strong></h3><p>因为父web.xml中有一个  <code>JspServlet</code>，这个servlet<code>拦截.jsp文件</code>，<strong>而我们并没有覆写这个配置，</strong><br>所以springmvc此时不拦截jsp，<strong>jsp的处理交给了tomcat</strong></p><h2 id="2：-拦截所有，包括-jsp"><a href="#2：-拦截所有，包括-jsp" class="headerlink" title="2：/* 拦截所有，包括.jsp"></a>2：/* <code>拦截所有，包括.jsp</code></h2><h2 id="如何解决-拦截静态资源这件事？"><a href="#如何解决-拦截静态资源这件事？" class="headerlink" title="如何解决/拦截静态资源这件事？"></a>如何解决/拦截静态资源这件事？</h2><ol><li>这种方案只能把静态资源防止在webapp目录下<br>在 SpringMVC 的配置文件中<br>配置 <a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a><br>配置 <a href="mvc:annotation-driven/">mvc:annotation-driven/</a>(自动注册合适的适配器和映射器)</li></ol><p><code>关于&lt;mvc:default-servlet-handler/&gt;作用</code><br><a href="mvc:default-servlet-handler/">mvc:default-servlet-handler/</a> 将在 SpringMVC 上下文中定义一个<code>DefaultServletHttpRequestHandler</code>，<br><strong>它会对进入 <code>DispatcherServlet </code>的请求进行筛查，</strong><br>    —如果发现是是静态资源的请求，就将该请求交由 <strong>WEB 应用服务器默认的 Servlet</strong> 处理，<br>    —如果不是静态资源的请求，才由 DispatcherServlet 继续处理</p><p>一般 WEB 应用服务器默认的 Servlet 的名称都是 default。<br>若所使用的 WEB 服务器的默认 Servlet 名称不是 default，则需要通过 default-servlet-name 属性显式指定        </p><p><code>&lt;mvc:default-servlet-handler default-servlet-name=&quot;&quot;/&gt;</code></p><ol start="2"><li>想要放在resource下放置静态资源a.html<br> &lt;mvc:resources location= “classpath:/“ mapping=”/resources/**”&gt;</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC请求处理流程及三大核心组件</title>
      <link href="2020/11/20/springmvc/%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"/>
      <url>2020/11/20/springmvc/%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringMVC请求流程"><a href="#SpringMVC请求流程" class="headerlink" title="SpringMVC请求流程"></a>SpringMVC请求流程</h2><p>第⼀步：⽤户发送请求⾄前端控制器<code>DispatcherServlet </code><br>第⼆步：<code>DispatcherServlet</code>收到请求,调⽤<code>HandlerMapping处理器映射器</code> ,问当前处理请求的handler，<br>HandlerMapping处理器映射器是个map,key是url,value能够处理当前url的handle,</p><p>第三步：处理器映射器根据请求Url找到具体的<code>Handler</code>（后端控制器:执行具体业务逻辑的方法），返回<code>处理器的执行链</code><br>⽣成处理器对象及处理器<code>拦截器</code>(如果 有则⽣成)⼀并返回<code>DispatcherServlet</code></p><p>第四步：<code>DispatcherServle</code>t调⽤<code>HandlerAdapter处理器适配器</code>去调⽤<code>Handler </code></p><p>第五步：处理器适配器执⾏<code>Handler</code> </p><p>第六步：Handler执⾏完成给处理器适配器返回<code>ModelAndView </code></p><p>第七步：处理器适配器向前端控制器返回 <code>ModelAndView</code>，ModelAndView 是SpringMVC 框架的⼀个底层对象，包括 Model 和 View </p><p>第⼋步：前端控制器请求视图解析器去进⾏视图解析，根据逻辑视图名来解析真正的视图。 </p><p>第九步：视图解析器向前端控制器返回<code>View 对象</code></p><p>第⼗步：前端控制器进⾏视图渲染，就是将模型数据（在 ModelAndView 对象中）填充到 <code>request 域 </code></p><p>第⼗⼀步：前端控制器向⽤户响应结果</p><p><img src="2020-12-09-19-45-53.png"></p><h2 id="Spring-MVC-九⼤组件"><a href="#Spring-MVC-九⼤组件" class="headerlink" title="Spring MVC 九⼤组件"></a>Spring MVC 九⼤组件</h2><p><strong>HandlerMapping（处理器映射器）</strong><br>HandlerMapping 是⽤来查找 Handler 的，也就是处理器，具体的表现形式可以是类，也可以是 ⽅法。<br>⽐如，<code>标注了@RequestMapping的每个⽅法都可以看成是⼀个Handler</code>。<br>Handler<code>负责具体实际的请求处理</code>，在请求到达后，HandlerMapping 的<code>作⽤</code>便是找到请求相应的处理器 <code>Handler</code> 和 <code>Interceptor</code>.<br>HandlerMapping ：请求映射到处理器，找谁来处理，如果映射成功返回一个HandlerExecutionChain对象（包含一个Handler处理器(页面控制器)对象、多个HandlerInterceptor拦截器对象）<br><strong>HandlerAdapter（处理器适配器）</strong><br>HandlerAdapter 是⼀个适配器。因为 Spring MVC 中 Handler 可以是任意形式的，只要能处理请 求即可。但是把请求交给 Servlet 的时候，由于 Servlet 的⽅法结构都是 doService(HttpServletRequest req,HttpServletResponse resp)形式的，要让固定的 Servlet 处理 ⽅法调⽤ Handler 来进⾏处理，便是 HandlerAdapter 的职责(<code>执行不同形式的handler</code>)。</p><p><strong>ViewResolver</strong><br>视图解析器，找谁来处理返回的页面。把<code>逻辑视图解析为具体的View</code>,进行这种<strong>策略模式</strong>，很容易更换其他视图技术；<br>如<code>InternalResourceViewResolver</code><strong>将逻辑视图名映射为JSP视图</strong></p><p><strong>HandlerExceptionResolver</strong><br>HandlerExceptionResolver ⽤于<code>处理 Handler 产⽣的异常情况</code>。它的作⽤是根据异常设置 ModelAndView，之后交给渲染⽅法进⾏渲染，渲染⽅法会将 ModelAndView 渲染成⻚⾯。</p><p><strong>MultipartResolver</strong><br>MultipartResolver ⽤于上传请求，通过将普通的请求包装成 MultipartHttpServletRequest 来实 现。MultipartHttpServletRequest 可以通过 getFile() ⽅法 直接获得⽂件。如果上传多个⽂件，还 可以调⽤ getFileMap()⽅法得到Map&lt;FileName，File&gt;这样的结构，MultipartResolver 的作⽤就 是封装普通的请求，使其拥有⽂件上传的功能。</p><p><strong>FlashMapManager</strong><br>FlashMap ⽤于<strong>重定向</strong>时的参数传递，⽐如在处理⽤户订单时候，为了避免重复提交，可以处理完 post请求之后重定向到⼀个get请求，这个get请求可以⽤来显示订单详情之类的信息。这样做虽然 可以规避⽤户重新提交订单的问题，但是在这个⻚⾯上要显示订单的信息，这些数据从哪⾥来获得 呢？因为重定向时么有传递参数这⼀功能的，如果不想把参数写进URL（不推荐），那么就可以通 过FlashMap来传递。只需要在重定向之前将要传递的数据写⼊请求（可以通过 ServletRequestAttributes.getRequest()⽅法获得）的属性OUTPUT_FLASH_MAP_ATTRIBUTE 中，这样在重定向之后的Handler中Spring就会⾃动将其设置到Model中，在显示订单信息的⻚⾯ 上就可以直接从Model中获取数据。FlashMapManager 就是⽤来管理 FalshMap 的。<br>RequestToViewNameTranslator<br>RequestToViewNameTranslator 组件的作⽤是从请求中获取 ViewName.因为 ViewResolver 根据 ViewName 查找 View，但有的 Handler 处理完成之后,没有设置 View，也没有设置 ViewName， 便要通过这个组件从请求中查找 ViewName。</p><p>LocaleResolver<br>本地化、国际化。</p><p>ThemeResolver<br>ThemeResolver 组件是⽤来解析主题的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC请求数据</title>
      <link href="2020/11/20/springmvc/%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/"/>
      <url>2020/11/20/springmvc/%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="参数绑定：取出参数值绑定到handler⽅法的形参上"><a href="#参数绑定：取出参数值绑定到handler⽅法的形参上" class="headerlink" title="参数绑定：取出参数值绑定到handler⽅法的形参上"></a>参数绑定：取出参数值绑定到handler⽅法的形参上</h2><p>原⽣servlet接收⼀个整型参数：<br>1）String ageStr = request.getParameter(“age”);<br>2) Integer age = Integer.parseInt(ageStr);<br>3) SpringMVC框架对Servlet的封装，简化了servlet的很多操作<br>4) SpringMVC在接收整型参数的时候，直接在Handler⽅法中声明形参即可 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;xxx&quot;) public String handle(Integer age) &#123; System.out.println(age); &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>默认⽀持 Servlet API 作为⽅法参数 当需要使⽤HttpServletRequest、HttpServletResponse、HttpSession等原⽣servlet对象时，直接在handler⽅法中形参声明使⽤即可。</li><li>绑定简单数据类型参数，只需要直接声明形参即可（<code>形参参数名和传递的参数名要保持⼀ 致</code>，<strong>建议使⽤包装类型</strong>，因为简单数据类型为null时不能转换<br>当形参参数名和传递参数名不⼀致时可以使⽤@RequestParam注解进⾏ ⼿动映射）<br><code>@RequestParam</code>注解<br> 1）在处理方法入参处使用 @RequestParam 可以把请求参数传递给请求方法<br> 2）value：参数名<br> 3）required：是否必须。默认为 true, 表示请求参数中必须包含对应的参数，若不存在，将抛出异常<br> 4）defaultValue: 默认值，当没有传递参数时使用该值<br><code>@CookieValue</code> 注解<br>1）    使用 @CookieValue 绑定请求中的 Cookie 值<br>2）    @CookieValue 可让处理方法入参绑定某个 Cookie 值<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;testCookieValue&quot;)public String testCookieValue(@CookieValue(&quot;JSESSIONID&quot;) String sessionId) &#123;System.out.println(&quot;testCookieValue: sessionId: &quot; + sessionId);return &quot;success&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>使用POJO作为参数<br> 1）    使用 POJO 对象绑定请求参数值<br> 2）    Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值。支持级联属性。如：dept.deptId、dept.address.tel <pre><code> 接收pojo类型参数，直接形参声明即可，类型就是Pojo的类型，形参名无所谓</code></pre></li></ol><ul><li><strong>但是要求传递的参数名必须和Pojo的属性名保持一致</strong><!-- 测试 POJO 对象传参，支持级联属性 --><form action=" testPOJO" method="POST">username: <input type="text" name="username"/><br>password: <input type="password" name="password"/><br>email: <input type="text" name="email"/><br>age: <input type="text" name="age"/><br>city: <input type="text" name="address.city"/><br>province: <input type="text" name="address.province"/><input type="submit" value="Submit"/></form></li></ul><ol start="4"><li><code>绑定⽇期类型参数</code>（需要配置<code>⾃定义类型转换器</code>）<br>因为String不能直接转换为日期类型</li></ol><p>前端jsp</p><fieldset> <p>测试⽤例：SpringMVC接收⽇期类型参数</p><p><a href="/demo/handle06?birthday=2019-10-08">点击测试</a></p></fieldset><p>后台Handler⽅法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;handle06&quot;) public ModelAndView handle06(Date birthday)     &#123; Date date &#x3D; new Date();    ModelAndView modelAndView &#x3D; new ModelAndView();     modelAndView.addObject(&quot;date&quot;,date);     modelAndView.setViewName(&quot;success&quot;);     return modelAndView; &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义类型转换器，implements Converter&lt;String, Date&gt;字符串转date</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DateConverter implements Converter&lt;String, Date&gt; &#123;    @Override    public Date convert(String source) &#123;        &#x2F;&#x2F; 完成字符串向日期的转换        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        try &#123;            Date parse &#x3D; simpleDateFormat.parse(source);            return parse;        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>别忘了</p><!--注册自定义类型转换器--><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--        自动注册最合适的处理器映射器，处理器适配器(调用handler方法)    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span> <span class="token attr-name">conversion-service</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>conversionServiceBean<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>conversionServiceBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.format.support.FormattingConversionServiceFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>converters<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.lagou.edu.converter.DateConverter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC对Restful风格的支持</title>
      <link href="2020/11/20/springmvc/Restful/"/>
      <url>2020/11/20/springmvc/Restful/</url>
      
        <content type="html"><![CDATA[<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>rest是⼀个url请求的⻛格，基于这种⻛格设计请求的url </p><ol><li><p>没有rest的话，原有的url设计 <a href="http://localhost:8080/user/queryUserById.action?id=3">http://localhost:8080/user/queryUserById.action?id=3</a> url中定义了动作（操作），参数具体锁定到操作的是谁</p></li><li><p>有了rest⻛格之后 rest中，认为互联⽹中的所有东⻄都是资源，<br>既然是资源就会有⼀个唯⼀的uri标识它，<br>代表它 <a href="http://localhost:8080/user/3">http://localhost:8080/user/3</a> 代表的是id为3的那个⽤户记录（资源）<br>锁定资源之后如何操作它呢？<br>常规操作就是增删改查<br>根据请求⽅式不同，代表要做不同的操作<br>get 查询，获取资源 post 增加，新建资源 put 更新 delete 删除资源<br>rest⻛格带来的直观体现：<strong>就是传递参数⽅式的变化，参数可以在uri中了</strong><br>/account/1 HTTP GET ：得到 id = 1 的 account<br>/account/1 HTTP DELETE：删除 id = 1 的 account<br>/account/1 HTTP PUT：更新 id = 1 的 account<br>URL：资源定位符，通过URL地址去定位互联⽹中的资源（抽象的概念，⽐如图⽚、视频、app服务 等）。<br>RESTful ⻛格 URL：互联⽹所有的事物都是资源，<strong>要求URL中只有表示资源的名称，没有动词</strong>。<br>RESTful⻛格资源操作：<br>使⽤HTTP请求中的method⽅法put、delete、post、get来操作资源。分别对 应添加、删除、修改、查询。不过⼀般使⽤时还是 post 和 get。put 和 delete⼏乎不使⽤。</p></li></ol><hr><h2 id="Spring-MVC-⽀持-RESTful-⻛格请求"><a href="#Spring-MVC-⽀持-RESTful-⻛格请求" class="headerlink" title="Spring MVC ⽀持 RESTful ⻛格请求"></a>Spring MVC ⽀持 RESTful ⻛格请求</h2><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p><code>@PathVariable </code>注解获取 RESTful ⻛格的请求 <code>URL中的路径变量</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*     * restful  get   &#x2F;demo&#x2F;handle&#x2F;15     *&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;handle&#x2F;&#123;id&#125;&quot;,method &#x3D; &#123;RequestMethod.GET&#125;)    public ModelAndView handleGet(@PathVariable(&quot;id&quot;) Integer id) &#123;        ModelAndView modelAndView &#x3D; new ModelAndView();        modelAndView.setViewName(&quot;success&quot;);        return modelAndView;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a>HiddenHttpMethodFilter</h3><p><code>HiddenHttpMethodFilter</code>浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支持，<br>Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与 DELETE 请求。</p><p>如何发送PUT请求或DELETE请求?</p><ul><li>①.配置HiddenHttpMethodFilter</li><li>②.需要发送POST请求</li><li>③.需要在发送POST请求时携带一个 name=”_method”的隐含域，值为PUT或DELETE</li></ul><!--配置springmvc请求方式转换过滤器，会检查请求参数中是否有_method参数，如果有就按照指定的请求方式进行转换--><p>`<br>  <filter><br>    <filter-name>hiddenHttpMethodFilter</filter-name><br>    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class><br>  </filter></p>  <filter-mapping>    <filter-name>encoding</filter-name>    <url-pattern>/*</url-pattern>  </filter-mapping>  <filter-mapping>    <filter-name>hiddenHttpMethodFilter</filter-name>    <url-pattern>/*</url-pattern>  </filter-mapping>  `<p>`<br>  <!-- 实验1 测试 REST风格 GET 请求 --><br><a href="springmvc/testRESTGet/1">testREST GET</a><br/><br/></p><!-- 实验2 测试 REST风格 POST 请求 --><form action="springmvc/testRESTPost" method="POST"><input type="submit" value="testRESTPost"></form><!-- 实验3 测试 REST风格 PUT 请求 --><form action="springmvc/testRESTPut/1" method="POST"><input type="hidden" name="_method" value="PUT"><input type="submit" value="testRESTPut"></form><!-- 实验4 测试 REST风格 DELETE 请求 --><form action="springmvc/testRESTDelete/1" method="POST"><input type="hidden" name="_method" value="DELETE"><input type="submit" value="testRESTDelete"></form>`---<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(value&#x3D;&quot;&#x2F;testRESTGet&#x2F;&#123;id&#125;&quot;,method&#x3D;RequestMethod.GET)public String testRESTGet(@PathVariable(value&#x3D;&quot;id&quot;) Integer id)&#123;System.out.println(&quot;testRESTGet id&#x3D;&quot;+id);return &quot;success&quot;;&#125; @RequestMapping(value&#x3D;&quot;&#x2F;testRESTPost&quot;,method&#x3D;RequestMethod.POST)public String testRESTPost()&#123;System.out.println(&quot;testRESTPost&quot;);return &quot;success&quot;;&#125; @RequestMapping(value&#x3D;&quot;&#x2F;testRESTPut&#x2F;&#123;id&#125;&quot;,method&#x3D;RequestMethod.PUT)public String testRESTPut(@PathVariable(&quot;id&quot;) Integer id)&#123;System.out.println(&quot;testRESTPut id&#x3D;&quot;+id);return &quot;success&quot;;&#125; @RequestMapping(value&#x3D;&quot;&#x2F;testRESTDelete&#x2F;&#123;id&#125;&quot;,method&#x3D;RequestMethod.DELETE)public String testRESTDelete(@PathVariable(&quot;id&quot;) Integer id)&#123;System.out.println(&quot;testRESTDelete id&#x3D;&quot;+id);return &quot;success&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC响应数据</title>
      <link href="2020/11/20/springmvc/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/"/>
      <url>2020/11/20/springmvc/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="几种途径输出模型数据"><a href="#几种途径输出模型数据" class="headerlink" title="几种途径输出模型数据"></a>几种途径输出模型数据</h2><p>1）    <strong>ModelAndView</strong>: 处理方法返回值类型为 ModelAndView 时, 方法体即可通过该对象添加模型数据<br>2）    <strong>Map 或 Model</strong>: 入参为 org.springframework.ui.Model、<br>org.springframework.ui.ModelMap 或 java.uti.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中。</p><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><pre><code>控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息</code></pre><p>1）    两个重要的成员变量:</p><pre><code><pre class="line-numbers language-java" data-language="java"><code class="language-java">private Object view;视图信息private ModelMap model; 模型数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></code></pre><p>2）添加模型数据:<br>MoelAndView addObject(String attributeName, Object attributeValue)   设置模型数据<br>ModelAndView addAllObject(Map&lt;String, ?&gt; modelMap)<br>3）设置视图:<br>void setView(View view)                设置视图对象<br>void setViewName(String viewName)     设置视图名字<br>4）获取模型数据<br>      protected Map&lt;String, Object&gt; getModelInternal()   获取模型数据<br>      public ModelMap getModelMap()<br>      public Map&lt;String, Object&gt; getModel()<br>5.3.1    Map介绍</p><p><strong>SpringMVC在handler方法上传入Map、Model和ModelMap参数，并向这些参数中保存数据（放入到<code>请求域</code>），都可以在<code>页面获取到</code></strong></p><ul><li>它们之间是什么关系？</li><li>运行时的具体类型都是 <code>BindingAwareModelMap</code>，相当于给BindingAwareModelMap中<strong>保存的数据都会放在请求域中</strong></li><li></li><li> Map(jdk中的接口)        Model（spring的接口）</li><li></li><li> ModelMap(class,实现Map接口)</li><li>BindingAwareModelMap继承了ExtendedModelMap，ExtendedModelMap继承了ModelMap,实现了Model接口</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**     * url: http:&#x2F;&#x2F;localhost:8080&#x2F;demo&#x2F;handle01     *&#x2F;    @RequestMapping(&quot;&#x2F;handle01&quot;)    public ModelAndView handle01(@ModelAttribute(&quot;name&quot;) String name) &#123;        int c &#x3D; 1&#x2F;0;        Date date &#x3D; new Date();&#x2F;&#x2F; 服务器时间        &#x2F;&#x2F; 返回服务器时间到前端页面        &#x2F;&#x2F; 封装了数据和页面信息的 ModelAndView        ModelAndView modelAndView &#x3D; new ModelAndView();        &#x2F;&#x2F; addObject 其实是向请求域中request.setAttribute(&quot;date&quot;,date);        modelAndView.addObject(&quot;date&quot;,date);        &#x2F;&#x2F; 视图信息(封装跳转的页面信息) 逻辑视图名        modelAndView.setViewName(&quot;success&quot;);        return modelAndView;    &#125;       &#x2F;**     * 直接声明形参ModelMap，封装数据     * url: http:&#x2F;&#x2F;localhost:8080&#x2F;demo&#x2F;handle11     *     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;modelmap:class org.springframework.validation.support.BindingAwareModelMap     *&#x2F;    @RequestMapping(&quot;&#x2F;handle11&quot;)    public String handle11(ModelMap modelMap) &#123;        Date date &#x3D; new Date();&#x2F;&#x2F; 服务器时间        modelMap.addAttribute(&quot;date&quot;,date);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;modelmap:&quot; + modelMap.getClass());        return &quot;success&quot;;    &#125;    &#x2F;**     * 直接声明形参Model，封装数据     * url: http:&#x2F;&#x2F;localhost:8080&#x2F;demo&#x2F;handle12     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;model:class org.springframework.validation.support.BindingAwareModelMap     *&#x2F;    @RequestMapping(&quot;&#x2F;handle12&quot;)    public String handle12(Model model) &#123;        Date date &#x3D; new Date();        model.addAttribute(&quot;date&quot;,date);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;model:&quot; + model.getClass());        return &quot;success&quot;;    &#125;    &#x2F;**     * 直接声明形参Map集合，封装数据     * url: http:&#x2F;&#x2F;localhost:8080&#x2F;demo&#x2F;handle13     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;map:class org.springframework.validation.support.BindingAwareModelMap     *&#x2F;    @RequestMapping(&quot;&#x2F;handle13&quot;)    public String handle13(Map&lt;String,Object&gt; map) &#123;        Date date &#x3D; new Date();        map.put(&quot;date&quot;,date);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;map:&quot; + map.getClass());        return &quot;success&quot;;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json交互</title>
      <link href="2020/11/20/springmvc/json%E4%BA%A4%E4%BA%92/"/>
      <url>2020/11/20/springmvc/json%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯</title>
      <link href="2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<ol><li> 爬楼梯<br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</li></ol><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li> 1 阶 + 1 阶</li><li> 2 阶<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li> 1 阶 + 1 阶 + 1 阶</li><li> 1 阶 + 2 阶</li><li> 2 阶 + 1 阶</li></ol>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零</title>
      <link href="2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ol start="11"><li>盛最多水的容器<br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</li></ol><p>说明：你不能倾斜容器。<br><img src="2020-12-11-22-24-00.png"><br>示例 1：</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><hr><h2 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h2><p>给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。<br><strong>你应当保留两个分区中每个节点的初始相对位置。</strong><br>输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;        ListNode l1 &#x3D; new ListNode(-1);        ListNode l2 &#x3D; new ListNode(-1);        ListNode cur &#x3D; head;        ListNode small &#x3D; l1;        ListNode large &#x3D; l2;        while(cur!&#x3D;null)&#123;            if(cur.val&lt;x)&#123;                small.next &#x3D;cur;                small &#x3D; small.next;            &#125;else&#123;                large.next &#x3D; cur;                large &#x3D; large.next;            &#125;            cur &#x3D; cur.next;        &#125;        large.next &#x3D; null;        small.next &#x3D; l2.next;        return l1.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零</title>
      <link href="2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>2020/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<ol start="283"><li>移动零<br>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</li></ol><p>示例:</p><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><p>使用count指针指向该数组的头部。<br>遍历数组：i指针不断向右移动，每次i指针指向非零数，则将左右指针对应的数交换，同时左指针右移。<br>注意到以下性质：<br>count指针左边均为非零数；<br>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务传播特性详解</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="事务传播特性—-详解："><a href="#事务传播特性—-详解：" class="headerlink" title="事务传播特性—-详解："></a>事务传播特性—-详解：</h1><p><code>required</code>：使用当前的事务，如果当前没有事务，则创建一个事务，子方法是必须运行在一个事务中的，如果当前存在事务，则加入这个事务，成为一个整体。<br><code>supports</code>:如果当前有事务，则使用事务，如果当前没有事务，则不使用事务<br><code>mandatory</code>：该传播属性强制必须存在一个事务，如果不存在，则抛出异常<br><code>required_new</code>:如果当前有事务，则挂起该事务，并且自己创建一个新的事务给自己使用；如果当前没有事务，则同required<br><code>not_support</code>:如果当前有事务，则把事务挂起，自己不使用事务去进行数据库操作<br><code>never</code>:如果当前事务存在，则抛出异常<br><code>nested</code>：  如果当前有事务，则开启子事务（嵌套事务），嵌套事务是独立提交或者回滚；如果当前没有事务，则同required<br>但是如果父事务提交，则会携带子事务一起提交。如果父事务回滚，则子事务会一起回滚。相反，子事务异常，则父事务可以不会滚（捕获子事务的异常），也可以回滚。<br>有异常才会回滚事务，如果异常被捕获，也就是try，catch，就不会回滚事务了，<br>发生异常，或者抛出异常都会回滚事务</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>导入test依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;    &lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写test类 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RunWith(SpringRunner.class)@SpringBootTest(classes &#x3D; Application.class)public class TransTest &#123;    @Autowired    private TestTransService testTransService;    &#x2F;*    * 事务传播特性    *   required：    *   supports：    *   mandatory：    *   required_new:    *   not_supported:    *   never:    *   nested:    * *&#x2F;    @Test    public void demo()&#123;        testTransService.saveParent();        testTransService.saveChildren();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写需要的测试方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service    public class TestTransService &#123;        @Autowired        private StuMapper stuMapper;        public void saveParent()&#123;            Stu stu&#x3D;new Stu();            stu.setName(&quot;parent&quot;);            stu.setAge(55);            stuMapper.insert(stu);        &#125;        public void saveChildren()&#123;            saveChild1();            int a&#x3D;1&#x2F;0;            saveChild2();        &#125;        public void saveChild1()&#123;            Stu stu1&#x3D;new Stu();            stu1.setName(&quot;child-1&quot;);            stu1.setAge(11);            stuMapper.insert(stu1);        &#125;        public void saveChild2()&#123;            Stu stu2&#x3D;new Stu();            stu2.setName(&quot;child-2&quot;);            stu2.setAge(22);            stuMapper.insert(stu2);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title=" REQUIRED"></a><font color = gold> REQUIRED</font></h2><font color=orange>required：使用当前的事务，如果当前没有事务，则创建一个事务，子方法是必须运行在一个事务中的，如果当前存在事务，则加入这个事务，成为一个整体。</font><p>(1)<code>demo方法没有开启事务</code>，直接测试<br>报错：java.lang.ArithmeticException: / by zero<br>parent，child1入库<br><strong>结论：在报错之前，已经执行的代码会进行数据库操作，之后代码没有执行，也就没有操作数据库</strong></p><hr><p>(2)<code>在demo()方法上开启事务propagation = Propagation.REQUIRED，进行测试</code><br>    /*<br>    * 事务传播特性<br>    *   required：<br>    *   supports：<br>    *   mandatory：<br>    *   required_new:<br>    *   not_supported:<br>    *   never:<br>    *   nested:<br>    * */</p><pre><code>`@Transactional(propagation = Propagation.REQUIRED)`<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void demo()&#123;    testTransService.saveParent();    testTransService.saveChildren();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></code></pre><p>报错：<code>java.lang.ArithmeticException: / by zero</code></p><p><strong>结论</strong>：<br>demo()方法开启REQUIRED事务，事务具有传播特性，方体体里面的方法也具有事务，所以报错后数据库进行了回滚操作</p><p>如果demo方法没有开启事务，在saveChildren()上开启了事务（  @Transactional(propagation = Propagation.REQUIRED)），则会保存saveParent()方法插入的数据。</p><hr><h2 id="supports"><a href="#supports" class="headerlink" title="supports "></a><font color = gold>supports </font></h2><p><font color = orange>supports:如果当前有事务，则使用事务，如果当前没有事务，则不使用事务</font></p><ol><li>demo方法上没有加事务，但是 saveChildren加SUPPORTS事务<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#96;@Transactional(propagation &#x3D; Propagation.SUPPORTS)&#96;public void saveChildren()&#123;            saveChild1();            int a&#x3D;1&#x2F;0;            saveChild2();        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>结论</strong>： 数据库新增parent,child-1数据<br>是因为外层demo没有事务，saveChildren也就跟着外层函数来，不增加事务。<br>2. demo方法上加Required事务，但是 saveChildren加SUPPORTS事务</p><p><strong>结论</strong>: 没有数据入库，事务就进行了回滚操作</p><hr><h2 id="mandatory"><a href="#mandatory" class="headerlink" title="mandatory"></a><font color = gold>mandatory</font></h2><p><font color = orange>该传播属性强制必须存在一个事务，如果不存在，则抛出异常</font></p><ol><li>把调用方demo的Required事务给注释掉，在被调用方saveChildren使用事务mandatory<br>会抛出没有事务的异常</li><li>demo方法上加Required事务，saveChildren加mandatory事务</li></ol><hr><h2 id="required-new"><a href="#required-new" class="headerlink" title="required_new"></a><font color = gold>required_new</font></h2><p><font color = orange>required_new:如果当前有事务，则挂起该事务，并且自己创建一个新的事务给自己使用；如果当前没有事务，则同required</font></p><ol><li>把调用方demo的Required事务给注释掉，在被调用方saveChildren使用事务required_new<br>会有一条parent记录，saveChildren自己本身有事务，进行了回滚</li><li><strong>demo方法上加Required事务，saveChildren加required_new事务<br>此时有两个事务，<br>数据库此时并没有任何数据<br>这是因为saveChildren回滚，本身有/0异常，会影响到demo方法，也会回滚</strong><br> 由于抛出空指针异常，所以saveChildren()这个新事物会回滚，而抛出的异常会传递给父方法，父方法的事务也会回滚，所有没有一条记录</li><li>demo方法上加Required事务，saveChildren加required_new事务<br> 把saveChildren的/0注释掉，放到demo方法中的时候，<br> 数据库有child1 ,chird2<br> 结论：可以证明required_new创建的时新事务</li></ol><hr><h2 id="not-support"><a href="#not-support" class="headerlink" title="not_support"></a><font color = gold>not_support</font></h2><p><font color = orange>如果当前有事务，则把事务挂起，自己不使用事务去进行数据库操作</font></p><ol><li>把调用方demo的Required事务给注释掉，在被调用方saveChildren（有异常）使用事务not_support<br>parent，child1入库,没有回滚</li><li>调用方demo使用Required事务，在被调用方saveChildren（有异常）使用事务not_support<br>child1入库</li></ol><hr><h2 id="never"><a href="#never" class="headerlink" title="never"></a><font color = gold>never</font></h2><p><font color = orange>如果当前事务存在，则抛出异常</font><br>1.调用方demo使用Required事务，在被调用方saveChildren（有异常）使用事务never<br>    会抛出另一个异常非法事务状态<br>2.调用方demo不使用Required事务，在被调用方saveChildren（有异常）使用事务never<br>    会抛出异常 /0  parent，child1入库</p><hr><h2 id="nested"><a href="#nested" class="headerlink" title="nested"></a><font color = gold>nested</font></h2><p><font color = orange>如果当前有事务，则开启子事务（嵌套事务），嵌套事务是独立提交或者回滚；如果当前没有事务，则同required</font></p><p>1.调用方demo使用Required事务（有异常），在被调用方saveChildren（没有异常）使用事务nested<br>    数据库没有数据<br>    如果在外层方法发生异常，被调用方法也会回滚<br>    <strong>父事务回滚，则子事务会一起回滚</strong></p><pre><code>**区别与required_new**  主方法发生异常，子方法不会收到影响 新开启一个新的事务  看前面</code></pre><p>2.调用方demo使用Required事务（没有异常），在被调用方saveChildren（有异常）使用事务nested<br>    会抛出异常 /0  没有数据库入库</p><pre><code>在外层方法demo追加try catch，主方法其他操作不会受到子事务的影响<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(propagation &#x3D; Propagation.REQUIRED)public void demo()&#123;    testTransService.saveParent();    try &#123;        &#x2F;&#x2F;相当于数据库中的savepoint 捕获异常之后，不影响其他事务操作        testTransService.saveChildren();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre><font color = orange>但是如果父事务提交，则会携带子事务一起提交。如果父事务回滚，则子事务会一起回滚。相反，子事务异常，则父事务可以不回滚（捕获子事务的异常），也可以回滚。有异常才会回滚事务，如果异常被捕获，也就是try，catch，就不会回滚事务了，发生异常，或者抛出异常都会回滚事务</font>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--日志监控功能</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86x%E9%A1%B9%E7%9B%AE--%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86x%E9%A1%B9%E7%9B%AE--%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="通过日志监控service执行时间"><a href="#通过日志监控service执行时间" class="headerlink" title="通过日志监控service执行时间"></a>通过日志监控service执行时间</h2><p>使用到切面，引入依赖<br><code>        &lt;!--引入aop依赖--&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;         &lt;/dependency        </code></p><p>使用<code>环绕通知</code>，编写切面类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.imooc.aspect; import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;&#x2F;** 记录每个service所需要的时间* *&#x2F;@Aspect@Componentpublic class ServiceLogAspect &#123;    private static final Logger log&#x3D; LoggerFactory.getLogger(ServiceLogAspect.class);     &#x2F;**     * 切面表达式：     * execution 执行的位置     * 第一处：* 代表所有的返回类型     * 第二处：包名 代表aop监控的类所在的包     * 第三处：.. 代表该包及其子包     * 第四处：* 所有的类     * 第五处：*（..) * 代表所有的方法名，(..)代表方法中的任何参数     * @param joinPoint     * @return     *&#x2F;    @Around(&quot;execution(* com.imooc.service.impl..*.*(..))&quot;)    public Object recordTimeLog(ProceedingJoinPoint joinPoint) throws Throwable &#123;        &#x2F;&#x2F;&#123;&#125; 代表占位符 &#123;&#125;.&#123;&#125; 类名.方法名        log.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 开始执行 &#123;&#125;.&#123;&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;,joinPoint.getTarget().getClass(),                joinPoint.getSignature().getName());        &#x2F;&#x2F;开始记录时间        long start&#x3D;System.currentTimeMillis();        &#x2F;&#x2F;执行方法        Object result &#x3D; joinPoint.proceed();        &#x2F;&#x2F;结束记录时间        long end&#x3D;System.currentTimeMillis();        long takeTime&#x3D;end-start;        if(takeTime&gt;3000)&#123;            log.error(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行结束，耗时：&#123;&#125;毫秒 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;,takeTime);        &#125;else if(takeTime&gt;2000)&#123;            log.warn(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行结束，耗时：&#123;&#125;毫秒 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;,takeTime);        &#125;else&#123;            log.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 执行结束，耗时：&#123;&#125;毫秒 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;,takeTime);        &#125;        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--整合swagger2</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE--%E6%95%B4%E5%90%88Swagger2/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE--%E6%95%B4%E5%90%88Swagger2/</url>
      
        <content type="html"><![CDATA[<p>postMan 后端人员自测<br>和前端人员交互的时候就需要编写接口文档了</p><p>API  swagger2  开源的插件，减少编写更多的文档，只需要通过一些简单的代码，和前端人员对接<br>                并且使用文档也能完成自测功能</p><p>引入依赖：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;!--swagger2 配置 下面两个是官方的 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.4.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.4.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--这个是第三方的ui--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;swagger-bootstrap-ui&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.6&lt;&#x2F;version&gt;&lt;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*向springboot表明是配置类*&#x2F;@Configuration@EnableSwagger2&#x2F;*开启swagger2配置*&#x2F;public class Swagger2 &#123;    &#x2F;&#x2F; http:&#x2F;&#x2F;localhost:8088&#x2F;swagger-ui.html 原路径    &#x2F;&#x2F; http:&#x2F;&#x2F;localhost:8088&#x2F;doc.html 界面美观路径    &#x2F;&#x2F; 配置swagger2核心配置 docket    @Bean    public Docket createRestApi()&#123;        return new Docket(DocumentationType.SWAGGER_2) &#x2F;&#x2F;指定api类型为Swagger2                .apiInfo(apiInfo())                    &#x2F;&#x2F;用于定义api文档汇总                .select().apis(RequestHandlerSelectors                        .basePackage(&quot;com.imooc.controller&quot;)) &#x2F;&#x2F;指定controller包                        .paths(PathSelectors.any())             &#x2F;&#x2F;选定所有controller包                        .build();    &#125;    private ApiInfo apiInfo()&#123;        return new ApiInfoBuilder()                .title(&quot;天天吃货 电商平台接口api&quot;)            &#x2F;&#x2F;文档页标题                .contact(new Contact(&quot;小丸子&quot;,                        &quot;https:&#x2F;&#x2F;tomorrow813.github.io&quot;,                        &quot;245482791@qq.com&quot;))           &#x2F;&#x2F;联系人信息                .description(&quot;专为天天吃货提供的api文档&quot;)      &#x2F;&#x2F;详细信息                .version(&quot;1.0.1&quot;)                           &#x2F;&#x2F;文档版本号码                .termsOfServiceUrl(&quot;https:&#x2F;&#x2F;www.imooc.com&quot;) &#x2F;&#x2F;网站地址                .build();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>swagger2优化</p><p>controller：</p><p>@ApiIgnore注释在controller上：表明该controller不显示在文档中/<em>用于注释该controller</em>/<br>@Api(value = “注册登录”,tags = {“用于注册登录的相关接口”})/<em>用于注释该controller</em>/<br>@ApiOperation(value = “用户名是否存在”,notes = “用户名是否存在”,httpMethod = “GET”)//用于注释该方法<br>model：</p><p>注释在实体类名上：@ApiModel(value = “用户名BO”,description = “从客户端，有用户传入的数据封装在此entity中”)<br>注释在实体属性上：@ApiModelProperty(value =”用户名”,name = “username”,example = “imooc”,required = true)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--自定义响应数据结构</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE--%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE--%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Restful webservice返回的强规范: HttpStatus.OK<br>我们也可以自定义响应的数据结构传递回前端：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @Description: 自定义响应数据结构 * 前端接受此类数据（json object)后，可自行根据业务去实现相关功能 *  * 200：表示成功 * 500：表示错误，错误信息在msg字段中 * 501：bean验证错误，不管多少个错误都以map形式返回 * 502：拦截器拦截到用户token出错 * 555：异常抛出信息 * 556: 用户qq校验异常 *&#x2F;public class JSONResult &#123;    &#x2F;&#x2F; 定义jackson对象    private static final ObjectMapper MAPPER &#x3D; new ObjectMapper();    &#x2F;&#x2F; 响应业务状态    private Integer status;    &#x2F;&#x2F; 响应消息    private String msg;    &#x2F;&#x2F; 响应中的数据    private Object data;        @JsonIgnore    private String ok;&#x2F;&#x2F; 不使用    public static JSONResult build(Integer status, String msg, Object data) &#123;        return new JSONResult(status, msg, data);    &#125;    public static JSONResult build(Integer status, String msg, Object data, String ok) &#123;        return new JSONResult(status, msg, data, ok);    &#125;        public static JSONResult ok(Object data) &#123;        return new JSONResult(data);    &#125;    public static JSONResult ok() &#123;        return new JSONResult(null);    &#125;        public static JSONResult errorMsg(String msg) &#123;        return new JSONResult(500, msg, null);    &#125;        public static JSONResult errorMap(Object data) &#123;        return new JSONResult(501, &quot;error&quot;, data);    &#125;        public static JSONResult errorTokenMsg(String msg) &#123;        return new JSONResult(502, msg, null);    &#125;        public static JSONResult errorException(String msg) &#123;        return new JSONResult(555, msg, null);    &#125;        public static JSONResult errorUserQQ(String msg) &#123;        return new JSONResult(556, msg, null);    &#125;    public JSONResult() &#123;    &#125;    public JSONResult(Integer status, String msg, Object data) &#123;        this.status &#x3D; status;        this.msg &#x3D; msg;        this.data &#x3D; data;    &#125;        public JSONResult(Integer status, String msg, Object data, String ok) &#123;        this.status &#x3D; status;        this.msg &#x3D; msg;        this.data &#x3D; data;        this.ok &#x3D; ok;    &#125;    public JSONResult(Object data) &#123;        this.status &#x3D; 200;        this.msg &#x3D; &quot;OK&quot;;        this.data &#x3D; data;    &#125;    public Boolean isOK() &#123;        return this.status &#x3D;&#x3D; 200;    &#125;    public Integer getStatus() &#123;        return status;    &#125;    public void setStatus(Integer status) &#123;        this.status &#x3D; status;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg &#x3D; msg;    &#125;    public Object getData() &#123;        return data;    &#125;    public void setData(Object data) &#123;        this.data &#x3D; data;    &#125;public String getOk() &#123;return ok;&#125;public void setOk(String ok) &#123;this.ok &#x3D; ok;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--核心功能</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E5%8D%95%E4%BD%93%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h2><h3 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h3><pre><code>用户 -----访问网站进行注册---输入用户名密码----校验（主要针对用户名不要和数据库的用户名字一样，密码的校验两次输入一致）--那么后端收到这三个参数如何处理呢？第一步肯定是判断：三个参数是否存在空值的情况，虽然有前端的判断，但是不排除有人会绕过前端来注册，所以后端的判断一个都不能少。然后判断用户名是否已存在，我们不希望系统里存在两个张三。还要判断密码长度是否小于6，我们不希望咱们网站的用户密码太过脆弱。最后判断两次密码是否一致。校验失败重新输入，成功注册成功了</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>  用户名以及密码表单提交的以后  会把这三个参数包装到jsonobject传入后段  偏向于业务类型的jsonobject<br>  UserBO去接收前端传入的对象  成员属性包括用户名字， 密码 ， 确认密码<br>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">@PostMapping(&quot;&#x2F;regist&quot;) public JSONResult regist(@RequestBody UserBO userBO,                          HttpServletRequest request,                          HttpServletResponse reponse) &#123;     String username &#x3D; userBO.getUsername();     String password &#x3D; userBO.getPassword();     String confirmPassword &#x3D; userBO.getConfirmPassword();     &#x2F;&#x2F;1. 判断用户名和密码必须不为空     if (StringUtils.isBlank(username) ||             StringUtils.isBlank(password)) &#123;         return JSONResult.errorMsg(&quot;用户名或密码不能为空&quot;);     &#125;     &#x2F;&#x2F;查询用户名是否存在     boolean isExist &#x3D; userService.queryUsernameIsExist(username);     if(isExist)&#123;         return JSONResult.errorMsg(&quot;用户名已经存在&quot;);     &#125;     &#x2F;&#x2F;密码长度不能少于6位     if(password.length()&lt;6)&#123;         return JSONResult.errorMsg(&quot;密码长度不能少于6&quot;);     &#125;     &#x2F;&#x2F;判断两次密码是否一致     if(!password.equals(confirmPassword))&#123;         return JSONResult.errorMsg(&quot;两次密码输入不一致&quot;);     &#125;     &#x2F;&#x2F;实现注册     Users userResult &#x3D; userService.createUser(userBO);     userResult &#x3D; setNUllProperty(userResult);     CookieUtils.setCookie(request,reponse,&quot;user&quot;, JsonUtils.objectToJson(userResult),true);     return JSONResult.ok(); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  具体的还是看代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(propagation &#x3D; Propagation.SUPPORTS)    @Override    public boolean queryUsernameIsExist(String username) &#123;        Example userExample &#x3D; new Example(Users.class);&#x2F;&#x2F;查询哪一个对应的实体类        Example.Criteria userExampleCriteria &#x3D; userExample.createCriteria();        userExampleCriteria.andEqualTo(&quot;username&quot;, username);&#x2F;&#x2F;构建条件        Users user &#x3D; usersMapper.selectOneByExample(userExample);        return user &#x3D;&#x3D; null ? false : true;    &#125;    &#x2F;*        创建用户     *&#x2F;    @Transactional(propagation &#x3D; Propagation.REQUIRED)    @Override    public Users createUser(UserBO userBO) &#123;        &#x2F;&#x2F;保证主键全局唯一，这个之后继续学习，id生成器        String userId &#x3D; sid.nextShort();        Users user &#x3D; new Users();        user.setId(userId);        user.setUsername(userBO.getUsername());        try &#123;            user.setPassword(MD5Utils.getMD5Str(userBO.getPassword()));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F;设置默认值        user.setNickname(userBO.getUsername());        user.setFace(USER_FACE);        user.setBirthday(DateUtil.stringToDate(&quot;1970-01-01&quot;));        user.setSex(Sex.secret.type);        user.setCreatedTime(new Date());        user.setUpdatedTime(new Date());        usersMapper.insert(user);        return user;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiOperation(value &#x3D; &quot;用户名登录&quot; , notes &#x3D; &quot;用户名登录&quot;, httpMethod &#x3D; &quot;POST&quot;)    @PostMapping(&quot;&#x2F;login&quot;)    public JSONResult login(@RequestBody UserBO userBO,                                      HttpServletRequest request,                                      HttpServletResponse reponse) throws Exception &#123;        String username &#x3D; userBO.getUsername();        String password &#x3D; userBO.getPassword();        String confirmPassword &#x3D; userBO.getConfirmPassword();        &#x2F;&#x2F;0. 判断用户名和密码必须不为空        if (StringUtils.isBlank(username) ||                StringUtils.isBlank(password)) &#123;            return JSONResult.errorMsg(&quot;用户名或密码不能为空&quot;);        &#125;        &#x2F;&#x2F;1. 实现登录        Users userResult &#x3D; userService.queryUserForLogin(username,                MD5Utils.getMD5Str(password));        if (userResult&#x3D;&#x3D;null)&#123;            return JSONResult.errorMsg(&quot;用户名或密码不正确&quot;);        &#125;        userResult &#x3D; setNUllProperty(userResult);        CookieUtils.setCookie(request,reponse,&quot;user&quot;, JsonUtils.objectToJson(userResult),true);        return JSONResult.ok(userResult);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional(propagation &#x3D; Propagation.SUPPORTS)    @Override    public Users queryUserForLogin(String username, String password) &#123;        Example userExample &#x3D; new Example(Users.class);&#x2F;&#x2F;查询哪一个对应的实体类        Example.Criteria userExampleCriteria &#x3D; userExample.createCriteria();        userExampleCriteria.andEqualTo(&quot;username&quot;, username);&#x2F;&#x2F;构建条件        userExampleCriteria.andEqualTo(&quot;password&quot;,password);        Users user &#x3D; usersMapper.selectOneByExample(userExample);        return user ;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h2><h2 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie session"></a>cookie session</h2><p>cookie:</p><p>以键值对的形式存储在浏览器<br>cookie不能跨域，当前及其父级域名可以取值（比如mercury.jd.como可以取值到jd.com域名）<br>cookie可以设置有效期<br>cookie可以设置path（<a href="http://www.jd.com/users">www.jd.com/users</a> 设置了此域名，其他该域名下的路径就不可以使用此cookie）<br>session</p><p>基于服务器内存的缓存（非持久化），可保存请求会话  非持久化指的是服务器宕机或者重启之后，所有的会话请求都会丢失<br>每个session通过sessionid来区分不同请求<br>session可以设置过期时间<br>session也是以键值对形式存在的<br>用户第一次请求，在服务器端，只要创建了一个session，就可以在cookie里面保存一个jessionid，可以在servlet中设置，下一次请求，request header会携带此cookie.</p><p>其他文章具体总结</p><h2 id="集成Swagger2-api"><a href="#集成Swagger2-api" class="headerlink" title="集成Swagger2 api"></a>集成Swagger2 api</h2><h2 id="日志监控功能"><a href="#日志监控功能" class="headerlink" title="日志监控功能"></a>日志监控功能</h2><h2 id="自定义相应数据结构"><a href="#自定义相应数据结构" class="headerlink" title="自定义相应数据结构"></a>自定义相应数据结构</h2><h2 id="分类的设计与实现-：商品的类别"><a href="#分类的设计与实现-：商品的类别" class="headerlink" title="分类的设计与实现 ：商品的类别"></a>分类的设计与实现 ：商品的类别</h2><h2 id="首页商品推荐"><a href="#首页商品推荐" class="headerlink" title="首页商品推荐"></a>首页商品推荐</h2><h2 id="商品的搜索与分页"><a href="#商品的搜索与分页" class="headerlink" title="商品的搜索与分页"></a>商品的搜索与分页</h2><h2 id="商品的详情与评论渲染"><a href="#商品的详情与评论渲染" class="headerlink" title="商品的详情与评论渲染"></a>商品的详情与评论渲染</h2><h2 id="购物车与订单-订单的幂等性-锁的机制控制库存"><a href="#购物车与订单-订单的幂等性-锁的机制控制库存" class="headerlink" title="购物车与订单 订单的幂等性 锁的机制控制库存"></a>购物车与订单 订单的幂等性 锁的机制控制库存</h2><h2 id="微信与支付宝支付"><a href="#微信与支付宝支付" class="headerlink" title="微信与支付宝支付"></a>微信与支付宝支付</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体项目--准备工作</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%95%86%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91--%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%95%86%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91--%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="电商项目：单体架构设计于项目开发"><a href="#电商项目：单体架构设计于项目开发" class="headerlink" title="电商项目：单体架构设计于项目开发"></a>电商项目：单体架构设计于项目开发</h1><h1 id="基于SpringBoot2-x"><a href="#基于SpringBoot2-x" class="headerlink" title="基于SpringBoot2.x"></a>基于SpringBoot2.x</h1><p>实现单体电商项目核心功能开发</p><p>实现单体电商项目个人中心功能</p><p>项目部署上线</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>项目展示以及主要的功能：轮播图<br>                    主页不同分类<br>                    根据页面的滚动慢慢的进行加载：在前端设计的调用模式<br>                    首页搜索功能：输入关键词 页面跳转<br>                    分页功能<br>                    默认排序 销量排序 价格有限 排序规则<br>                    购物车<br>                    支付<br>                    没有登录的话就登录<br>                    登录功能 回调到购物车<br>                    结算页面  地址 可以进行编辑 选择<br>                    微信支付 支付宝支付<br>                    查看我的订单 跳转到个人中心<br>                    个人中心：代发货<br>                    其中就是订单<br>                    我的评价<br>                    我的信息<br>                    收货地址</p><h2 id="前后段主要技术选型"><a href="#前后段主要技术选型" class="headerlink" title="前后段主要技术选型"></a>前后段主要技术选型</h2><p>后段技术选型<br><code>SpringBoot Spring Mybatis</code> 框架整合</p><p>SpringBoot还是SpringMVC??<br>SpringMVC是框架  配置项很多就很繁琐<br>                还得自己下载tomcat<br>SpringBoot是框架：主要实现了自动配置，<br>                从xml配置繁琐到yml，<br>                还集成了很多的中间件，用starter依赖和引用，简化了maven配置<br>                从外置的tomcat变为内置的tomcat，在yaml就可以配置</p><p>前端技术选型：<br>        Jquery<br>        VUE本身是渐进式框架，方便。在渐进式过程中可以逐步逐步去替换掉原来的代码<br>        html<br>        css</p><p>技术选型要考虑到的：<br>    切合业务<br>    社区活跃度：代表使用率高，优缺点<br>    团队技术水平<br>    版本更新迭代的周期：以前Dubbo中间停更了一段时间，那么这段时间就会影响业务的使用<br>    安全性<br>    成功案例：口碑不错的</p><h2 id="前后端分离开发模式："><a href="#前后端分离开发模式：" class="headerlink" title="前后端分离开发模式："></a>前后端分离开发模式：</h2><p>早起传统的JAVAweb开发模式：<br>                      用户 – 浏览器 -url–服务器 war包(后段model,view,controller 前端html(jsp渲染成html)cssjs)  只要有用户访问服务器，所有请求的页面都在服务器进行渲染。当用户越来越多的话， 所有页面都在服务器进行渲染，服务器压力太大了了。<br>                      需要注意的是  传统web开发 ，浏览器请求到的服务器的所有页面都是基于url来进行跳转的</p><p>前后端单页面的交互：mvvm前端开发模式<br>                        手机  – 小程序/安卓—- ———–服务器model,view<br>                      用户—-浏览器–h5–nginx（html css js）–Restful webservice&gt;-服务器model,view,controller静态资源在静态资源服务器上，<br>                      前端龟前端，后端代码只要一套极好了</p><h2 id="数据库表设计："><a href="#数据库表设计：" class="headerlink" title="数据库表设计："></a>数据库表设计：</h2><p>全局的规划，数据库表设计工具设计库以及表，前期就设计好的<br><code>PDMan</code>:<br>            数据库建模工具<br>            设置：预处理的模版， 每次新建表的时候都会生成<br>            数据库设置：<br>            如何把关系图和数据库的表进行对应：模型版本–初始化基线写版本号-点击同步，注意同步配置里选的必须是增量</p><hr><h3 id="我们的设计库表中没有使用数据库外键"><a href="#我们的设计库表中没有使用数据库外键" class="headerlink" title="我们的设计库表中没有使用数据库外键"></a>我们的设计库表中没有使用数据库外键</h3><p>1，性能影响</p><p>对于数据的完整性会做检查操作，特别是在大并发的时候，会影响性能</p><p>2，热更新（不停机维护）<br>如果有外键的话，是强一致性的，使的新更新的代码无法运行，需要重启服务。而我们希望不停机维护。</p><p>3 降低耦合度</p><p>物理外键不存在，逻辑外键还是存在的，比如说cghtb有htbh字段，htmxb也有htbh字段</p><p>4 数据库分库发表<br>有外键关系的两张表，难以做到分到两个不同的数据库，因为耦合度是在是太高了。</p><hr><h2 id="项目结构搭建"><a href="#项目结构搭建" class="headerlink" title="项目结构搭建"></a>项目结构搭建</h2><h3 id="项目拆分与聚合："><a href="#项目拆分与聚合：" class="headerlink" title="项目拆分与聚合："></a>项目拆分与聚合：</h3><p>后段分层架构模式：基于maven分层与拆分<br>项目分层设计原则<br>前期拆分：根据业务拆分为不同的子模块<br>后期聚合：通过<code>maven</code>项目的聚合</p><p>jar                             common.jar子模块/工程  pojo.jar(数据库表逆向生成)  mapper.jar<br>或者        —-                service.jar  controller.jar     。。。<br>war<br>最终运行的包                      pom聚合工程  所有子模块都在聚合工程里面</p><p>这样的话就可以很多人进行开发<br>多个不同的项目可以都导入common的依赖不用多次写代码，</p><h3 id="Idea构建：具体操作的话可以参考https-blog-csdn-net-weixin-43434182-article-details-108017186"><a href="#Idea构建：具体操作的话可以参考https-blog-csdn-net-weixin-43434182-article-details-108017186" class="headerlink" title="Idea构建：具体操作的话可以参考https://blog.csdn.net/weixin_43434182/article/details/108017186"></a>Idea构建：具体操作的话可以参考<a href="https://blog.csdn.net/weixin_43434182/article/details/108017186">https://blog.csdn.net/weixin_43434182/article/details/108017186</a></h3><pre><code> 1. 拆分：        父工程由于构建的是聚合工程，所以打包方式选择pom        构建pojo，pojo引用common        构建mapper，mapper引用pojo，        构建service，service引用mapper，        构建api，api引用service    聚合：root --install 之后依赖关系才会真正的建立2. 父工程整合spring boot   pom.xml引入spring boot基础依赖</code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.imooc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>foodie-dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--        1.聚合工程可以分顶级项目（顶级工程，父工程）和子工程，两者之间为继承关系        子工程在maven中称之为module，模块之间时平级的，可以相互依赖        2.子工程可以使用父工程所有的资源（依赖），子工程之间如果需要相互之间使用资源，需要构建依赖（构建关系）        3.父工程可以由多个子工程组合而成    --></span>    <span class="token comment">&lt;!--所有的子工程都会在这里出现--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-common<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-pojo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-mapper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>foodie-dev-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 聚合工程打包方式选择pom--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>     <span class="token comment">&lt;!--引入依赖parent,统一管理版本--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--设置资源属性--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--设置源码编码格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--设置编译后文件编码格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token comment">&lt;!--排除这一块依赖，后续引入其他依赖--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!--spring boot可以解析yml文件，如果想解析xml等非yml配置文件，需要此依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-configuration-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span>然后在controller层就可以在resource下创建application.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编写启动类<br>    <pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class,args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>然后，因为是聚合项目，需要先install子项目，使其成为主项目的依赖，然后启动项目</p><hr><p>mybatis mysql mapper<br>导入依赖<br>写配置文件<br>mybatis逆向生成工具:打开项目，主要修改generatorConfig.xml文件,然后GeneratorDisplay，右键运行，生成相应的文件，<br>复制到项目中，因为引用了通用mapper，需要在项目中进行相应的配置</p><p>Restful<br>api service 层开发<br><code>Postman</code>调试Restful接口</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体电商项目--跨域配置实现前后端联调</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE--%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE--%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class CorsConfig &#123;    public CorsConfig()&#123;    &#125;    @Bean    public CorsFilter corsFilter()&#123;        &#x2F;&#x2F;1. 添加cors配置信息        CorsConfiguration config &#x3D; new CorsConfiguration();        &#x2F;*允许访问的客户端域名*&#x2F;&#x2F;&#x2F;        config.addAllowedOrigin(&quot;http:&#x2F;&#x2F;192.168.180.129:80&quot;);        config.addAllowedOrigin(&quot;http:&#x2F;&#x2F;localhost:8080&quot;);        &#x2F;&#x2F;&#x2F;*是否允许请求带有验证信息*&#x2F;设置是否发送cookie信息        config.setAllowCredentials(true);        &#x2F;&#x2F;设置允许请求的方式        config.addAllowedMethod(&quot;*&quot;);        &#x2F;*允许服务端访问的客户端请求头*&#x2F;        config.addAllowedHeader(&quot;*&quot;);        &#x2F;&#x2F;2. 为url添加映射路径        UrlBasedCorsConfigurationSource corsSource &#x3D; new UrlBasedCorsConfigurationSource();        corsSource.registerCorsConfiguration(&quot;&#x2F;**&quot;,config);&#x2F;&#x2F;所有路径都可以使用配置信息        return new CorsFilter(corsSource);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/javaweb/javaweb%E7%AC%94%E8%AE%B0-----html/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/javaweb/javaweb%E7%AC%94%E8%AE%B0-----html/</url>
      
        <content type="html"><![CDATA[<p>1、HTML语法<br>      1)标签分为有开始有结束的标签和自结束标签<br>      2)标签不区分大小写<br>      3)标签可以嵌套，但不可以交叉嵌套<br>      4)标签必须正常关闭<br>      5)标签的属性必须有值，且属性值必须用引号括起来<br>      6)注释不可以嵌套</p><p>2、常用标签<br>      1)标题标签h1-h6,大小粗细递减<br>      2)<div></div>标签作用布局<br>      3)<p></p>段落标签<br>      4)转义字符       以&amp;开始，以;结束<br>                                          普通空格：&nbsp;<br>                                          中文空格：&emsp;<br>                                          大于号：&gt;<br>                                          小于号：&lt;<br>                                          版权号：&copy;<br>      5)列表<br>                                    有序列表<ol><br>                        <li></li><br>                                 </ol><br>                                    无序列表<ul><br>                        <li></li><br>                                 </ul>    type:disc 实心圆  、circle空心圆 、 square 方块</p><p>3、插入图片<code>&lt;img alt=&quot;picture&quot; src=&quot;img/wm.jpg&quot; title=&quot;aaa&quot;&gt;</code><br>     img 标签插入图片<br>     alt:图片插入路径有误时显示的文本<br>     src:图片插入的路径<br>     title:鼠标悬停时提示文本<br>     ../返回上一级<br>     src路径：当目标文件与当前文件在同一包中时可以直接访问。<br>                                当目标文件和当前文件不在同一包中时，要先找其父包，再找目标文件。</p><p>4、超链接    <code>&lt;a href=&quot;pages/target.html&quot; target=&quot;_blank&quot;&gt;</code>跳转到目标页面，目标页面有美女！</a><br>             使用a标签制作超链接<br>          href中是链接路径<br>          target中有        _blank在新的页面下打开<br>                      _self在当前界面打开</p><p>5、表格<br>         <code>&lt;table&gt;                &lt;tr&gt;             tr表示行                    &lt;th&gt;|&lt;td&gt;    th表头|td单元格                &lt;/tr&gt;          &lt;/table&gt;</code></p><pre><code>     rowspan跨行     clospan跨列     align=&quot;cender&quot;居中     width     height     border边界</code></pre><p>6、表单<br>               使用form制作表单<br>        input制作表单项<br>         type表单项类型<br>          text文本框<br>          password密码框<br>          reset重置<br>          submit提交<br>          file<br>          hidden</p><pre><code>     `name`名称，有name属性才可以提交数据到目标位置     value值     checked默认选中(radio(单选)|checkbox(复选))             使用select option 制作表单   action属性   表单提交的路径   method属性     表单提交的方式      get不安全     post安全</code></pre><p>7、CSS<br>1.CSS样式由选择符(选择器)和声明组成，而声明又由属性和值组成<br>选择器的分类<br>    ①标签选择器：如上图的p<br>    ②类选择器：.class属性值{..}<br>    ③ID选择器：#id属性值{..}<br>①写在标签的style属性中：<code>&lt;p style=“font-size: 30px”&gt;字体大小用px表示&lt;/p&gt;</code><br>②写在style标签中(style标签一般写在head标签与title标签之间)：<br>          <pre class="line-numbers language-html" data-language="html"><code class="language-html">      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">  <span class="token selector">p</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>③引入外部CSS文件：<br>    <code>html&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; </code>  </p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>html学习笔记<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">p</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>gold<span class="token punctuation">&#125;</span>        <span class="token selector">.color_orange</span><span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">&#125;</span>        <span class="token selector">#font_size</span><span class="token punctuation">&#123;</span><span class="token property">font-size</span><span class="token punctuation">:</span> 36px<span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>这是我的第一个html页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    1. 语法<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>    <span class="token comment">&lt;!-- 1.标签的分类    开始结束标签    自闭合标签    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>css<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color_orange<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>javascript<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>font_size<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 2.标签不区分大小写 --></span>    <span class="token comment">&lt;!-- 3.标签可以嵌套但不能交叉嵌套 --></span>    <span class="token comment">&lt;!-- 4.标签必须正确关闭 --></span>    <span class="token comment">&lt;!-- 5.属性必须有值，且属性值必须加引号 --></span>    <span class="token comment">&lt;!-- 6.注释不能嵌套 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span>  <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>动漫头像  图片不能显示提示信息<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>动漫头像 放到图片上提示信息<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>常用标签.html<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击有美女,新页面打开<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>常用标签.html<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_self<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击有美女,在该页面打开<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>300px<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>姓名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>年龄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>静<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>13<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>喜洋洋<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--action表单提交的路径--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>success.html<span class="token punctuation">"</span></span>   <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        用户名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        密<span class="token entity named-entity" title="&emsp;">&amp;emsp;</span>码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        性别：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>man<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checked<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>男        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>woman<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        爱好：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>basketball<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checked<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>篮球        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>football<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>足球        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>volleyball<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>排球        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        喜欢的明星：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>star<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fbb<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>范冰冰<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>杨颖<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zzy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>章子怡<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 JavaWeb</title>
      <link href="2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/javaweb/javaweb/"/>
      <url>2020/11/20/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/javaweb/javaweb/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><ol><li>什么是 JavaWeb</li></ol><p>JavaWeb 是指，<code>所有通过Java语言编写可以通过浏览器访问的程序的总称</code>，叫 JavaWeb。 JavaWeb 是基于请求和响应来开发的。</p><p>b)什么是请求</p><p>请求是指客户端给服务器发送数据，叫请求 Request。</p><p>c)什么是响应</p><p>响应是指服务器给客户端回传数据，叫响应 Response。</p><p>d)请求和响应的关系</p><p>请求和响应是成对出现的，有请求就有响应。</p><ol start="2"><li>Web 资源的分类</li></ol><p>web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。 静态资源： html、css、js、txt、mp4 视频 , jpg 图片<br><strong>动态资源： jsp 页面、Servlet 程序</strong></p><p>3.常用的 Web 服务器</p><p>Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。它是一种轻量级的 javaWeb 容器（服务 器），也是当前应用最广的 JavaWeb 服务器（免费）。 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）。<br>GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业服务器，达到产品级质量（应用很少）。<br>Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良， resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的 Web 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）</p><p><img src="2020-12-10-17-41-59.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="2020/11/17/%E5%BC%82%E5%B8%B8/"/>
      <url>2020/11/17/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="31-2：Java中的两种异常类型是什么"><a href="#31-2：Java中的两种异常类型是什么" class="headerlink" title="31-2：Java中的两种异常类型是什么"></a>31-2：Java中的两种异常类型是什么</h2><p>Java 中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。</p><ol><li>受检异常<br>这种异常在IO操作中⽐较多。<br>⽬的就是告诉这个⽅法的调⽤者，<br>我这个⽅法不保证⼀定可以成功，<br>是有可能找不到对应的⽂件的，<br>你要明确的对这种情况做特殊处理哦。</li><li>非受检异常<br>这种异常⼀般可以理解为是代码原因导致的。<br>⽐如发⽣空指针、数组越界等。</li></ol><h2 id="1-1：他们有什么区别"><a href="#1-1：他们有什么区别" class="headerlink" title="1-1：他们有什么区别"></a>1-1：他们有什么区别</h2><ol><li>不受检查的异常不需要在方法或者是构造函数上声明</li><li>受检查的异常必须要用 throws 语句在方法或者是构造函数上声明。</li></ol><h2 id="1-2：异常链"><a href="#1-2：异常链" class="headerlink" title="1-2：异常链"></a>1-2：异常链</h2><p>是指在进⾏⼀个异常处理时抛出了另外⼀个异常， 由此产⽣了⼀个异常链条。<br>该技术⼤多⽤于将“ 受检查异常” 封装成为“⾮受检查异常”或者RuntimeException。</p><h2 id="1-3：try、catch、finally执行顺序"><a href="#1-3：try、catch、finally执行顺序" class="headerlink" title="1-3：try、catch、finally执行顺序"></a>1-3：try、catch、finally执行顺序</h2><h3 id="不带return返回顺序"><a href="#不带return返回顺序" class="headerlink" title="不带return返回顺序"></a>不带return返回顺序</h3><p>如果try中没有异常，则顺序为try→finally，如果try中有异常，则顺序为try→catch→finally</p><h3 id="带return返回顺序"><a href="#带return返回顺序" class="headerlink" title="带return返回顺序"></a>带return返回顺序</h3><p><code>如果try中带有return</code><br>   程序执行try块中return之前代码；<br>   再执行finally块，最后执行try中return;<br>   <code>finally块之后的语句return不再执行</code>，因为程序在try中已经return过了。</p><p><code>catch块中有return</code><br>   程序先执行try，如果遇到异常执行catch块，<br>      有异常：执行catch中return之前代码，<br>             再执行finally语句中全部代码，<br>             最后执行catch块中return。<br>             finally之后的return不再执行。<br>      无异常：执行完try再finally再return。</p><p><code>try块和finally块中有return</code><br>   无异常：程序执行<code>try块中return之前</code>代码；<br>          再执行<code>finally块</code>，因为finally块中有return所以提前退出，<br>          而不再执行try中的return；<br>   有异常：不执行try，顺序执行catch-finally</p><p><code>catch块和finally块中有return</code><br>   无异常：执行try后跳过catch执行finally；得到finally的返回值；<br>   有异常：程序执行catch块中return之前代码；<br>          再执行finally块，因为finally块中有return所以提前退出。<br>          而不再执行catch中的return。</p><p><code>try块、catch块和finally块中有return</code><br>   无异常：然后再执行finally块，<br>          因为finally块中有return所以提前退出。<br>   有异常：执行catch块中return之前代码；<br>          再执行finally块，因为finally块中有return所以提前退出。</p><p><a href="https://www.jianshu.com/p/8c9ea967ffe6">https://www.jianshu.com/p/8c9ea967ffe6</a>  具体习题可参考这片博文</p><h2 id="1-4：什么是OOM？常见有哪些OOM"><a href="#1-4：什么是OOM？常见有哪些OOM" class="headerlink" title="1-4：什么是OOM？常见有哪些OOM"></a>1-4：什么是OOM？常见有哪些OOM</h2><ol><li><code>Java堆溢出——OutOfMemoryError</code><br>原因：由于不断创建对象实例，当对象数量达到了最大堆的容量限制后产生内存溢出异常。<br>解决方法：<br>1)首先确认是内存泄露（Memory Leak）还是内存溢出（Memory Overflow）；<br>2)如果是内存泄漏引起的，查看GC Roots引用链，找出为什么无法被垃圾回收的原因；<br>3)如果是内存溢出，检查虚拟机的堆参数（-Xmx最大值和-Xms最小值），对比物理内存看是否可以调大；</li><li><code>虚拟机栈和本地方法栈溢出——StackOverflowError</code><br>原因：在单线程下，虚拟机栈容量太小或者定义了大量的本地变量<br>解决方法：增大虚拟机栈容量<br>原因：在多线程下，大量创建新线程，会抛出OOM，每个线程的栈分配的内存越大，越容易产生；<br>解决方法：减少线程产生、降低最大堆、减少栈容量；</li><li><code>运行时常量池溢出</code><br>原因：代码在运行时创建了大量的常量，超出了常量池上限；<br>解决方法：通过修改-XX:PermSize和-XX:MaxPermSize参数来修改方法区大小，从而修改常量池大小；</li><li><code>方法区溢出</code><br>原因：在运行时，ClassLoader动态加载了大量的Class信息，超出方法区上限；<br>解决方法：通过修改参数来修改方法区大小；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Java集合---List集合比较</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88/List%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88/List%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="源码扩容过程有什么值得借鉴的地方？"><a href="#源码扩容过程有什么值得借鉴的地方？" class="headerlink" title="源码扩容过程有什么值得借鉴的地方？"></a>源码扩容过程有什么值得借鉴的地方？</h2><p>答：有两点：</p><ol><li>是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封 装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时， 也可快速扩容。</li><li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li></ol><p>这两点在我们平时设计和写代码时都可以借鉴。</p><h2 id="ArrayList-和-LinkedList-两者有没有最大容量"><a href="#ArrayList-和-LinkedList-两者有没有最大容量" class="headerlink" title="ArrayList 和 LinkedList 两者有没有最大容量"></a>ArrayList 和 LinkedList 两者有没有最大容量</h2><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存 空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用 的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p><h2 id="vector、Arraylist区别和适用场景"><a href="#vector、Arraylist区别和适用场景" class="headerlink" title="vector、Arraylist区别和适用场景"></a>vector、Arraylist区别和适用场景</h2><p>1.<code>线程</code>：Vector是多线程安全的， Vector类中的方法很多有synchronized进行修饰，<br>         只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>         ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。<br>         这样就导致了Vector在效率上无法与ArrayList相比</p><ol start="2"><li><p><code>底层</code>：两个都是数组实现，支持快速随机访问，其 API 都做了一层对数组底层访问的封装</p></li><li><p><code>初始化</code>：Vector无参构造器初始化时就生成了容量为10的空数组，ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。</p><pre><code>  Vector可以设置增长因子CapacityIncrement，而ArrayList不可以</code></pre></li><li><p><code>扩容机制</code>：<br>Vector在每次add增加元素(可能是1个，也可能是一组)时，都要调用ensureCapacityHelper方法来确保足够的容量，当容量不足以容纳当前的元素个数时，即minCapacity（指的是当前元素数目elementCount + 1） - elementData.length &gt; 0，就会grow(minCapacity)扩容，就看构造方法中传入的容量增长系数CapacityIncrement是否为0，</p><pre><code>  如果不为0，就设置新的容量为 旧容量 + 容量增长量；  如果为0，设置新的容量为旧的容量的2倍，  如果设置后的容量还不够，则直接新的容量设置为  传入参数所需要的容量 </code></pre><p>ArrayList在每次add增加元素(可能是1个，也可能是一组)时，都要调用nsureCapacityInternal方法来确保足够的容量,如果我们期望的最小容量大于目前数组的长度，那么就扩容.</p><ol><li>ArrayList第一次add元素时，扩容为长度为10的数组。<br>当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时minCapacity等于默认的容量（10）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</li></ol></li></ol><h2 id="ArrayList、LinkedList区别和适用场景"><a href="#ArrayList、LinkedList区别和适用场景" class="headerlink" title="ArrayList、LinkedList区别和适用场景"></a>ArrayList、LinkedList区别和适用场景</h2><ol><li><code>是否保证线程安全</code>： ArrayList在单线程下是线程安全的，<pre><code>             多线程下由于多个线程不断抢夺资源，             所以会出现不安全             和 LinkedList 都是不同步的，也就是不保证线程安全；</code></pre></li><li><code>底层数据结构</code>： Arraylist 底层使用的是 Object 数组；<pre><code>             LinkedList 底层使用的是 双向链表 数据结构</code></pre></li><li><code>插入和删除是否受元素位置的影响</code>：<br>① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。<br>② LinkedList 采用链表存储，插入删除元素时间复杂度不受元素位置的影响，<pre><code>         如果是要在指定位置i插入和删除元素的话需要先移动到指定位置再插入。</code></pre></li><li><code>是否支持快速随机访问</code>： LinkedList 不支持高效的随机元素访问，<br>LinkedList 并没有采用从头循环到尾的做法， 而是采取了简单二分 法， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值 得我们借鉴。<br>而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。</li><li><code>内存空间占用</code>： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间；<br>双向链表节点对应的类Node的实例，<br>Node中包含成员变量：prev，next，item。<br>prev是该节点的上一个节点，<br>next是该节点的下一个节点，<br>item是该节点所包含的值。（因为要存放直接后继和直接前驱以及数据）<br>当需要对数据进行对此访问的情况下选用ArrayList，<br>当需要对数据进行多次增加删除修改时采用LinkedList。<br>ArrayList与LinkedList集合各有所长，可以在不同场合根据具体需求选用:<br>–    ArrayList元素的检索速度高于LinkedList<br>–    LinkedList因为内存的不连续性，更适合于大批量数据的存放和管理<br>–    如果在非末端插入数据，LinkedList速度优于ArrayList</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Java集合---LinkedList源码笔记</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88/LinkedList/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88/LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><font color=orange>LinkedList</font></h1><!-- ![avatar](http://i1.fuimg.com/729820/166f5e5b5f18282c.png)   --><img src='http://i1.fuimg.com/729820/166f5e5b5f18282c.png' width="30%"  ><font color=orange>可爱的小姐姐头像镇楼～～～～～～继续总结。开始LinkedList咯～～～～还是来个可爱的分隔符～</font><p><code>-------------------------------------------------------</code></p><h2 id="3-1：linkedlist数据结构"><a href="#3-1：linkedlist数据结构" class="headerlink" title="3-1：linkedlist数据结构"></a>3-1：linkedlist数据结构</h2><p><code>LinkedList</code>是List接口的<strong>双向链表</strong>非同步实现，<br>并允许包括<code>null</code>在内的所有元素。<br>双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如 下：</p><p>双向链表节点对应的<code>类Node</code>的实例，<br>Node中包含成员变量：<code>prev，next，item。</code><br><code>prev</code>是该节点的上一个节点，<br><code>next</code>是该节点的下一个节点，<br><code>item</code>是该节点所包含的值。<br><code>first</code> 是双向链表的头节点，它的前一个节点是 null。<br><code>last</code> 是双向链表的尾节点，它的后一个节点是 null；<br>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；<br>因为是个<code>双向链表</code>，只要机器内存足够强大，是没有大小限制的。</p><h2 id="3-2：linkedlist-根据索引返回对应的Node值"><a href="#3-2：linkedlist-根据索引返回对应的Node值" class="headerlink" title="3-2：linkedlist   根据索引返回对应的Node值"></a>3-2：linkedlist   根据索引返回对应的Node值</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Returns the (non-null) Node at the specified element index. *&#x2F;Node&lt;E&gt; node(int index) &#123;    &#x2F;&#x2F; assert isElementIndex(index);    if (index &lt; (size &gt;&gt; 1)) &#123;&#x2F;&#x2F; 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; 1 是 size 除以 2 的意思。        Node&lt;E&gt; x &#x3D; first;&#x2F;&#x2F; 直到 for 循环到 index 的前一个 node 停止        for (int i &#x3D; 0; i &lt; index; i++)            x &#x3D; x.next;        return x;    &#125; else &#123;&#x2F;&#x2F; 如果 index 处于队列的后半部分，从尾开始找        Node&lt;E&gt; x &#x3D; last;&#x2F;&#x2F; 直到 for 循环到 index 的后一个 node 停止        for (int i &#x3D; size - 1; i &gt; index; i--)            x &#x3D; x.prev;        return x;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码中我们可以发现， LinkedList 并没有采用从头循环到尾的做法， 而是采取了<font color=orange>简单二分法</font>， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，<code>这种思想值 得我们借鉴。</code></p><h2 id="3-3：linkedlist增加节点"><a href="#3-3：linkedlist增加节点" class="headerlink" title="3-3：linkedlist增加节点"></a>3-3：linkedlist增加节点</h2><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把 节点的值，前后指向节点都置为 null，帮助 GC 进行回收。<br>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开 始追加，addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void linkLast(E e) &#123;&#x2F;&#x2F; 把尾节点数据暂存    final Node&lt;E&gt; l &#x3D; last;&#x2F;&#x2F; 新建新的节点，初始化入参含义： &#x2F;&#x2F; l 是新节点的前一个节点，当前值是尾节点值    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);    last &#x3D; newNode;&#x2F;&#x2F;如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节    if (l &#x3D;&#x3D; null)        first &#x3D; newNode;&#x2F;&#x2F;否则把前尾节点的下一个节点，指向当前尾节点。    else        l.next &#x3D; newNode;&#x2F;&#x2F;大小和版本更改    size++;    modCount++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从头部追加（addFirst）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Links e as first element. *&#x2F;private void linkFirst(E e) &#123;    final Node&lt;E&gt; f &#x3D; first;    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);    first &#x3D; newNode;    if (f &#x3D;&#x3D; null)        last &#x3D; newNode;    else        f.prev &#x3D; newNode;    size++;    modCount++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4：linkedlist删除节点"><a href="#3-4：linkedlist删除节点" class="headerlink" title="3-4：linkedlist删除节点"></a>3-4：linkedlist删除节点</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">private E unlinkLast(Node&lt;E&gt; l) &#123;    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;    final E element &#x3D; l.item;    final Node&lt;E&gt; prev &#x3D; l.prev;    l.item &#x3D; null;    l.prev &#x3D; null; &#x2F;&#x2F; help GC    last &#x3D; prev;    if (prev &#x3D;&#x3D; null)        first &#x3D; null;    else        prev.next &#x3D; null;    size--;    modCount++;    return element;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">private E unlinkFirst(Node&lt;E&gt; f) &#123;    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;    final E element &#x3D; f.item;    final Node&lt;E&gt; next &#x3D; f.next;    f.item &#x3D; null;    f.next &#x3D; null; &#x2F;&#x2F; help GC    first &#x3D; next;    if (next &#x3D;&#x3D; null)        last &#x3D; null;    else        next.prev &#x3D; null;    size--;    modCount++;    return element;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Java集合---Vector源码笔记</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88/Vector/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88/Vector/</url>
      
        <content type="html"><![CDATA[<p><code>VECTOR</code></p><p><code>休息了一会会，接着再来看看Vector的源码吧，加油～～</code><br><img src='http://i1.fuimg.com/729820/166f5e5b5f18282c.png' width="25%" ><br><code>-----------------------------------------------------------------------------</code></p><h2 id="1-1：vector数据结构"><a href="#1-1：vector数据结构" class="headerlink" title="1-1：vector数据结构"></a>1-1：vector数据结构</h2><p>底层数据结构为<code>数组</code>，支持快速随机访问</p><h2 id="1-2：vector构造器"><a href="#1-2：vector构造器" class="headerlink" title="1-2：vector构造器"></a>1-2：vector构造器</h2><p><code>Vector</code>有四个不同的构造函数。 无参构造的容量默认值为10，容量增长系数<code>CapacityIncrement</code>为0</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Vector(int initialCapacity, int capacityIncrement) &#123;    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    this.elementData &#x3D; new Object[initialCapacity];    this.capacityIncrement &#x3D; capacityIncrement;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3：vector-indexOf-object-o"><a href="#1-3：vector-indexOf-object-o" class="headerlink" title="1-3：vector  indexOf(object o)"></a>1-3：vector  indexOf(object o)</h2><p>Vector在查找给定元素索引值方法中，<code>indexOf(object o )</code>–&gt;<br>Vector中允许元素为<code>null</code><br>源码都将该元素的值分为null和不为null两种情况处理，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int indexOf(Object o) &#123;    return indexOf(o, 0);&#125;public synchronized int indexOf(Object o, int index) &#123;    if (o &#x3D;&#x3D; null) &#123;        for (int i &#x3D; index ; i &lt; elementCount ; i++)            if (elementData[i]&#x3D;&#x3D;null)                return i;    &#125; else &#123;        for (int i &#x3D; index ; i &lt; elementCount ; i++)            if (o.equals(elementData[i]))                return i;    &#125;    return -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4：扩容机制"><a href="#1-4：扩容机制" class="headerlink" title="1-4：扩容机制"></a>1-4：扩容机制</h2><p>与<code>ArrayList</code>不同的是，<br><code>Vector</code>在每次<code>add</code>增加元素(可能是1个，也可能是一组)时，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public synchronized boolean add(E e) &#123;    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] &#x3D; e;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都要调用<code>ensureCapacityHelper</code>方法来确保足够的容量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void ensureCapacityHelper(int minCapacity) &#123;    &#x2F;&#x2F; overflow-conscious code    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当容量不足以容纳当前的元素个数时，即<code>minCapacity</code>（指的是当前元素数目<code>elementCount + 1） - elementData.length &gt; 0</code>，就会<code>grow(minCapacity)</code>扩容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void grow(int minCapacity) &#123;    &#x2F;&#x2F; overflow-conscious code    int oldCapacity &#x3D; elementData.length;    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ?                                     capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity &#x3D; minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity &#x3D; hugeCapacity(minCapacity);    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就看构造方法中传入的容量增长系数<code>CapacityIncrement</code>是否为0，<br>**如果不为0，就设置新的容量为 旧容量 + 容量增长量；<br>如果为0，设置新的容量为旧的容量的2倍，<br>如果设置后的容量还不够，则直接新的容量设置为传入参数所需要的容量 **<br>而后同样用<code>Arrays.copyof()</code>方法将元素拷贝到新的数组。</p><h2 id="1-5：Vector是保证线程安全的"><a href="#1-5：Vector是保证线程安全的" class="headerlink" title="1-5：Vector是保证线程安全的"></a>1-5：Vector是保证线程安全的</h2><p>由于vector中Add方法加了<code>synchronized</code>，来保证add操作是线程安全的</p>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入学习-----ArrayList</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88/ArrayList/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88/ArrayList/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 深入Java集合—ArrayList源码笔记<br>date: 2020-11-17 14:20:32<br>tags: java，集合，源码</p><hr><h1 id="ARRAYLIST"><a href="#ARRAYLIST" class="headerlink" title="ARRAYLIST"></a><font color=orange>ARRAYLIST</font></h1><!-- ![avatar](http://i1.fuimg.com/729820/166f5e5b5f18282c.png)   --><img src='http://i1.fuimg.com/729820/166f5e5b5f18282c.png' width="30%" ><p><code>可爱的小姐姐头像镇楼～～～～～～ 今天打算把看过的源码总结一下。从集合框架开始咯～～～～ 来个可爱的分隔符～！ 话不多说正式开始总结啦！！！！</code><br><code>-------------------------------------------------------</code></p><h2 id="数组-Array-和列表-ArrayList-有什么区别？"><a href="#数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？"></a>数组(Array)和列表(ArrayList)有什么区别？</h2><ol><li>定义上： Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。 </li><li>容量上： Array 大小固定， ArrayList 的大小是动态变化的。 </li><li>操作上： ArrayList 提供更多的方法和特性， </li></ol><p>使用基本数据类型或者知道数据元素数量的时候<br>可以考虑Array;<br>ArrayList处理固定数量<br>的基本类型数据类型时<br>会自动装箱来减少编码工作量，<br>但是相对较慢。</p><h2 id="2-1：ArrayList数据结构"><a href="#2-1：ArrayList数据结构" class="headerlink" title="2-1：ArrayList数据结构"></a>2-1：ArrayList数据结构</h2><p>private transient Object[] elementData;<br>底层使用<code>数组</code>实现, 其 API 都做了一层对数组底层访问的封装</p><p>并允许包括null在内的所有元素。</p><h2 id="2-2-：构造器"><a href="#2-2-：构造器" class="headerlink" title="2-2 ：构造器"></a>2-2 ：构造器</h2><p>有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如 下：<br><code>无参数直接初始化:</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;public ArrayList() &#123;    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。<br><code>指定初始数据初始化</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ArrayList(Collection&lt;? extends E&gt; c) &#123;    elementData &#x3D; c.toArray();    if ((size &#x3D; elementData.length) !&#x3D; 0) &#123;        &#x2F;&#x2F; c.toArray might (incorrectly) not return Object[] (see 6260652)&#x2F;&#x2F;是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型        if (elementData.getClass() !&#x3D; Object[].class)            elementData &#x3D; Arrays.copyOf(elementData, size, Object[].class);    &#125; else &#123;        &#x2F;&#x2F; replace with empty array.&#x2F;&#x2F; 给定集合（c）无值，则默认空数组        this.elementData &#x3D; EMPTY_ELEMENTDATA;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=orange>为什么要创建空数组？</font><br>因为开发中很多时候 创建了ArrayList对象，但是没有装元素，这个时候的话，直接初始化为10，就会浪费空间。</p><h2 id="2-3：ArrayList的add操作-以及-扩容"><a href="#2-3：ArrayList的add操作-以及-扩容" class="headerlink" title="2-3：ArrayList的add操作  以及 扩容"></a>2-3：ArrayList的add操作  以及 扩容</h2><p>新增就是往数组中添加元素，主要分成两步：<br>判断是否需要扩容，如果需要执行扩容操作；<br>直接赋值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean add(E e) &#123;&#x2F;&#x2F;确保数组大小是否足够，不够执行扩容，size 为当前数组的大小    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!    elementData[size++] &#x3D; e;    return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;&#x2F;&#x2F;如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        return Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    return minCapacity;&#125;private void ensureExplicitCapacity(int minCapacity) &#123;&#x2F;&#x2F;记录数组被修改    modCount++;    &#x2F;&#x2F; overflow-conscious code&#x2F;&#x2F; 如果我们期望的最小容量大于目前数组的长度，那么就扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);&#125;&#x2F;&#x2F; 如果我们期望的最小容量大于目前数组的长度，那么就扩容private void grow(int minCapacity) &#123;    &#x2F;&#x2F; overflow-conscious code    int oldCapacity &#x3D; elementData.length;    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);&#x2F;&#x2F; 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值    if (newCapacity - minCapacity &lt; 0)        newCapacity &#x3D; minCapacity;&#x2F;&#x2F; 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity &#x3D; hugeCapacity(minCapacity);    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，每当向数组中添加元素时， 都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容， 以满足添加数据的需求。数组扩容通过一个公开的方法 <code>ensureCapacity(int minCapacity)</code> 来 实现。</p><ol><li><p><code>ArrayList</code>第一次<code>add</code>元素时，扩容为长度为10的数组。<br>  当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时<code>minCapacity</code>等于默认的容量（<strong>10</strong>）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p></li><li><p>   扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原 来容量的 <strong>1.5</strong> 倍；<br>当ArrayList数组超过当前容量时，扩容至1.5倍（遇到计算结果为小数的，向下取整），<br>第一次扩容后，容量为15，第二次扩容至22</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static int hugeCapacity(int minCapacity) &#123;    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ArrayList 中的数组的最大值是 <code>Integer.MAX_VALUE</code>，超过这个值，JVM 就不会给数组分配 内存空间了。这边也可以看到ArrayList允许的最大容量，就是Integer的最大值（-2的31次方~2的31次方减1）。</p></li><li><p>   新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 <code>null</code> 值的。</p></li><li><p>   不是原子操作，，没有任何锁控制，所以这里的操作是线程不安全的，原因主要是<code>elementData[size++] = e</code>可以继续进行拆分</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static int hugeCapacity(int minCapacity) &#123;    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>扩容是通过这行代码来实现的： <code>Arrays.copyOf(elementData, newCapacity); </code>这行代码描述的 本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据 拷贝过去，我们通过 <code>System.arraycopy </code>方法进行拷贝</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @param src 被拷贝的数组 * @param srcPos 从数组那里开始* @param dest 目标数组 * @param destPos 从目标数组那个索引位置开始拷贝 * @param length 拷贝的长度 * 此方法是没有返回值的，通过 dest 的引用进行传值 *&#x2F;public static native void arraycopy(Object src,  int  srcPos,                                    Object dest, int destPos,                                    int length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4：remove"><a href="#2-4：remove" class="headerlink" title="2-4：remove"></a>2-4：remove</h2><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理 和思路都差不多，我们选取根据值删除方式来进行源码说明：</p><p>我们需要注意的两点是：</p><p>新增的时候是没有对 <code>null</code> 进行校验的，所以删除的时候也是允许删除 <code>null</code> 值的； 找到值在数组中的索引位置，是通过 <code>equals</code> 来判断的，如果数组元素不是基本类型，需要我 们关注 <code>equals</code> 的具体实现。</p><p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean remove(Object o) &#123;    if (o &#x3D;&#x3D; null) &#123;        for (int index &#x3D; 0; index &lt; size; index++)            if (elementData[index] &#x3D;&#x3D; null) &#123;                fastRemove(index);                return true;            &#125;    &#125; else &#123;        for (int index &#x3D; 0; index &lt; size; index++)            if (o.equals(elementData[index])) &#123;                fastRemove(index);                return true;            &#125;    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void fastRemove(int index) &#123;    modCount++;    int numMoved &#x3D; size - index - 1;    if (numMoved &gt; 0)&#x2F;&#x2F; numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去&#x2F;&#x2F; 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 num        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);&#x2F;&#x2F; remove方法会让下标到数组末尾的元素向前移动一个单位，并把最后一位的值置空，方便GC    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5：ArrayList线程不安全"><a href="#2-5：ArrayList线程不安全" class="headerlink" title="2-5：ArrayList线程不安全"></a>2-5：ArrayList线程不安全</h2><p>只有当 ArrayList 作为<code>共享变量</code>时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，<strong>所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</strong></p><h2 id="2-6：那如何解决ArrayList线程不安全问题呢？"><a href="#2-6：那如何解决ArrayList线程不安全问题呢？" class="headerlink" title="2-6：那如何解决ArrayList线程不安全问题呢？"></a>2-6：那如何解决ArrayList线程不安全问题呢？</h2><ol><li>用Collections.synchronizedList<ul><li>因为Collections.synchronizedList封装后的list，<br> list的所有操作方法都是带synchronized关键字的，<br> 相当于所有操作都会进行加锁，<br> 所以使用它是线程安全的，但是性能大大降低，</li></ul></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">SynchronizedCollection(Collection&lt;E&gt; c) &#123;    this.c &#x3D; Objects.requireNonNull(c);    mutex &#x3D; this;&#125;public boolean add(E e) &#123;    synchronized (mutex) &#123;return c.add(e);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><code>CopyOnWriteArrayList</code><ul><li>写操作：添加元素时，<pre><code>   不直接往当前容器添加，而是先拷贝一份数组，   在新的数组中添加元素后，   在将原容器的引用指向新的容器。   因为数组时用volatile关键字修饰的，   所以当array重新赋值后，   其他线程可以立即知道（volatile的可见性）</code></pre></li><li>读操作：读取数组时，读老的数组，不需要加锁。</li><li>读写分离：写操作是copy了一份新的数组进行写，<pre><code>     读操作是读老的数组，所以是读写分离。</code></pre>采用了<code>Fail-Fast</code>机制，<br>面对并发的修改时，迭代器很快就会完全失败，<br>而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java基础，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github博客：网站内图片不能正常显示，但本地文件可以显示</title>
      <link href="2020/09/07/hexo%E5%8D%9A%E5%AE%A2/pic/"/>
      <url>2020/09/07/hexo%E5%8D%9A%E5%AE%A2/pic/</url>
      
        <content type="html"><![CDATA[<p>在同级的img下放图片，md引用即可</p><p>参考文章：<br>网上流传的另一份代码 npm install <a href="https://github.com/CodeFalling/hexo-asset-image">https://github.com/CodeFalling/hexo-asset-image</a> –save 并不能使用。</p><p><a href="https://cpper.blog.csdn.net/article/details/104117319?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.not_use_machine_learn_pai">https://cpper.blog.csdn.net/article/details/104117319?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.not_use_machine_learn_pai</a></p><p><img src="a.png"></p><img src="/2020/09/07/hexo%E5%8D%9A%E5%AE%A2/pic/a.png" class="" title="hi"><p><img src="1.png"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-看图了解思想</title>
      <link href="2020/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Sort/"/>
      <url>2020/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/Sort/</url>
      
        <content type="html"><![CDATA[<font color = 'gold' size = 5>今天看了bilibili左神的排序算法的公开课！！！  <p>学到了学到了  </p><p>接着想练习一下   </p><p>做了leedcode912. 排序数组    </p><p>下面来总结一下常见的排序算法把～～～<br></font ><br><font color = 'pink' size = 3>(里面的动态图参考<a href="https://www.cnblogs.com/onepixel/p/7674659.html%E5%A4%A7%E4%BD%AC%E7%9A%84">https://www.cnblogs.com/onepixel/p/7674659.html大佬的</a>)<br></font></p><hr><p>   <font color = 'pink' size = 3> 以下是时间复杂度：o(n2)  空间复杂度：o(1)三兄弟<br>   其中冒泡 插入 稳定的<br>   选择不稳定<br>   具体分析看下面详解<br>   </font></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>进行n-1次排序,依次选择最大的数字浮到数组的后面<br>比较相邻的元素。如果第一个比第二个大，就交换它们两个；对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p><img src=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif alt="bubbleSort" /><p><code>时间：o(n2)   空间o(1) 稳定的</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;                for(int i &#x3D; 0 ; i&lt;nums.length-1;i++)&#123;            for(int j &#x3D; 0 ;j &lt; nums.length-1-i;j++)&#123;                if(nums[j]&gt;nums[j+1])&#123;                    int tmp &#x3D; nums[j];                    nums[j]&#x3D;nums[j+1];                    nums[j+1]&#x3D;tmp;                &#125;            &#125;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次选择最小值放在前面，<br>看图说话</p><p><img src=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gifalt="selectSort" /></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        &#x2F;&#x2F;selctSort        for(int i &#x3D; 0 ; i&lt;nums.length-1;i++)&#123;            int minindex &#x3D; i;            for(int j &#x3D; i+1;j&lt;nums.length;j++)&#123;                if(nums[minindex]&gt;nums[j])&#123;                    minindex &#x3D; j;                &#125;            &#125;            int tmp &#x3D; nums[i];nums[i]&#x3D;nums[minindex];nums[minindex]&#x3D;tmp;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>时间：o(n2)   空间o(1) 不稳定的</code><br><strong>注意注意</strong><br>比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等 的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列<strong>5 8 5 2 9</strong>，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序<strong>不是一个稳定的排序算法</strong>。<br>执行结果：<br>[5, 8, 5, 2, 9]<br>[2, 8, 5, 5, 9]<br>[2, 5, 8, 5, 9]<br>[2, 5, 5, 8, 9]</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>从第一个元素开始，该元素可以认为已经被排序；<br>取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；</p><p><img src=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gifalt="insertSort" /></p><p><code>时间：o(n2)   空间o(1)  稳定的</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        &#x2F;&#x2F;&#x2F;selectsort        for(int i &#x3D; 1; i &lt; nums.length;i++)&#123;            int current &#x3D; nums[i];            int preIndex &#x3D; i-1;            &#x2F;&#x2F;找位置插入               while(preIndex&gt;&#x3D;0&amp;&amp;nums[preIndex]&gt;current)&#123;                nums[preIndex+1]&#x3D;nums[preIndex];                preIndex--;            &#125;            nums[preIndex+1]&#x3D;current;        &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把长度为n的输入序列分成两个长度为n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。</p><p><img src=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gifalt="mergeSort" /><br><code>时间复杂度O(N*logN)，额外空间复杂度O(N) 稳定</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        &#x2F;&#x2F;归并排序        if(nums&#x3D;&#x3D;null||nums.length&lt;2) return nums;        mergeSort(nums,0,nums.length-1);        return nums;    &#125;    public void mergeSort(int[] nums,int l,int r)&#123;        if(l&#x3D;&#x3D;r) return;        int mid &#x3D; l + ((r-l)&gt;&gt;1);        mergeSort(nums,l,mid);        mergeSort(nums,mid+1,r);        merge(nums,l,mid,r);    &#125;    public void merge(int[] nums,int l, int mid, int r)&#123;        int[] help &#x3D; new int[r-l+1];        int p1 &#x3D; l;        int p2 &#x3D; mid+1;        int i &#x3D; 0;        while(p1&lt;&#x3D;mid&amp;&amp;p2&lt;&#x3D;r)&#123;            help[i++] &#x3D; (nums[p1]&lt;nums[p2])?nums[p1++]:nums[p2++];        &#125;        while(p1&lt;&#x3D;mid)&#123;            help[i++]&#x3D;nums[p1++];        &#125;        while(p2&lt;&#x3D;r)&#123;            help[i++]&#x3D;nums[p2++];        &#125;        for(int j &#x3D; 0 ; j &lt; help.length;j++)&#123;            nums[j+l] &#x3D; help[j];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><p>从数列中挑出一个元素，称为 “基准”（pivot）；<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br><code>时间复杂度O(N*logN)，额外空间复杂度O(logN) 不稳定</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[] sortArray(int[] nums) &#123;        if(nums&#x3D;&#x3D;null||nums.length&lt;2) return nums;        &#x2F;&#x2F;quickSort        quickSort(nums,0,nums.length-1);        return nums;    &#125;    public void quickSort(int[] nums, int l , int r)&#123;        if(l&gt;&#x3D;r) return ;        &#x2F;&#x2F; pivot: 标杆位置，cur: 小于pivot的元素的个数        int pivot &#x3D; partition(nums,l,r);        quickSort(nums,l,pivot-1);        quickSort(nums,pivot+1,r);    &#125;    public int  partition(int[] nums, int l,int r)&#123;        int pivot &#x3D; r;        int cur &#x3D; l;        for(int i &#x3D; l ; i &lt; r;i++)&#123;            if(nums[i]&lt;nums[pivot])&#123;                int tmp &#x3D; nums[i];nums[i]&#x3D;nums[cur];nums[cur]&#x3D;tmp;                cur++;            &#125;        &#125;        int tmp &#x3D; nums[cur];nums[cur]&#x3D;nums[pivot];nums[pivot]&#x3D;tmp;        return cur;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序引出的逆序对和小数和问题</title>
      <link href="2020/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2020/08/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BC%95%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<font color = 'pink' size = 5>！！！  看了归并排序那接着来看看几道题把  趁热打铁</font >---<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p><code>剑指 Offer 51. 数组中的逆序对</code><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>示例 1:<br>输入: [7,5,6,4]<br>输出: 5</p><hr><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    int sum &#x3D; 0;    public int reversePairs(int[] nums) &#123;        if(nums&#x3D;&#x3D;null||nums.length&lt;2) return 0;        mergeSort(nums,0,nums.length-1);        return sum;    &#125;    public int mergeSort(int[] nums,int l,int r)&#123;        if(l&#x3D;&#x3D;r) return 0;        int mid &#x3D; l + ((r-l)&gt;&gt;2);        return mergeSort(nums,l,mid)+mergeSort(nums,mid+1,r)+merge(nums,l,mid,r);    &#125;    public int merge(int[] nums,int l ,int mid,int r)&#123;        int i &#x3D; 0;        int[] help &#x3D; new int[r-l+1];        int p1&#x3D;l;        int p2&#x3D;mid+1;        while(p1&lt;&#x3D;mid&amp;&amp;p2&lt;&#x3D;r)&#123;            sum +&#x3D; nums[p1]&gt;nums[p2]?(mid-p1+1):0;            help[i++]&#x3D;nums[p1]&gt;nums[p2]?nums[p2++]:nums[p1++];        &#125;        while(p1&lt;&#x3D;mid)&#123;            help[i++]&#x3D;nums[p1++];        &#125;        while(p2&lt;&#x3D;r)&#123;            help[i++]&#x3D;nums[p2++];        &#125;        for(i &#x3D; 0;i&lt;help.length;i++)&#123;            nums[l+i]&#x3D;help[i];        &#125;        return sum;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><p><code>小和问题</code></p><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。</p><p>例子： [1,3,4,2,5] 1左边比1小的数，没有；<br> 3左边比3小的数，1；<br> 4左边比4小的数，1、3；<br>2左边比2小的数，1；<br>5左边比5小的数，1、3、4、2；<br>   所以小和为1+1+3+1+1+3+4+2=16</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int smallSum(int[] arr) &#123;if (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;return 0;&#125;return mergeSort(arr, 0, arr.length - 1);&#125;public static int mergeSort(int[] arr, int l, int r) &#123;if (l &#x3D;&#x3D; r) &#123;return 0;&#125;int mid &#x3D; l + ((r - l) &gt;&gt; 1);return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r);&#125;public static int merge(int[] arr, int l, int m, int r) &#123;int[] help &#x3D; new int[r - l + 1];int i &#x3D; 0;int p1 &#x3D; l;int p2 &#x3D; m + 1;int res &#x3D; 0;while (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;res +&#x3D; arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0;help[i++] &#x3D; arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#125;while (p1 &lt;&#x3D; m) &#123;help[i++] &#x3D; arr[p1++];&#125;while (p2 &lt;&#x3D; r) &#123;help[i++] &#x3D; arr[p2++];&#125;for (i &#x3D; 0; i &lt; help.length; i++) &#123;arr[l + i] &#x3D; help[i];&#125;return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程是什么-与线程的初相识</title>
      <link href="2019/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>2019/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="什么叫做线程"><a href="#什么叫做线程" class="headerlink" title="什么叫做线程"></a>什么叫做线程</h2><p><img src="/img/b.png"></p><p><code>程序(program)</code>：是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。</p><p><code>进程(process)</code>是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。——生命周期<br>如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的<br>进程作为<code>资源分配的单位</code>，系统在运行时会为每个进程分配不同的内存区域，每个进程会有独立的方法区和堆空间</p><p><code>线程(thread)</code>，进程可进一步细化为线程，<strong>是一个程序内部的一条执行路径。</strong></p><p>若<strong>一个进程同一时间并行执行多个线程</strong>，就是支持<strong>多线程</strong>的<br>线程作为<code>调度和执行的单位</code>，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小<br>一个进程中的多个线程<code>共享相同的内存单元/内存地址空间</code> ，它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得<code>线程间通信更简便、高效</code>。<br>但多个线程操作共享的系统资源可能就会带来<code>安全</code>的隐患。</p><p><code>并行与并发</code></p><ol><li>并发： 同⼀时间段，多个任务都在执⾏；</li><li>并⾏： 单位时间内，多个任务同时执⾏。</li></ol><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</p><p>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，<strong>此时它已 具备了运行的条件</strong>，只是没分配到CPU资源</p><p>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能</p><p>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</p><p>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</p><p> -&gt; 创建状态：一个新进程被创建时的第一个状态；<br>创建状态 -&gt; 就绪状态：当进程被创建完成并初始化后，<br>                     一切就绪准备运行时，<br>                     变为就绪状态，这个过程是很快的；<br>就绪态 -&gt; 运行状态：处于就绪状态的进程被操作系统的进程调度器选中后，<br>                    就分配给 CPU 正式运行该进程；<br>运行状态 -&gt; 结束状态：当进程已经运行完成或出错时，<br>                      会被操作系统作结束状态处理；<br>运行状态 -&gt; 就绪状态：处于运行状态的进程在运行过程中，<br>                      由于分配给它的运行时间片用完，<br>                      <strong>yield( )或失去cpu资源</strong><br>                      操作系统会把该进程变为就绪态，<br>                      接着从就绪态选中另外一个进程运行；<br>运行状态 -&gt; 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I/O 事件；<br>                    sleep(long time) join  wait 等待同步锁</p><p>阻塞状态 -&gt; 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；<br>                    sleep时间到  join结束  notify/notifyAll 获取到了同步锁</p><h2 id="wait和sleep的异同"><a href="#wait和sleep的异同" class="headerlink" title="wait和sleep的异同"></a>wait和sleep的异同</h2><p>相同点：<br>一旦执行方法都可以使当前线程进入阻塞状态</p><p>不同点：</p><ol><li><p><code>来自不同的类</code>，Thread类中声明了sleep,object类中声明wait</p></li><li><p><code>调用的要求不同</code>：sleep可以在任意需要的场景下调用，wait必须在同步代码块或者同步方法中调用</p></li><li><p><code>关于是否释放同步监视器的问题</code>：如果两个方法都在同步代码块当中，sleep不会释放锁，wait会释放锁</p></li><li><p>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。<br>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发安全包</title>
      <link href="2019/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>2019/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>主要有俩个方法</p><p>昂一个线程或者多个线程调用<code>await</code>方法的时候，这些线程会被阻塞，</p><p>调用<code>countDown</code>方法会将计数器减1，调用countDown方法的线程不会被阻塞</p><p>当计数器的值变为0的时候，因为<code>await</code>阻塞的线程就会被唤醒，继续执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws InterruptedException &#123;        CountDownLatch countDownLatch &#x3D; new CountDownLatch(3);        for (int i &#x3D; 0 ; i &lt; 3;i++)&#123;            new Thread(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;);                countDownLatch.countDown();            &#125;,String.valueOf(i)).start();        &#125;    countDownLatch.await();        System.out.println(&quot;main完成&quot;);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3,()-&gt;&#123;            System.out.println(&quot;等到3个线程完成之后才会打印&quot;);        &#125;);        for (int i &#x3D; 0 ; i &lt; 3;i++)&#123;            final int tmp &#x3D; i ;            new Thread(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+tmp);                try &#123;                    cyclicBarrier.await();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125; catch (BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;            &#125;,String.valueOf(i)).start();        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>acquire</code>:当一个线程调用acquire操作的时候，要么通过成功获取信号量（<code>信号量减1</code>），<strong>要么一直等待下去，知道有线程释放信号量或者超时</strong><br><code>release</code>：实际上会将<code>信号量加1</code>，然后等待<code>唤醒等待的线程</code></p><p><code>信号量主要目的</code><br>一个是用于<code>共享资源的互斥使用</code>，<br>一个是用于<code>并发线程数的控制</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Semaphore semaphore &#x3D; new Semaphore(3);        for(int i &#x3D; 0;i&lt;6;i++)&#123;            new Thread(()-&gt;&#123;                try &#123;                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName()+&quot;抢到了&quot;);                    try &#123;TimeUnit.SECONDS.sleep(1);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;                    System.out.println(Thread.currentThread().getName()+&quot;离开了&quot;);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    semaphore.release();                &#125;            &#125;,String.valueOf(i)).start();        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>为了保证并发量，<br>希望读读共存<br>读写不能共存<br>写读不能共存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">static class MyCache &#123;        private volatile Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();        private ReadWriteLock readWriteLock &#x3D; new ReentrantReadWriteLock();        public void put(String key, Object value)  &#123;            readWriteLock.writeLock().lock();  &#x2F;&#x2F;上写锁            try &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t-----写入数据key&quot;);&#x2F;&#x2F;            Thread.sleep(3000);                map.put(key, value);                System.out.println(Thread.currentThread().getName() + &quot;\t-----写入数据成功&quot;);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125; finally &#123;                readWriteLock.writeLock().unlock();            &#125;        &#125;        public void get(String key)  &#123;            readWriteLock.readLock().lock();  &#x2F;&#x2F;上读锁            try &#123;                System.out.println(Thread.currentThread().getName() + &quot;\t读取数据key&quot;);&#x2F;&#x2F;            Thread.sleep(3000);                Object result &#x3D; map.get(key);                System.out.println(Thread.currentThread().getName() + &quot;\t读取数据成功&quot; + result);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125; finally &#123;                readWriteLock.readLock().unlock();            &#125;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        MyCache myCache &#x3D; new MyCache();        for (int i &#x3D; 0; i &lt; 5; i++) &#123;            final int tmp &#x3D; i ;            new Thread(()-&gt;&#123;                myCache.put(tmp+&quot;&quot;,tmp+&quot;&quot;);            &#125;,String.valueOf(i)).start();        &#125;        for (int i &#x3D; 0; i &lt; 5; i++) &#123;            final int tmp &#x3D; i ;            new Thread(()-&gt;&#123;                myCache.get(tmp+&quot;&quot;);            &#125;,String.valueOf(i)).start();        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类如何让加载，常见的类加载器，如何自定义类加载器</title>
      <link href="2019/09/07/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD/load/"/>
      <url>2019/09/07/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD/load/</url>
      
        <content type="html"><![CDATA[<p><code>类加载运行全过程</code></p><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到 JVM。</p><p>通过Java命令执行代码的大体流程如下：<br>其中loadClass的类加载过程有如下几步： 加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 </p><p><code>加载：</code></p><p>通过全类名获取定义此类的二进制字节流<br>将字节流所代表的静态存储结构转换为方法区的运行时数据结构<br>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</p><p><code>验证：</code>校验字节码文件的正确性</p><p><code>准备：</code>给类的<code>静态变量</code>分配内存，并赋予默认值<br>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。<br>    <code>特殊情况</code>：比如给 value 变量加上了 fianl 关键字public static final int value=1 ，那么准备阶段 value 的值就被复制为 1。<br><code>解析：</code>将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如 main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过 程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用，下 节课会讲到动态链接</p><p>初始化：对类的<code>静态变量初始化为指定的值</code>，<code>执行静态代码块</code><br>也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <clinit> ()方法的过程。<br>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化：<br>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<br>使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。<br>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。<br>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。<br>当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。</p><p><strong>注意</strong>，<br>主类在运行过程中如果使用到其它类，会逐步加载这些类。<br>jar包或war包里的类不是一次性全部加载的，是 <strong>使用到时才加载</strong>。</p><p><code>类加载器和双亲委派机制</code></p><p>上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器</p><p><code>引导类加载器</code>：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等<br><code>扩展类加载器</code>：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包<br>应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那 些类 自定义加载器：负责加载用户自定义路径下的类包</p><p><code>类加载器初始化过程</code>：</p><p>参见类运行加载全过程图可知其中会创建JVM启动器实例sun.misc.Launcher。 sun.misc.Launcher初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个 sun.misc.Launcher实例。 在Launcher构造方法内部，其创建了两个类加载器，分别是 sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应 用类加载器)。 JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们 的应用程序。</p><p><code>双亲委派机制</code><br>双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载</p><p>我们来看下应用程序类加载器AppClassLoader加载类的双亲委派机制源码，AppClassLoader 的loadClass方法最终会调用其父类ClassLoader的loadClass方法，该方法的大体逻辑如下：</p><ol><li><p>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接 返回。</p></li><li><p>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加 载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加 载。</p></li><li><p>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 findClass方法来完成类加载。</p></li></ol><p><code>为什么要设计双亲委派机制？</code></p><p>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心 API库被随意篡改</p><p>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一 次，保证被加载类的唯一性</p><p><code>自定义类加载器示例</code>：</p><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是 loadClass(String, boolean)，实现了双亲委派机制，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是重写</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类的加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志设置</title>
      <link href="2019/09/07/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E6%97%A5%E5%BF%97/"/>
      <url>2019/09/07/%E5%A4%A9%E5%A4%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-boot使用logback实现日志配置"><a href="#Spring-boot使用logback实现日志配置" class="headerlink" title="Spring boot使用logback实现日志配置"></a>Spring boot使用logback实现日志配置</h2><p>在pom.xml中添加依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- lombok --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建日志文件：LoggerTest-java"><a href="#创建日志文件：LoggerTest-java" class="headerlink" title="创建日志文件：LoggerTest.java"></a>创建日志文件：LoggerTest.java</h3><p>在里面有两种写法<br><code>第一种方法</code>：在日志类里面都必须添加上：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private final Logger logger &#x3D; LoggerFactory.getLogger(LoggerTest.class);@RunWith(SpringRunner.class)@SpringBootTestpublic class LoggerTest &#123;private final Logger logger &#x3D; LoggerFactory.getLogger(LoggerTest.class);@Testpublic void test()&#123;logger.debug(&quot;debug&quot;);logger.info(&quot;info&quot;);logger.error(&quot;error&quot;);&#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：这种方法每次用日志的时候都得写当前类</p><p><code>第二种方法</code>：加上<code>@Slf4j</code>这个注解</p><p>如果在info/warn/….中加上内容，有两种方法<br>第一种方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RunWith(SpringRunner.class)@SpringBootTest@Slf4jpublic class LoggerTest &#123;@Testpublic void test()&#123;String name &#x3D; &quot;jack&quot;;String password &#x3D; &quot;123456&quot;;log.info(&quot;name: &quot;+ name+&quot;, &quot;+&quot;password: &quot;+password);        log.debug(&quot;debug&quot;);        log.error(&quot;error &quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果是需要输出多个name和password，会比较麻烦</p><p>第二种方法：<code>log.info(&quot;name: &#123;&#125;,password:&#123;&#125;&quot;,name,password);</code></p><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><ol><li>需要满足的需求是区分info和error日志，</li><li>每天产生一个日志文件，采用两种方式配置，<br>一种是通过application.yml，另一种是通过logback-spring.xml配置。</li><li>1 application.yml<pre class="line-numbers language-none"><code class="language-none">logging:  pattern:    console: &quot;%d - %msg%n&quot;  file:    path: D:\0log  level: debug  #指定日志级别<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在进行第二种配置方式之前，先把application.yml中的配置注释掉</li><li>2  logback-spring.xml配置<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 配置控制台日志输出 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>consolelog<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.PatternLayout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d -%msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--  配置文件日志输出--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileInfoLog<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>ERROR<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">></span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">></span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 滚动策略 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 路径 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>自己的路径/info.%d.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileErrorLog<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.ThresholdFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>ERROR<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- 滚动策略 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- 路径 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>自己的路径/error.%d.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>consolelog<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileInfoLog<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileErrorLog<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>剩余的参考下<a href="https://www.bilibili.com/read/cv4547836/">https://www.bilibili.com/read/cv4547836/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 点餐项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点餐项目 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
