<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入Java集合---List集合比较</title>
      <link href="2020/11/17/List%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83/"/>
      <url>2020/11/17/List%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="源码扩容过程有什么值得借鉴的地方？"><a href="#源码扩容过程有什么值得借鉴的地方？" class="headerlink" title="源码扩容过程有什么值得借鉴的地方？"></a>源码扩容过程有什么值得借鉴的地方？</h2><p>答：有两点：</p><ol><li>是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封 装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时， 也可快速扩容。</li><li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li></ol><p>这两点在我们平时设计和写代码时都可以借鉴。</p><h2 id="ArrayList-和-LinkedList-两者有没有最大容量"><a href="#ArrayList-和-LinkedList-两者有没有最大容量" class="headerlink" title="ArrayList 和 LinkedList 两者有没有最大容量"></a>ArrayList 和 LinkedList 两者有没有最大容量</h2><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存 空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用 的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p><h2 id="vector、Arraylist区别和适用场景"><a href="#vector、Arraylist区别和适用场景" class="headerlink" title="vector、Arraylist区别和适用场景"></a>vector、Arraylist区别和适用场景</h2><p>1.<code>线程</code>：Vector是多线程安全的， Vector类中的方法很多有synchronized进行修饰，<br>         只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>         ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。<br>         这样就导致了Vector在效率上无法与ArrayList相比</p><ol start="2"><li><p><code>底层</code>：两个都是数组实现，支持快速随机访问，其 API 都做了一层对数组底层访问的封装</p></li><li><p><code>初始化</code>：Vector无参构造器初始化时就生成了容量为10的空数组，ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。</p><pre><code>  Vector可以设置增长因子CapacityIncrement，而ArrayList不可以</code></pre></li><li><p><code>扩容机制</code>：<br>Vector在每次add增加元素(可能是1个，也可能是一组)时，都要调用ensureCapacityHelper方法来确保足够的容量，当容量不足以容纳当前的元素个数时，即minCapacity（指的是当前元素数目elementCount + 1） - elementData.length &gt; 0，就会grow(minCapacity)扩容，就看构造方法中传入的容量增长系数CapacityIncrement是否为0，</p><pre><code>  如果不为0，就设置新的容量为 旧容量 + 容量增长量；  如果为0，设置新的容量为旧的容量的2倍，  如果设置后的容量还不够，则直接新的容量设置为  传入参数所需要的容量 </code></pre><p>ArrayList在每次add增加元素(可能是1个，也可能是一组)时，都要调用nsureCapacityInternal方法来确保足够的容量,如果我们期望的最小容量大于目前数组的长度，那么就扩容.</p><ol><li>ArrayList第一次add元素时，扩容为长度为10的数组。<br>当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时minCapacity等于默认的容量（10）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</li></ol></li></ol><h2 id="ArrayList、LinkedList区别和适用场景"><a href="#ArrayList、LinkedList区别和适用场景" class="headerlink" title="ArrayList、LinkedList区别和适用场景"></a>ArrayList、LinkedList区别和适用场景</h2><ol><li><code>是否保证线程安全</code>： ArrayList在单线程下是线程安全的，<pre><code>             多线程下由于多个线程不断抢夺资源，             所以会出现不安全             和 LinkedList 都是不同步的，也就是不保证线程安全；</code></pre></li><li><code>底层数据结构</code>： Arraylist 底层使用的是 Object 数组；<pre><code>             LinkedList 底层使用的是 双向链表 数据结构</code></pre></li><li><code>插入和删除是否受元素位置的影响</code>：<br>① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。<br>② LinkedList 采用链表存储，插入删除元素时间复杂度不受元素位置的影响，<pre><code>         如果是要在指定位置i插入和删除元素的话需要先移动到指定位置再插入。</code></pre></li><li><code>是否支持快速随机访问</code>： LinkedList 不支持高效的随机元素访问，<br>LinkedList 并没有采用从头循环到尾的做法， 而是采取了简单二分 法， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值 得我们借鉴。<br>而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。</li><li><code>内存空间占用</code>： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间；<br>双向链表节点对应的类Node的实例，<br>Node中包含成员变量：prev，next，item。<br>prev是该节点的上一个节点，<br>next是该节点的下一个节点，<br>item是该节点所包含的值。（因为要存放直接后继和直接前驱以及数据）<br>当需要对数据进行对此访问的情况下选用ArrayList，<br>当需要对数据进行多次增加删除修改时采用LinkedList。<br>ArrayList与LinkedList集合各有所长，可以在不同场合根据具体需求选用:<br>–    ArrayList元素的检索速度高于LinkedList<br>–    LinkedList因为内存的不连续性，更适合于大批量数据的存放和管理<br>–    如果在非末端插入数据，LinkedList速度优于ArrayList</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Java集合---LinkedList源码笔记</title>
      <link href="2020/11/17/LinkedList/"/>
      <url>2020/11/17/LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><font color=orange>LinkedList</font></h1><!-- ![avatar](http://i1.fuimg.com/729820/166f5e5b5f18282c.png)   --><img src='http://i1.fuimg.com/729820/166f5e5b5f18282c.png' width="30%"  ><font color=orange>可爱的小姐姐头像镇楼～～～～～～继续总结。开始LinkedList咯～～～～还是来个可爱的分隔符～</font><p><code>-------------------------------------------------------</code></p><h2 id="3-1：linkedlist数据结构"><a href="#3-1：linkedlist数据结构" class="headerlink" title="3-1：linkedlist数据结构"></a>3-1：linkedlist数据结构</h2><p><code>LinkedList</code>是List接口的<strong>双向链表</strong>非同步实现，<br>并允许包括<code>null</code>在内的所有元素。<br>双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如 下：</p><p>双向链表节点对应的<code>类Node</code>的实例，<br>Node中包含成员变量：<code>prev，next，item。</code><br><code>prev</code>是该节点的上一个节点，<br><code>next</code>是该节点的下一个节点，<br><code>item</code>是该节点所包含的值。<br><code>first</code> 是双向链表的头节点，它的前一个节点是 null。<br><code>last</code> 是双向链表的尾节点，它的后一个节点是 null；<br>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；<br>因为是个<code>双向链表</code>，只要机器内存足够强大，是没有大小限制的。</p><h2 id="3-2：linkedlist-根据索引返回对应的Node值"><a href="#3-2：linkedlist-根据索引返回对应的Node值" class="headerlink" title="3-2：linkedlist   根据索引返回对应的Node值"></a>3-2：linkedlist   根据索引返回对应的Node值</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns the (non-null) Node at the specified element index. */</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// assert isElementIndex(index);</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果 index 处于队列的前半部分，从头开始找，size >> 1 是 size 除以 2 的意思。</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 直到 for 循环到 index 的前一个 node 停止</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果 index 处于队列的后半部分，从尾开始找</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 直到 for 循环到 index 的后一个 node 停止</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>从源码中我们可以发现， LinkedList 并没有采用从头循环到尾的做法， 而是采取了<font color=orange>简单二分法</font>， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，<code>这种思想值 得我们借鉴。</code></p><h2 id="3-3：linkedlist增加节点"><a href="#3-3：linkedlist增加节点" class="headerlink" title="3-3：linkedlist增加节点"></a>3-3：linkedlist增加节点</h2><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把 节点的值，前后指向节点都置为 null，帮助 GC 进行回收。<br>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开 始追加，addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 把尾节点数据暂存</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 新建新的节点，初始化入参含义： </span><span class="token comment" spellcheck="true">// l 是新节点的前一个节点，当前值是尾节点值</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//否则把前尾节点的下一个节点，指向当前尾节点。</span>    <span class="token keyword">else</span>        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//大小和版本更改</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>从头部追加（addFirst）</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Links e as first element. */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>    first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">else</span>        f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="3-4：linkedlist删除节点"><a href="#3-4：linkedlist删除节点" class="headerlink" title="3-4：linkedlist删除节点"></a>3-4：linkedlist删除节点</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> E <span class="token function">unlinkLast</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// assert l == last &amp;&amp; l != null;</span>    <span class="token keyword">final</span> E element <span class="token operator">=</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev <span class="token operator">=</span> l<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    l<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>    l<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>    last <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> null<span class="token punctuation">)</span>        first <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">else</span>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> element<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> E <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// assert f == first &amp;&amp; f != null;</span>    <span class="token keyword">final</span> E element <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    f<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>    f<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>    first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>        last <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">else</span>        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> element<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Java集合---Vector源码笔记</title>
      <link href="2020/11/17/Vector/"/>
      <url>2020/11/17/Vector/</url>
      
        <content type="html"><![CDATA[<p><code>VECTOR</code></p><p><code>休息了一会会，接着再来看看Vector的源码吧，加油～～</code><br><img src='http://i1.fuimg.com/729820/166f5e5b5f18282c.png' width="25%" ><br><code>-----------------------------------------------------------------------------</code></p><h2 id="1-1：vector数据结构"><a href="#1-1：vector数据结构" class="headerlink" title="1-1：vector数据结构"></a>1-1：vector数据结构</h2><p>底层数据结构为<code>数组</code>，支持快速随机访问</p><h2 id="1-2：vector构造器"><a href="#1-2：vector构造器" class="headerlink" title="1-2：vector构造器"></a>1-2：vector构造器</h2><p><code>Vector</code>有四个不同的构造函数。 无参构造的容量默认值为10，容量增长系数<code>CapacityIncrement</code>为0</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">int</span> capacityIncrement<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>capacityIncrement <span class="token operator">=</span> capacityIncrement<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="1-3：vector-indexOf-object-o"><a href="#1-3：vector-indexOf-object-o" class="headerlink" title="1-3：vector  indexOf(object o)"></a>1-3：vector  indexOf(object o)</h2><p>Vector在查找给定元素索引值方法中，<code>indexOf(object o )</code>–&gt;<br>Vector中允许元素为<code>null</code><br>源码都将该元素的值分为null和不为null两种情况处理，</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elementCount <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> elementCount <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="1-4：扩容机制"><a href="#1-4：扩容机制" class="headerlink" title="1-4：扩容机制"></a>1-4：扩容机制</h2><p>与<code>ArrayList</code>不同的是，<br><code>Vector</code>在每次<code>add</code>增加元素(可能是1个，也可能是一组)时，</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityHelper</span><span class="token punctuation">(</span>elementCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>elementCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>都要调用<code>ensureCapacityHelper</code>方法来确保足够的容量。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityHelper</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>当容量不足以容纳当前的元素个数时，即<code>minCapacity</code>（指的是当前元素数目<code>elementCount + 1） - elementData.length &gt; 0</code>，就会<code>grow(minCapacity)</code>扩容</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>capacityIncrement <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span>                                     capacityIncrement <span class="token operator">:</span> oldCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>就看构造方法中传入的容量增长系数<code>CapacityIncrement</code>是否为0，<br>**如果不为0，就设置新的容量为 旧容量 + 容量增长量；<br>如果为0，设置新的容量为旧的容量的2倍，<br>如果设置后的容量还不够，则直接新的容量设置为传入参数所需要的容量 **<br>而后同样用<code>Arrays.copyof()</code>方法将元素拷贝到新的数组。</p><h2 id="1-5：Vector是保证线程安全的"><a href="#1-5：Vector是保证线程安全的" class="headerlink" title="1-5：Vector是保证线程安全的"></a>1-5：Vector是保证线程安全的</h2><p>由于vector中Add方法加了<code>synchronized</code>，来保证add操作是线程安全的</p>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入学习-----ArrayList</title>
      <link href="2020/11/17/ArrayList/"/>
      <url>2020/11/17/ArrayList/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 深入Java集合—ArrayList源码笔记<br>date: 2020-11-17 14:20:32<br>tags: java，集合，源码</p><hr><h1 id="ARRAYLIST"><a href="#ARRAYLIST" class="headerlink" title="ARRAYLIST"></a><font color=orange>ARRAYLIST</font></h1><!-- ![avatar](http://i1.fuimg.com/729820/166f5e5b5f18282c.png)   --><img src='http://i1.fuimg.com/729820/166f5e5b5f18282c.png' width="30%" ><p><code>可爱的小姐姐头像镇楼～～～～～～ 今天打算把看过的源码总结一下。从集合框架开始咯～～～～ 来个可爱的分隔符～！ 话不多说正式开始总结啦！！！！</code><br><code>-------------------------------------------------------</code></p><h2 id="数组-Array-和列表-ArrayList-有什么区别？"><a href="#数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？"></a>数组(Array)和列表(ArrayList)有什么区别？</h2><ol><li>定义上： Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。 </li><li>容量上： Array 大小固定， ArrayList 的大小是动态变化的。 </li><li>操作上： ArrayList 提供更多的方法和特性， </li></ol><p>使用基本数据类型或者知道数据元素数量的时候<br>可以考虑Array;<br>ArrayList处理固定数量<br>的基本类型数据类型时<br>会自动装箱来减少编码工作量，<br>但是相对较慢。</p><h2 id="2-1：ArrayList数据结构"><a href="#2-1：ArrayList数据结构" class="headerlink" title="2-1：ArrayList数据结构"></a>2-1：ArrayList数据结构</h2><p>private transient Object[] elementData;<br>底层使用<code>数组</code>实现, 其 API 都做了一层对数组底层访问的封装</p><p>并允许包括null在内的所有元素。</p><h2 id="2-2-：构造器"><a href="#2-2-：构造器" class="headerlink" title="2-2 ：构造器"></a>2-2 ：构造器</h2><p>有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如 下：<br><code>无参数直接初始化:</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。<br><code>指定初始数据初始化</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><span class="token comment" spellcheck="true">//是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>            elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// replace with empty array.</span><span class="token comment" spellcheck="true">// 给定集合（c）无值，则默认空数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><font color=orange>为什么要创建空数组？</font><br>因为开发中很多时候 创建了ArrayList对象，但是没有装元素，这个时候的话，直接初始化为10，就会浪费空间。</p><h2 id="2-3：ArrayList的add操作-以及-扩容"><a href="#2-3：ArrayList的add操作-以及-扩容" class="headerlink" title="2-3：ArrayList的add操作  以及 扩容"></a>2-3：ArrayList的add操作  以及 扩容</h2><p>新增就是往数组中添加元素，主要分成两步：<br>判断是否需要扩容，如果需要执行扩容操作；<br>直接赋值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录数组被修改</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span><span class="token comment" spellcheck="true">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果扩容后的值 > jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>我们看到，每当向数组中添加元素时， 都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容， 以满足添加数据的需求。数组扩容通过一个公开的方法 <code>ensureCapacity(int minCapacity)</code> 来 实现。</p><ol><li><p><code>ArrayList</code>第一次<code>add</code>元素时，扩容为长度为10的数组。<br>  当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时<code>minCapacity</code>等于默认的容量（<strong>10</strong>）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p></li><li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原 来容量的 <strong>1.5</strong> 倍；<br>当ArrayList数组超过当前容量时，扩容至1.5倍（遇到计算结果为小数的，向下取整），<br>第一次扩容后，容量为15，第二次扩容至22</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>     Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>     MAX_ARRAY_SIZE<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>ArrayList 中的数组的最大值是 <code>Integer.MAX_VALUE</code>，超过这个值，JVM 就不会给数组分配 内存空间了。这边也可以看到ArrayList允许的最大容量，就是Integer的最大值（-2的31次方~2的31次方减1）。</p></li><li><p>   新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 <code>null</code> 值的。</p></li><li><p>不是原子操作，，没有任何锁控制，所以这里的操作是线程不安全的，原因主要是<code>elementData[size++] = e</code>可以继续进行拆分</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>     Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>     MAX_ARRAY_SIZE<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><p>扩容是通过这行代码来实现的： <code>Arrays.copyOf(elementData, newCapacity); </code>这行代码描述的 本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据 拷贝过去，我们通过 <code>System.arraycopy </code>方法进行拷贝</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @param src 被拷贝的数组 * @param srcPos 从数组那里开始* @param dest 目标数组 * @param destPos 从目标数组那个索引位置开始拷贝 * @param length 拷贝的长度 * 此方法是没有返回值的，通过 dest 的引用进行传值 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span>Object src<span class="token punctuation">,</span>  <span class="token keyword">int</span>  srcPos<span class="token punctuation">,</span>                                    Object dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>                                    <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="2-4：remove"><a href="#2-4：remove" class="headerlink" title="2-4：remove"></a>2-4：remove</h2><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理 和思路都差不多，我们选取根据值删除方式来进行源码说明：</p><p>我们需要注意的两点是：</p><p>新增的时候是没有对 <code>null</code> 进行校验的，所以删除的时候也是允许删除 <code>null</code> 值的； 找到值在数组中的索引位置，是通过 <code>equals</code> 来判断的，如果数组元素不是基本类型，需要我 们关注 <code>equals</code> 的具体实现。</p><p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去</span><span class="token comment" spellcheck="true">// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 num</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// remove方法会让下标到数组末尾的元素向前移动一个单位，</span>并把最后一位的值置空，方便GC    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="2-5：ArrayList线程不安全"><a href="#2-5：ArrayList线程不安全" class="headerlink" title="2-5：ArrayList线程不安全"></a>2-5：ArrayList线程不安全</h2><p>只有当 ArrayList 作为<code>共享变量</code>时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，<strong>所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</strong></p><h2 id="2-6：那如何解决ArrayList线程不安全问题呢？"><a href="#2-6：那如何解决ArrayList线程不安全问题呢？" class="headerlink" title="2-6：那如何解决ArrayList线程不安全问题呢？"></a>2-6：那如何解决ArrayList线程不安全问题呢？</h2><ol><li>用Collections.synchronizedList<ul><li>因为Collections.synchronizedList封装后的list，<br> list的所有操作方法都是带synchronized关键字的，<br> 相当于所有操作都会进行加锁，<br> 所以使用它是线程安全的，但是性能大大降低，</li></ul></li></ol><pre class=" language-java"><code class="language-java"><span class="token function">SynchronizedCollection</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>E<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ol start="2"><li><code>CopyOnWriteArrayList</code><ul><li>写操作：添加元素时，<pre><code>   不直接往当前容器添加，而是先拷贝一份数组，   在新的数组中添加元素后，   在将原容器的引用指向新的容器。   因为数组时用volatile关键字修饰的，   所以当array重新赋值后，   其他线程可以立即知道（volatile的可见性）</code></pre></li><li>读操作：读取数组时，读老的数组，不需要加锁。</li><li>读写分离：写操作是copy了一份新的数组进行写，<pre><code>     读操作是读老的数组，所以是读写分离。</code></pre>采用了<code>Fail-Fast</code>机制，<br>面对并发的修改时，迭代器很快就会完全失败，<br>而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java基础，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="2020/11/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/11/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="你好～"><a href="#你好～" class="headerlink" title="你好～"></a>你好～</h2><p>我的第一篇博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/17/hello-world/"/>
      <url>2020/11/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
