<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入学习-----ArrayList</title>
      <link href="2020/11/17/ArrayList-1/"/>
      <url>2020/11/17/ArrayList-1/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 集合—ArrayList源码笔记<br>date: 2020-11-17 14:20:32<br>tags: java，集合，源码</p><hr><h1 id="ARRAYLIST"><a href="#ARRAYLIST" class="headerlink" title="ARRAYLIST"></a><font color="orange">ARRAYLIST</font></h1><!-- ![avatar](http://i1.fuimg.com/729820/166f5e5b5f18282c.png)   --><img src="http://i1.fuimg.com/729820/166f5e5b5f18282c.png" width="30%"><p><code>可爱的小姐姐头像镇楼～～～～～～ 今天打算把看过的源码总结一下。从集合框架开始咯～～～～ 来个可爱的分隔符～！ 话不多说正式开始总结啦！！！！</code><br><code>-------------------------------------------------------</code></p><h2 id="数组-Array-和列表-ArrayList-有什么区别？"><a href="#数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？"></a>数组(Array)和列表(ArrayList)有什么区别？</h2><ol><li>定义上： Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。 </li><li>容量上： Array 大小固定， ArrayList 的大小是动态变化的。 </li><li>操作上： ArrayList 提供更多的方法和特性， </li></ol><p>使用基本数据类型或者知道数据元素数量的时候<br>可以考虑Array;<br>ArrayList处理固定数量<br>的基本类型数据类型时<br>会自动装箱来减少编码工作量，<br>但是相对较慢。</p><h2 id="2-1：ArrayList数据结构"><a href="#2-1：ArrayList数据结构" class="headerlink" title="2-1：ArrayList数据结构"></a>2-1：ArrayList数据结构</h2><p>private transient Object[] elementData;<br>底层使用<code>数组</code>实现, 其 API 都做了一层对数组底层访问的封装</p><p>并允许包括null在内的所有元素。</p><h2 id="2-2-：构造器"><a href="#2-2-：构造器" class="headerlink" title="2-2 ：构造器"></a>2-2 ：构造器</h2><p>有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如 下：<br><code>无参数直接初始化:</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。<br><code>指定初始数据初始化</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><span class="token comment" spellcheck="true">//是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>            elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// replace with empty array.</span><span class="token comment" spellcheck="true">// 给定集合（c）无值，则默认空数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><font color="orange">为什么要创建空数组？</font><br>因为开发中很多时候 创建了ArrayList对象，但是没有装元素，这个时候的话，直接初始化为10，就会浪费空间。</p><h2 id="2-3：ArrayList的add操作-以及-扩容"><a href="#2-3：ArrayList的add操作-以及-扩容" class="headerlink" title="2-3：ArrayList的add操作  以及 扩容"></a>2-3：ArrayList的add操作  以及 扩容</h2><p>新增就是往数组中添加元素，主要分成两步：<br>判断是否需要扩容，如果需要执行扩容操作；<br>直接赋值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录数组被修改</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span><span class="token comment" spellcheck="true">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果扩容后的值 > jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>我们看到，每当向数组中添加元素时， 都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容， 以满足添加数据的需求。数组扩容通过一个公开的方法 <code>ensureCapacity(int minCapacity)</code> 来 实现。</p><ol><li><p><code>ArrayList</code>第一次<code>add</code>元素时，扩容为长度为10的数组。<br>  当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时<code>minCapacity</code>等于默认的容量（<strong>10</strong>）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p></li><li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原 来容量的 <strong>1.5</strong> 倍；<br>当ArrayList数组超过当前容量时，扩容至1.5倍（遇到计算结果为小数的，向下取整），<br>第一次扩容后，容量为15，第二次扩容至22</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>     Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>     MAX_ARRAY_SIZE<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>ArrayList 中的数组的最大值是 <code>Integer.MAX_VALUE</code>，超过这个值，JVM 就不会给数组分配 内存空间了。这边也可以看到ArrayList允许的最大容量，就是Integer的最大值（-2的31次方~2的31次方减1）。</p></li><li><p>   新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 <code>null</code> 值的。</p></li><li><p>不是原子操作，，没有任何锁控制，所以这里的操作是线程不安全的，原因主要是<code>elementData[size++] = e</code>可以继续进行拆分</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>     Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>     MAX_ARRAY_SIZE<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><p>扩容是通过这行代码来实现的： <code>Arrays.copyOf(elementData, newCapacity); </code>这行代码描述的 本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据 拷贝过去，我们通过 <code>System.arraycopy </code>方法进行拷贝</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @param src 被拷贝的数组 * @param srcPos 从数组那里开始* @param dest 目标数组 * @param destPos 从目标数组那个索引位置开始拷贝 * @param length 拷贝的长度 * 此方法是没有返回值的，通过 dest 的引用进行传值 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span>Object src<span class="token punctuation">,</span>  <span class="token keyword">int</span>  srcPos<span class="token punctuation">,</span>                                    Object dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>                                    <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="2-4：remove"><a href="#2-4：remove" class="headerlink" title="2-4：remove"></a>2-4：remove</h2><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理 和思路都差不多，我们选取根据值删除方式来进行源码说明：</p><p>我们需要注意的两点是：</p><p>新增的时候是没有对 <code>null</code> 进行校验的，所以删除的时候也是允许删除 <code>null</code> 值的； 找到值在数组中的索引位置，是通过 <code>equals</code> 来判断的，如果数组元素不是基本类型，需要我 们关注 <code>equals</code> 的具体实现。</p><p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去</span><span class="token comment" spellcheck="true">// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 num</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// remove方法会让下标到数组末尾的元素向前移动一个单位，</span>并把最后一位的值置空，方便GC    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="2-5：ArrayList线程不安全"><a href="#2-5：ArrayList线程不安全" class="headerlink" title="2-5：ArrayList线程不安全"></a>2-5：ArrayList线程不安全</h2><p>只有当 ArrayList 作为<code>共享变量</code>时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，<strong>所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</strong></p><h2 id="2-6：那如何解决ArrayList线程不安全问题呢？"><a href="#2-6：那如何解决ArrayList线程不安全问题呢？" class="headerlink" title="2-6：那如何解决ArrayList线程不安全问题呢？"></a>2-6：那如何解决ArrayList线程不安全问题呢？</h2><ol><li>用Collections.synchronizedList<ul><li>因为Collections.synchronizedList封装后的list，<br> list的所有操作方法都是带synchronized关键字的，<br> 相当于所有操作都会进行加锁，<br> 所以使用它是线程安全的，但是性能大大降低，</li></ul></li></ol><pre class=" language-java"><code class="language-java"><span class="token function">SynchronizedCollection</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>E<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ol start="2"><li><code>CopyOnWriteArrayList</code><ul><li>写操作：添加元素时，<pre><code>   不直接往当前容器添加，而是先拷贝一份数组，   在新的数组中添加元素后，   在将原容器的引用指向新的容器。   因为数组时用volatile关键字修饰的，   所以当array重新赋值后，   其他线程可以立即知道（volatile的可见性）</code></pre></li><li>读操作：读取数组时，读老的数组，不需要加锁。</li><li>读写分离：写操作是copy了一份新的数组进行写，<pre><code>     读操作是读老的数组，所以是读写分离。</code></pre>采用了<code>Fail-Fast</code>机制，<br>面对并发的修改时，迭代器很快就会完全失败，<br>而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java基础，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合---ArrayList源码笔记</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88-ArrayList%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88-ArrayList%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ARRAYLIST"><a href="#ARRAYLIST" class="headerlink" title="ARRAYLIST"></a><font color="orange">ARRAYLIST</font></h1><p><img src="/tomorrow813/2020/11/17/%E9%9B%86%E5%90%88-ArrayList%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/avatar.png" alt="avatar"><br>可爱的小姐姐头像镇楼～～～～～～<br>今天打算把看过的源码总结一下。从集合框架开始咯～～～～<br>来个可爱的分隔符～！<br>话不多说正式开始总结啦！！！！<br><code>-------------------------------------------------------</code></p><h2 id="数组-Array-和列表-ArrayList-有什么区别？"><a href="#数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？"></a>数组(Array)和列表(ArrayList)有什么区别？</h2><ol><li>定义上： Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。 </li><li>容量上： Array 大小固定， ArrayList 的大小是动态变化的。 </li><li>操作上： ArrayList 提供更多的方法和特性， </li></ol><p>使用基本数据类型或者知道数据元素数量的时候<br>可以考虑Array;<br>ArrayList处理固定数量<br>的基本类型数据类型时<br>会自动装箱来减少编码工作量，<br>但是相对较慢。</p><h2 id="2-1：ArrayList数据结构"><a href="#2-1：ArrayList数据结构" class="headerlink" title="2-1：ArrayList数据结构"></a>2-1：ArrayList数据结构</h2><p>private transient Object[] elementData;<br>底层使用<code>数组</code>实现, 其 API 都做了一层对数组底层访问的封装</p><p>并允许包括null在内的所有元素。</p><h2 id="2-2-：构造器"><a href="#2-2-：构造器" class="headerlink" title="2-2 ：构造器"></a>2-2 ：构造器</h2><p>有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如 下：<br><code>无参数直接初始化:</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。<br><code>指定初始数据初始化</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><span class="token comment" spellcheck="true">//是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>            elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// replace with empty array.</span><span class="token comment" spellcheck="true">// 给定集合（c）无值，则默认空数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><font color="orange">为什么要创建空数组？</font><br>因为开发中很多时候 创建了ArrayList对象，但是没有装元素，这个时候的话，直接初始化为10，就会浪费空间。</p><h2 id="2-3：ArrayList的add操作-以及-扩容"><a href="#2-3：ArrayList的add操作-以及-扩容" class="headerlink" title="2-3：ArrayList的add操作  以及 扩容"></a>2-3：ArrayList的add操作  以及 扩容</h2><p>新增就是往数组中添加元素，主要分成两步：<br>判断是否需要扩容，如果需要执行扩容操作；<br>直接赋值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录数组被修改</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span><span class="token comment" spellcheck="true">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果扩容后的值 > jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>我们看到，每当向数组中添加元素时， 都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容， 以满足添加数据的需求。数组扩容通过一个公开的方法 <code>ensureCapacity(int minCapacity)</code> 来 实现。</p><ol><li><p><code>ArrayList</code>第一次<code>add</code>元素时，扩容为长度为10的数组。<br>  当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时<code>minCapacity</code>等于默认的容量（<strong>10</strong>）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p></li><li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原 来容量的 <strong>1.5</strong> 倍；<br>当ArrayList数组超过当前容量时，扩容至1.5倍（遇到计算结果为小数的，向下取整），<br>第一次扩容后，容量为15，第二次扩容至22</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>     Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>     MAX_ARRAY_SIZE<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>ArrayList 中的数组的最大值是 <code>Integer.MAX_VALUE</code>，超过这个值，JVM 就不会给数组分配 内存空间了。这边也可以看到ArrayList允许的最大容量，就是Integer的最大值（-2的31次方~2的31次方减1）。</p></li><li><p>   新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 <code>null</code> 值的。</p></li><li><p>不是原子操作，，没有任何锁控制，所以这里的操作是线程不安全的，原因主要是<code>elementData[size++] = e</code>可以继续进行拆分</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>     Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>     MAX_ARRAY_SIZE<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><p>扩容是通过这行代码来实现的： <code>Arrays.copyOf(elementData, newCapacity); </code>这行代码描述的 本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据 拷贝过去，我们通过 <code>System.arraycopy </code>方法进行拷贝</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @param src 被拷贝的数组 * @param srcPos 从数组那里开始* @param dest 目标数组 * @param destPos 从目标数组那个索引位置开始拷贝 * @param length 拷贝的长度 * 此方法是没有返回值的，通过 dest 的引用进行传值 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span>Object src<span class="token punctuation">,</span>  <span class="token keyword">int</span>  srcPos<span class="token punctuation">,</span>                                    Object dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>                                    <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="2-4：remove"><a href="#2-4：remove" class="headerlink" title="2-4：remove"></a>2-4：remove</h2><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理 和思路都差不多，我们选取根据值删除方式来进行源码说明：</p><p>我们需要注意的两点是：</p><p>新增的时候是没有对 <code>null</code> 进行校验的，所以删除的时候也是允许删除 <code>null</code> 值的； 找到值在数组中的索引位置，是通过 <code>equals</code> 来判断的，如果数组元素不是基本类型，需要我 们关注 <code>equals</code> 的具体实现。</p><p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去</span><span class="token comment" spellcheck="true">// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 num</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// remove方法会让下标到数组末尾的元素向前移动一个单位，</span>并把最后一位的值置空，方便GC    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="2-5：ArrayList线程不安全"><a href="#2-5：ArrayList线程不安全" class="headerlink" title="2-5：ArrayList线程不安全"></a>2-5：ArrayList线程不安全</h2><p>只有当 ArrayList 作为<code>共享变量</code>时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，<strong>所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</strong></p><h2 id="2-6：那如何解决ArrayList线程不安全问题呢？"><a href="#2-6：那如何解决ArrayList线程不安全问题呢？" class="headerlink" title="2-6：那如何解决ArrayList线程不安全问题呢？"></a>2-6：那如何解决ArrayList线程不安全问题呢？</h2><ol><li>用Collections.synchronizedList<ul><li>因为Collections.synchronizedList封装后的list，<br> list的所有操作方法都是带synchronized关键字的，<br> 相当于所有操作都会进行加锁，<br> 所以使用它是线程安全的，但是性能大大降低，</li></ul></li></ol><pre class=" language-java"><code class="language-java"><span class="token function">SynchronizedCollection</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>E<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    mutex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ol start="2"><li><code>CopyOnWriteArrayList</code><ul><li>写操作：添加元素时，<pre><code>   不直接往当前容器添加，而是先拷贝一份数组，   在新的数组中添加元素后，   在将原容器的引用指向新的容器。   因为数组时用volatile关键字修饰的，   所以当array重新赋值后，   其他线程可以立即知道（volatile的可见性）</code></pre></li><li>读操作：读取数组时，读老的数组，不需要加锁。</li><li>读写分离：写操作是copy了一份新的数组进行写，<pre><code>     读操作是读老的数组，所以是读写分离。</code></pre>采用了<code>Fail-Fast</code>机制，<br>面对并发的修改时，迭代器很快就会完全失败，<br>而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java，集合，源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="2020/11/17/%E9%9B%86%E5%90%88/"/>
      <url>2020/11/17/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><img src="avatar.png"><br>可爱的小姐姐头像镇楼～～～～～～<br>**<font color = "orange">今天打算把看过的源码总结一下。从集合框架开始咯～～～～<br>来个可爱的分隔符～！<br>话不多说正式开始总结啦！！！！<br></font>**</p><p><strong>那就先看看集合框架的总体介绍吧</strong>～<br>集合框架：总体分为Map和Collection两大类</p><ol><li><p>Collection接口：是单值集合的根接口。没有直接的实现类，但是具有更具体的子接口：List Set</p><ol><li><p>List 元素有序，可重复的集合  </p><ul><li>Arraylist： Object数组。 集合中的每个元素都有其对应的顺序索引。</li><li>Vector： Object数组</li><li>LinkedList： 双向链表(JDK1.6之前为循环链表， JDK1.7取消了循环)</li></ul></li><li><p>Set 元素无序(元素存放的顺序不保证)、不可重复的集合 </p><ul><li><p>HashSet: 基于 HashMap 实现的，既不能保证添加顺序，也不能保证大小顺序</p></li><li><p>LinkedHashSet： LinkedHashSet 继承于 HashSet，</p><pre><code>             比HashSet多维护了添加的顺序，LinkedHashSet插入性能略低于 HashSet,元素不可重复           并且其内部是通过 LinkedHashMap 来实现的。           有点类似于我们之前说的LinkedHashMap            其内部是基于 HashMap 实现⼀样，不过还是有⼀点点区别的</code></pre></li><li><p>TreeSet： 红黑树(⾃平衡的排序二叉树)，</p><pre><code>     元素不可重复，可以保证元素的大小排序     一定要用到java.lang.Comparable  或者是java.util.Comparator     TreeSet 两种排序方法：自然排序和定制排序。     默认情况下，TreeSet 采用自然排序。TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的关系，然后将集合元素按升序排列    如果试图把一个对象大小添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。    实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。    如果需要定制排序，比如降序排列，可通过Comparator接口的帮助。需要重写compare(T o1,T o2)方法。    利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。    要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。    此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。    使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0</code></pre><p>HashSet ,LinkedHashSet的不可重复性是怎么实现的？</p></li></ul><p>  – 现比较hash值，如果hash值不一样的话，说明一定是不相同的。<br>  – 如果说hash是一样的，再调用equals取比较大小</p></li><li><p>Queue</p></li></ol></li><li><p>Map</p><ol><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，<pre><code>      数组是HashMap的主体，      链表则是主要为了解决哈希冲突⽽存在的（“拉链法”解决冲突）。       JDK1.8以后在解决哈希冲突时有了较⼤的变化，       当链表⻓度⼤于阈值（默认为8）时，       将链表转化为红⿊树，以减少搜索时间</code></pre></li><li>LinkedHashMap： LinkedHashMap 继承⾃ HashMap，<pre><code>           所以它的底层仍然是基于拉链式散列结构           即由数组和链表或红⿊树组成。           LinkedHashMap 在上⾯结构的基础上，           增加了⼀条双向链表，           使得上⾯的结构可以保持键值对的插⼊顺序。           同时通过对链表进⾏相应的操作，           实现了访问顺序相关逻辑。</code></pre></li><li>Hashtable： 数组+链表组成的，数组是 HashMap 的主体，<pre><code>        链表则是主要为了解决哈希冲突⽽存在的</code></pre></li></ol></li><li><p>TreeMap： 红⿊树（⾃平衡的排序⼆叉树）</p></li></ol><p>有点懵圈～，还是来看看List家族的源码吧，加深理解～<br>1.VECTOR</p><h2 id="1-1：vector数据结构"><a href="#1-1：vector数据结构" class="headerlink" title="1-1：vector数据结构"></a>1-1：vector数据结构</h2><p>底层数据结构为数组，支持快速随机访问</p><h2 id="1-2：vector构造器"><a href="#1-2：vector构造器" class="headerlink" title="1-2：vector构造器"></a>1-2：vector构造器</h2><p>Vector有四个不同的构造函数。 无参构造的容量默认值为10，容量增长系数CapacityIncrement为0<br>public Vector(int initialCapacity, int capacityIncrement) {<br>    super();<br>    if (initialCapacity &lt; 0)<br>        throw new IllegalArgumentException(“Illegal Capacity: “+<br>                                           initialCapacity);<br>    this.elementData = new Object[initialCapacity];<br>    this.capacityIncrement = capacityIncrement;<br>}</p><h2 id="1-3：vector-indexOf-object-o"><a href="#1-3：vector-indexOf-object-o" class="headerlink" title="1-3：vector  indexOf(object o)"></a>1-3：vector  indexOf(object o)</h2><p>Vector在查找给定元素索引值方法中，indexOf(object o )–&gt;<br>public int indexOf(Object o) {<br>    return indexOf(o, 0);<br>}<br>public synchronized int indexOf(Object o, int index) {<br>    if (o == null) {<br>        for (int i = index ; i &lt; elementCount ; i++)<br>            if (elementData[i]==null)<br>                return i;<br>    } else {<br>        for (int i = index ; i &lt; elementCount ; i++)<br>            if (o.equals(elementData[i]))<br>                return i;<br>    }<br>    return -1;<br>}</p><p>Vector中允许元素为null<br>源码都将该元素的值分为null和不为null两种情况处理，</p><h2 id="1-4：扩容机制"><a href="#1-4：扩容机制" class="headerlink" title="1-4：扩容机制"></a>1-4：扩容机制</h2><p>与ArrayList不同的是，<br>Vector在每次add增加元素(可能是1个，也可能是一组)时，<br>public synchronized boolean add(E e) {<br>    modCount++;<br>    ensureCapacityHelper(elementCount + 1);<br>    elementData[elementCount++] = e;<br>    return true;<br>}</p><p>都要调用ensureCapacityHelper方法来确保足够的容量。<br>private void ensureCapacityHelper(int minCapacity) {<br>    // overflow-conscious code<br>    if (minCapacity - elementData.length &gt; 0)<br>        grow(minCapacity);<br>}</p><p>当容量不足以容纳当前的元素个数时，即minCapacity（指的是当前元素数目elementCount + 1） - elementData.length &gt; 0，就会grow(minCapacity)扩容</p><p>private void grow(int minCapacity) {<br>    // overflow-conscious code<br>    int oldCapacity = elementData.length;<br>    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?<br>                                     capacityIncrement : oldCapacity);<br>    if (newCapacity - minCapacity &lt; 0)<br>        newCapacity = minCapacity;<br>    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)<br>        newCapacity = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>}</p><p>就看构造方法中传入的容量增长系数CapacityIncrement是否为0，<br>如果不为0，就设置新的容量为 旧容量 + 容量增长量；<br>如果为0，设置新的容量为旧的容量的2倍，<br>如果设置后的容量还不够，则直接新的容量设置为  传入参数所需要的容量<br>而后同样用Arrays.copyof()方法将元素拷贝到新的数组。</p><h2 id="1-5：Vector是保证线程安全的"><a href="#1-5：Vector是保证线程安全的" class="headerlink" title="1-5：Vector是保证线程安全的"></a>1-5：Vector是保证线程安全的</h2><p>由于vector中Add方法加了synchronized，来保证add操作是线程安全的<br>   哈哈哈哈哈哈，还挺好玩的，接着看！<br>2.ARRAYLIST</p><h3 id="2-1：数组-Array-和列表-ArrayList-有什么区别？"><a href="#2-1：数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="2-1：数组(Array)和列表(ArrayList)有什么区别？"></a>2-1：数组(Array)和列表(ArrayList)有什么区别？</h3><ol><li>定义上： Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。 </li><li>容量上： Array 大小固定， ArrayList 的大小是动态变化的。 </li><li>操作上： ArrayList 提供更多的方法和特性， </li></ol><p>使用基本数据类型或者知道数据元素数量的时候<br>可以考虑Array;<br>ArrayList处理固定数量<br>的基本类型数据类型时<br>会自动装箱来减少编码工作量，<br>但是相对较慢。</p><h2 id="2-1：ArrayList数据结构"><a href="#2-1：ArrayList数据结构" class="headerlink" title="2-1：ArrayList数据结构"></a>2-1：ArrayList数据结构</h2><p>private transient Object[] elementData;<br>底层使用数组实现, 其 API 都做了一层对数组底层访问的封装</p><p>并允许包括null在内的所有元素。</p><h3 id="2-1-：构造器"><a href="#2-1-：构造器" class="headerlink" title="2-1 ：构造器"></a>2-1 ：构造器</h3><p>有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如 下：<br>无参数直接初始化:<br>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};<br>public ArrayList() {<br>    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>}<br>    ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。<br>指定初始数据初始化<br>public ArrayList(Collection&lt;? extends E&gt; c) {<br>    elementData = c.toArray();<br>    if ((size = elementData.length) != 0) {<br>        // c.toArray might (incorrectly) not return Object[] (see 6260652)<br>//是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型<br>        if (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    } else {<br>        // replace with empty array.<br>// 给定集合（c）无值，则默认空数组<br>        this.elementData = EMPTY_ELEMENTDATA;<br>    }<br>}<br>    为什么要创建空数组？<br>    因为开发中很多时候 创建了ArrayList对象，但是没有装元素，这个时候的话，直接初始化为10，就会浪费空间。</p><h3 id="2-4：ArrayList的add操作-以及-扩容"><a href="#2-4：ArrayList的add操作-以及-扩容" class="headerlink" title="2-4：ArrayList的add操作  以及 扩容"></a>2-4：ArrayList的add操作  以及 扩容</h3><p>新增就是往数组中添加元素，主要分成两步：<br>    判断是否需要扩容，如果需要执行扩容操作；<br>    直接赋值。</p><p>public boolean add(E e) {<br>//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小<br>    ensureCapacityInternal(size + 1);  // Increments modCount!!<br>    elementData[size++] = e;<br>    return true;<br>}</p><p>private void ensureCapacityInternal(int minCapacity) {<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>}</p><p>private static int calculateCapacity(Object[] elementData, int minCapacity) {<br>//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑<br>    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {<br>        return Math.max(DEFAULT_CAPACITY, minCapacity);<br>    }<br>    return minCapacity;<br>}</p><p>private void ensureExplicitCapacity(int minCapacity) {<br>//记录数组被修改<br>    modCount++;</p><pre><code>// overflow-conscious code</code></pre><p>// 如果我们期望的最小容量大于目前数组的长度，那么就扩容<br>    if (minCapacity - elementData.length &gt; 0)<br>        grow(minCapacity);<br>}</p><p>// 如果我们期望的最小容量大于目前数组的长度，那么就扩容<br>private void grow(int minCapacity) {<br>    // overflow-conscious code<br>    int oldCapacity = elementData.length;<br>    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值<br>    if (newCapacity - minCapacity &lt; 0)<br>        newCapacity = minCapacity;<br>// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值<br>    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)<br>        newCapacity = hugeCapacity(minCapacity);<br>    // minCapacity is usually close to size, so this is a win:<br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>}<br>我们看到，每当向数组中添加元素时， 都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容， 以满足添加数据的需求。数组扩容通过一个公开的方法 ensureCapacity(int minCapacity) 来 实现。</p><ol><li><p>ArrayList第一次add元素时，扩容为长度为10的数组。<br>  当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时minCapacity等于默认的容量（10）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p></li><li><p>   扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原 来容量的 1.5 倍；<br>当ArrayList数组超过当前容量时，扩容至1.5倍（遇到计算结果为小数的，向下取整），<br>第一次扩容后，容量为15，第二次扩容至22</p></li><li><p>private static int hugeCapacity(int minCapacity) {<br> if (minCapacity &lt; 0) // overflow</p><pre><code> throw new OutOfMemoryError();</code></pre><p> return (minCapacity &gt; MAX_ARRAY_SIZE) ?</p><pre><code> Integer.MAX_VALUE : MAX_ARRAY_SIZE;</code></pre><p>}</p></li></ol><p>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配 内存空间了。这边也可以看到ArrayList允许的最大容量，就是Integer的最大值（-2的31次方~2的31次方减1）。<br>4.    新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</p><ol start="5"><li>不是原子操作，，没有任何锁控制，所以这里的操作是线程不安全的，原因主要是elementData[size++] = e可以继续进行拆分<br>private static int hugeCapacity(int minCapacity) {<br> if (minCapacity &lt; 0) // overflow<pre><code> throw new OutOfMemoryError();</code></pre> return (minCapacity &gt; MAX_ARRAY_SIZE) ?<pre><code> Integer.MAX_VALUE : MAX_ARRAY_SIZE;</code></pre>}</li></ol><p>    扩容是通过这行代码来实现的： Arrays.copyOf(elementData, newCapacity); 这行代码描述的 本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据 拷贝过去，我们通过 System.arraycopy 方法进行拷贝<br>/** * @param src 被拷贝的数组 </p><ul><li>@param srcPos 从数组那里开始</li><li>@param dest 目标数组 </li><li>@param destPos 从目标数组那个索引位置开始拷贝 </li><li>@param length 拷贝的长度 </li><li>此方法是没有返回值的，通过 dest 的引用进行传值 */<br>public static native void arraycopy(Object src,  int  srcPos,<pre><code>                              Object dest, int destPos,                              int length);</code></pre></li></ul><h3 id="2-4：remove"><a href="#2-4：remove" class="headerlink" title="2-4：remove"></a>2-4：remove</h3><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理 和思路都差不多，我们选取根据值删除方式来进行源码说明：</p><p>我们需要注意的两点是：</p><p>新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的； 找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我 们关注 equals 的具体实现。</p><p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：<br>public boolean remove(Object o) {<br>    if (o == null) {<br>        for (int index = 0; index &lt; size; index++)<br>            if (elementData[index] == null) {<br>                fastRemove(index);<br>                return true;<br>            }<br>    } else {<br>        for (int index = 0; index &lt; size; index++)<br>            if (o.equals(elementData[index])) {<br>                fastRemove(index);<br>                return true;<br>            }<br>    }<br>    return false;<br>}</p><p>private void fastRemove(int index) {<br>    modCount++;<br>    int numMoved = size - index - 1;<br>    if (numMoved &gt; 0)<br>// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去<br>// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 num<br>        System.arraycopy(elementData, index+1, elementData, index,<br>                         numMoved);<br>// remove方法会让下标到数组末尾的元素向前移动一个单位，<br>并把最后一位的值置空，方便GC<br>    elementData[–size] = null; // clear to let GC do its work</p><p>}</p><h2 id="2-6：ArrayList线程不安全"><a href="#2-6：ArrayList线程不安全" class="headerlink" title="2-6：ArrayList线程不安全"></a>2-6：ArrayList线程不安全</h2><p>只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p><h3 id="2-7：那如何解决ArrayList线程不安全问题呢？"><a href="#2-7：那如何解决ArrayList线程不安全问题呢？" class="headerlink" title="2-7：那如何解决ArrayList线程不安全问题呢？"></a>2-7：那如何解决ArrayList线程不安全问题呢？</h3><ol><li>用Collections.synchronizedList<ul><li>因为Collections.synchronizedList封装后的list，<br> list的所有操作方法都是带synchronized关键字的，<br> 相当于所有操作都会进行加锁，<br> 所以使用它是线程安全的，但是性能大大降低，<br>SynchronizedCollection(Collection<E> c) {<br>this.c = Objects.requireNonNull(c);<br>mutex = this;<br>}</li></ul></li></ol><p>public boolean add(E e) {<br>    synchronized (mutex) {return c.add(e);}<br>}</p><ol start="2"><li>CopyOnWriteArrayList<ul><li>写操作：添加元素时，<pre><code>   不直接往当前容器添加，而是先拷贝一份数组，   在新的数组中添加元素后，   在将原容器的引用指向新的容器。   因为数组时用volatile关键字修饰的，   所以当array重新赋值后，   其他线程可以立即知道（volatile的可见性）</code></pre></li><li>读操作：读取数组时，读老的数组，不需要加锁。</li><li>读写分离：写操作是copy了一份新的数组进行写，<pre><code>     读操作是读老的数组，所以是读写分离。</code></pre>采用了Fail-Fast机制，<br>面对并发的修改时，迭代器很快就会完全失败，<br>而不是冒着在将来某个不确定时间发生任意不确定行为的风险<br>嗯嗯嗯不错不错，学习到了再来看看Linkedlist的源码吧</li></ul></li><li>LINKEDLIST<h2 id="3-1：linkedlist数据结构"><a href="#3-1：linkedlist数据结构" class="headerlink" title="3-1：linkedlist数据结构"></a>3-1：linkedlist数据结构</h2></li></ol><p>LinkedList是List接口的双向链表非同步实现，<br>并允许包括null在内的所有元素。<br>双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如 下：</p><p>first 是双向链表的头节点，它的前一个节点是 null。<br>last 是双向链表的尾节点，它的后一个节点是 null；<br>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；<br>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。<br>双向链表节点对应的类Node的实例，<br>Node中包含成员变量：prev，next，item。<br>prev是该节点的上一个节点，<br>next是该节点的下一个节点，<br>item是该节点所包含的值。</p><p>/**</p><ul><li><p>Returns the (non-null) Node at the specified element index.</p></li><li><p>/<br>Node<E> node(int index) {<br>  // assert isElementIndex(index);</p><p>  if (index &lt; (size &gt;&gt; 1)) {<br>// 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; 1 是 size 除以 2 的意思。</p><pre><code>  Node&lt;E&gt; x = first;</code></pre><p>// 直到 for 循环到 index 的前一个 node 停止</p><pre><code>  for (int i = 0; i &lt; index; i++)      x = x.next;  return x;</code></pre><p>  } else {<br>// 如果 index 处于队列的后半部分，从尾开始找</p><pre><code>  Node&lt;E&gt; x = last;</code></pre><p>// 直到 for 循环到 index 的后一个 node 停止</p><pre><code>  for (int i = size - 1; i &gt; index; i--)      x = x.prev;  return x;</code></pre><p>  }<br>}</p></li></ul><p>从源码中我们可以发现， LinkedList 并没有采用从头循环到尾的做法， 而是采取了简单二分 法， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值 得我们借鉴。</p><h2 id="3-1：linkedlist-add"><a href="#3-1：linkedlist-add" class="headerlink" title="3-1：linkedlist  add"></a>3-1：linkedlist  add</h2><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把 节点的值，前后指向节点都置为 null，帮助 GC 进行回收。<br>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开 始追加，addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：<br>void linkLast(E e) {<br>// 把尾节点数据暂存<br>    final Node<E> l = last;<br>// 新建新的节点，初始化入参含义：<br>// l 是新节点的前一个节点，当前值是尾节点值<br>    final Node<E> newNode = new Node&lt;&gt;(l, e, null);<br>    last = newNode;<br>//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节<br>    if (l == null)<br>        first = newNode;<br>//否则把前尾节点的下一个节点，指向当前尾节点。<br>    else<br>        l.next = newNode;<br>//大小和版本更改<br>    size++;<br>    modCount++;<br>}<br>从头部追加（addFirst）<br>/**</p><ul><li>Links e as first element.</li><li>/<br>private void linkFirst(E e) {<br>  final Node<E> f = first;<br>  final Node<E> newNode = new Node&lt;&gt;(null, e, f);<br>  first = newNode;<br>  if (f == null)<pre><code>  last = newNode;</code></pre>  else<pre><code>  f.prev = newNode;</code></pre>  size++;<br>  modCount++;<br>}</li></ul><h2 id="3-1：linkedlist"><a href="#3-1：linkedlist" class="headerlink" title="3-1：linkedlist"></a>3-1：linkedlist</h2><p>private E unlinkLast(Node<E> l) {<br>    // assert l == last &amp;&amp; l != null;<br>    final E element = l.item;<br>    final Node<E> prev = l.prev;<br>    l.item = null;<br>    l.prev = null; // help GC<br>    last = prev;<br>    if (prev == null)<br>        first = null;<br>    else<br>        prev.next = null;<br>    size–;<br>    modCount++;<br>    return element;<br>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List 源码会问哪些面试题<br>   手画一个小心心<br>源码扩容过程有什么值得借鉴的地方？<br>答：有两点：<br>    是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封 装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时， 也可快速扩容。<br>    扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</p><p>这两点在我们平时设计和写代码时都可以借鉴。</p><p>ArrayList 和 LinkedList 两者有没有最大容量</p><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存 空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用 的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p><h2 id="：vector、Arraylist区别和适用场景"><a href="#：vector、Arraylist区别和适用场景" class="headerlink" title="：vector、Arraylist区别和适用场景"></a>：vector、Arraylist区别和适用场景</h2><ol><li><p>线程：Vector是多线程安全的， Vector类中的方法很多有synchronized进行修饰，</p><pre><code>  只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。  ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。  这样就导致了Vector在效率上无法与ArrayList相比</code></pre></li><li><p>底层：两个都是数组实现，支持快速随机访问，其 API 都做了一层对数组底层访问的封装</p></li><li><p>初始化：Vector无参构造器初始化时就生成了容量为10的空数组，ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。</p><pre><code>  Vector可以设置增长因子CapacityIncrement，而ArrayList不可以</code></pre></li><li><p>扩容机制：<br>Vector在每次add增加元素(可能是1个，也可能是一组)时，都要调用ensureCapacityHelper方法来确保足够的容量，当容量不足以容纳当前的元素个数时，即minCapacity（指的是当前元素数目elementCount + 1） - elementData.length &gt; 0，就会grow(minCapacity)扩容，就看构造方法中传入的容量增长系数CapacityIncrement是否为0，</p><pre><code>  如果不为0，就设置新的容量为 旧容量 + 容量增长量；  如果为0，设置新的容量为旧的容量的2倍，  如果设置后的容量还不够，则直接新的容量设置为  传入参数所需要的容量 </code></pre><p>ArrayList在每次add增加元素(可能是1个，也可能是一组)时，都要调用nsureCapacityInternal方法来确保足够的容量,如果我们期望的最小容量大于目前数组的长度，那么就扩容.</p><ol><li>ArrayList第一次add元素时，扩容为长度为10的数组。<br>当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时minCapacity等于默认的容量（10）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；<br>arraylist、linkedlist区别和适用场景</li></ol></li><li><p>是否保证线程安全： ArrayList在单线程下是线程安全的，</p><pre><code>             多线程下由于多个线程不断抢夺资源，             所以会出现不安全             和 LinkedList 都是不同步的，也就是不保证线程安全；</code></pre></li><li><p>底层数据结构： Arraylist 底层使用的是 Object 数组；</p><pre><code>          LinkedList 底层使用的是 双向链表 数据结构</code></pre></li><li><p>插入和删除是否受元素位置的影响：<br>① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。<br>② LinkedList 采用链表存储，插入删除元素时间复杂度不受元素位置的影响，</p><pre><code>         如果是要在指定位置i插入和删除元素的话需要先移动到指定位置再插入。</code></pre></li><li><p>是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，<br>LinkedList 并没有采用从头循环到尾的做法， 而是采取了简单二分 法， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值 得我们借鉴。</p><pre><code>                 而 ArrayList 支持。                 快速随机访问就是通过                 元素的序号快速获取元素对象(对应于get(int index) 方法)。</code></pre></li><li><p>内存空间占用： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，</p><pre><code>          而LinkedList的空间花费则体现在          它的每一个元素都需要消耗比ArrayList更多的空间</code></pre><p>双向链表节点对应的类Node的实例，<br>Node中包含成员变量：prev，next，item。<br>prev是该节点的上一个节点，<br>next是该节点的下一个节点，<br>item是该节点所包含的值。</p><pre><code>          （因为要存放直接后继和直接前驱以及数据）</code></pre><p>当需要对数据进行对此访问的情况下选用ArrayList，<br>当需要对数据进行多次增加删除修改时采用LinkedList。<br>•    ArrayList与LinkedList集合各有所长，可以在不同场合根据具体需求选用:<br>–    ArrayList元素的检索速度高于LinkedList<br>–    LinkedList因为内存的不连续性，更适合于大批量数据的存放和管理<br>–    如果在非末端插入数据，LinkedList速度优于ArrayList</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/11/17/ArrayList/"/>
      <url>2020/11/17/ArrayList/</url>
      
        <content type="html"><![CDATA[<p><img src="avatar.png"><br>可爱的小姐姐头像镇楼～～～～～～<br>**<font color = "orange">今天打算把看过的源码总结一下。从集合框架开始咯～～～～<br>来个可爱的分隔符～！<br>话不多说正式开始总结啦！！！！<br></font>**</p><p><strong>那就先看看集合框架的总体介绍吧</strong>～<br>集合框架：总体分为Map和Collection两大类</p><ol><li><p>Collection接口：是单值集合的根接口。没有直接的实现类，但是具有更具体的子接口：List Set</p><ol><li><p>List 元素有序，可重复的集合  </p><ul><li>Arraylist： Object数组。 集合中的每个元素都有其对应的顺序索引。</li><li>Vector： Object数组</li><li>LinkedList： 双向链表(JDK1.6之前为循环链表， JDK1.7取消了循环)</li></ul></li><li><p>Set 元素无序(元素存放的顺序不保证)、不可重复的集合 </p><ul><li><p>HashSet: 基于 HashMap 实现的，既不能保证添加顺序，也不能保证大小顺序</p></li><li><p>LinkedHashSet： LinkedHashSet 继承于 HashSet，</p><pre><code>             比HashSet多维护了添加的顺序，LinkedHashSet插入性能略低于 HashSet,元素不可重复           并且其内部是通过 LinkedHashMap 来实现的。           有点类似于我们之前说的LinkedHashMap            其内部是基于 HashMap 实现⼀样，不过还是有⼀点点区别的</code></pre></li><li><p>TreeSet： 红黑树(⾃平衡的排序二叉树)，</p><pre><code>     元素不可重复，可以保证元素的大小排序     一定要用到java.lang.Comparable  或者是java.util.Comparator     TreeSet 两种排序方法：自然排序和定制排序。     默认情况下，TreeSet 采用自然排序。TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的关系，然后将集合元素按升序排列    如果试图把一个对象大小添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。    实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。    如果需要定制排序，比如降序排列，可通过Comparator接口的帮助。需要重写compare(T o1,T o2)方法。    利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。    要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。    此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。    使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0</code></pre><p>HashSet ,LinkedHashSet的不可重复性是怎么实现的？</p></li></ul><p>  – 现比较hash值，如果hash值不一样的话，说明一定是不相同的。<br>  – 如果说hash是一样的，再调用equals取比较大小</p></li><li><p>Queue</p></li></ol></li><li><p>Map</p><ol><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，<pre><code>      数组是HashMap的主体，      链表则是主要为了解决哈希冲突⽽存在的（“拉链法”解决冲突）。       JDK1.8以后在解决哈希冲突时有了较⼤的变化，       当链表⻓度⼤于阈值（默认为8）时，       将链表转化为红⿊树，以减少搜索时间</code></pre></li><li>LinkedHashMap： LinkedHashMap 继承⾃ HashMap，<pre><code>           所以它的底层仍然是基于拉链式散列结构           即由数组和链表或红⿊树组成。           LinkedHashMap 在上⾯结构的基础上，           增加了⼀条双向链表，           使得上⾯的结构可以保持键值对的插⼊顺序。           同时通过对链表进⾏相应的操作，           实现了访问顺序相关逻辑。</code></pre></li><li>Hashtable： 数组+链表组成的，数组是 HashMap 的主体，<pre><code>        链表则是主要为了解决哈希冲突⽽存在的</code></pre></li></ol></li><li><p>TreeMap： 红⿊树（⾃平衡的排序⼆叉树）</p></li></ol><p>有点懵圈～，还是来看看List家族的源码吧，加深理解～<br>1.VECTOR</p><h2 id="1-1：vector数据结构"><a href="#1-1：vector数据结构" class="headerlink" title="1-1：vector数据结构"></a>1-1：vector数据结构</h2><p>底层数据结构为数组，支持快速随机访问</p><h2 id="1-2：vector构造器"><a href="#1-2：vector构造器" class="headerlink" title="1-2：vector构造器"></a>1-2：vector构造器</h2><p>Vector有四个不同的构造函数。 无参构造的容量默认值为10，容量增长系数CapacityIncrement为0<br>public Vector(int initialCapacity, int capacityIncrement) {<br>    super();<br>    if (initialCapacity &lt; 0)<br>        throw new IllegalArgumentException(“Illegal Capacity: “+<br>                                           initialCapacity);<br>    this.elementData = new Object[initialCapacity];<br>    this.capacityIncrement = capacityIncrement;<br>}</p><h2 id="1-3：vector-indexOf-object-o"><a href="#1-3：vector-indexOf-object-o" class="headerlink" title="1-3：vector  indexOf(object o)"></a>1-3：vector  indexOf(object o)</h2><p>Vector在查找给定元素索引值方法中，indexOf(object o )–&gt;<br>public int indexOf(Object o) {<br>    return indexOf(o, 0);<br>}<br>public synchronized int indexOf(Object o, int index) {<br>    if (o == null) {<br>        for (int i = index ; i &lt; elementCount ; i++)<br>            if (elementData[i]==null)<br>                return i;<br>    } else {<br>        for (int i = index ; i &lt; elementCount ; i++)<br>            if (o.equals(elementData[i]))<br>                return i;<br>    }<br>    return -1;<br>}</p><p>Vector中允许元素为null<br>源码都将该元素的值分为null和不为null两种情况处理，</p><h2 id="1-4：扩容机制"><a href="#1-4：扩容机制" class="headerlink" title="1-4：扩容机制"></a>1-4：扩容机制</h2><p>与ArrayList不同的是，<br>Vector在每次add增加元素(可能是1个，也可能是一组)时，<br>public synchronized boolean add(E e) {<br>    modCount++;<br>    ensureCapacityHelper(elementCount + 1);<br>    elementData[elementCount++] = e;<br>    return true;<br>}</p><p>都要调用ensureCapacityHelper方法来确保足够的容量。<br>private void ensureCapacityHelper(int minCapacity) {<br>    // overflow-conscious code<br>    if (minCapacity - elementData.length &gt; 0)<br>        grow(minCapacity);<br>}</p><p>当容量不足以容纳当前的元素个数时，即minCapacity（指的是当前元素数目elementCount + 1） - elementData.length &gt; 0，就会grow(minCapacity)扩容</p><p>private void grow(int minCapacity) {<br>    // overflow-conscious code<br>    int oldCapacity = elementData.length;<br>    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?<br>                                     capacityIncrement : oldCapacity);<br>    if (newCapacity - minCapacity &lt; 0)<br>        newCapacity = minCapacity;<br>    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)<br>        newCapacity = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>}</p><p>就看构造方法中传入的容量增长系数CapacityIncrement是否为0，<br>如果不为0，就设置新的容量为 旧容量 + 容量增长量；<br>如果为0，设置新的容量为旧的容量的2倍，<br>如果设置后的容量还不够，则直接新的容量设置为  传入参数所需要的容量<br>而后同样用Arrays.copyof()方法将元素拷贝到新的数组。</p><h2 id="1-5：Vector是保证线程安全的"><a href="#1-5：Vector是保证线程安全的" class="headerlink" title="1-5：Vector是保证线程安全的"></a>1-5：Vector是保证线程安全的</h2><p>由于vector中Add方法加了synchronized，来保证add操作是线程安全的<br>   哈哈哈哈哈哈，还挺好玩的，接着看！<br>2.ARRAYLIST</p><h3 id="2-1：数组-Array-和列表-ArrayList-有什么区别？"><a href="#2-1：数组-Array-和列表-ArrayList-有什么区别？" class="headerlink" title="2-1：数组(Array)和列表(ArrayList)有什么区别？"></a>2-1：数组(Array)和列表(ArrayList)有什么区别？</h3><ol><li>定义上： Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。 </li><li>容量上： Array 大小固定， ArrayList 的大小是动态变化的。 </li><li>操作上： ArrayList 提供更多的方法和特性， </li></ol><p>使用基本数据类型或者知道数据元素数量的时候<br>可以考虑Array;<br>ArrayList处理固定数量<br>的基本类型数据类型时<br>会自动装箱来减少编码工作量，<br>但是相对较慢。</p><h2 id="2-1：ArrayList数据结构"><a href="#2-1：ArrayList数据结构" class="headerlink" title="2-1：ArrayList数据结构"></a>2-1：ArrayList数据结构</h2><p>private transient Object[] elementData;<br>底层使用数组实现, 其 API 都做了一层对数组底层访问的封装</p><p>并允许包括null在内的所有元素。</p><h3 id="2-1-：构造器"><a href="#2-1-：构造器" class="headerlink" title="2-1 ：构造器"></a>2-1 ：构造器</h3><p>有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如 下：<br>无参数直接初始化:<br>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};<br>public ArrayList() {<br>    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>}<br>    ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。<br>指定初始数据初始化<br>public ArrayList(Collection&lt;? extends E&gt; c) {<br>    elementData = c.toArray();<br>    if ((size = elementData.length) != 0) {<br>        // c.toArray might (incorrectly) not return Object[] (see 6260652)<br>//是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型<br>        if (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    } else {<br>        // replace with empty array.<br>// 给定集合（c）无值，则默认空数组<br>        this.elementData = EMPTY_ELEMENTDATA;<br>    }<br>}<br>    为什么要创建空数组？<br>    因为开发中很多时候 创建了ArrayList对象，但是没有装元素，这个时候的话，直接初始化为10，就会浪费空间。</p><h3 id="2-4：ArrayList的add操作-以及-扩容"><a href="#2-4：ArrayList的add操作-以及-扩容" class="headerlink" title="2-4：ArrayList的add操作  以及 扩容"></a>2-4：ArrayList的add操作  以及 扩容</h3><p>新增就是往数组中添加元素，主要分成两步：<br>    判断是否需要扩容，如果需要执行扩容操作；<br>    直接赋值。</p><p>public boolean add(E e) {<br>//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小<br>    ensureCapacityInternal(size + 1);  // Increments modCount!!<br>    elementData[size++] = e;<br>    return true;<br>}</p><p>private void ensureCapacityInternal(int minCapacity) {<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>}</p><p>private static int calculateCapacity(Object[] elementData, int minCapacity) {<br>//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑<br>    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {<br>        return Math.max(DEFAULT_CAPACITY, minCapacity);<br>    }<br>    return minCapacity;<br>}</p><p>private void ensureExplicitCapacity(int minCapacity) {<br>//记录数组被修改<br>    modCount++;</p><pre><code>// overflow-conscious code</code></pre><p>// 如果我们期望的最小容量大于目前数组的长度，那么就扩容<br>    if (minCapacity - elementData.length &gt; 0)<br>        grow(minCapacity);<br>}</p><p>// 如果我们期望的最小容量大于目前数组的长度，那么就扩容<br>private void grow(int minCapacity) {<br>    // overflow-conscious code<br>    int oldCapacity = elementData.length;<br>    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值<br>    if (newCapacity - minCapacity &lt; 0)<br>        newCapacity = minCapacity;<br>// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值<br>    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)<br>        newCapacity = hugeCapacity(minCapacity);<br>    // minCapacity is usually close to size, so this is a win:<br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>}<br>我们看到，每当向数组中添加元素时， 都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容， 以满足添加数据的需求。数组扩容通过一个公开的方法 ensureCapacity(int minCapacity) 来 实现。</p><ol><li><p>ArrayList第一次add元素时，扩容为长度为10的数组。<br>  当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时minCapacity等于默认的容量（10）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；</p></li><li><p>   扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原 来容量的 1.5 倍；<br>当ArrayList数组超过当前容量时，扩容至1.5倍（遇到计算结果为小数的，向下取整），<br>第一次扩容后，容量为15，第二次扩容至22</p></li><li><p>private static int hugeCapacity(int minCapacity) {<br> if (minCapacity &lt; 0) // overflow</p><pre><code> throw new OutOfMemoryError();</code></pre><p> return (minCapacity &gt; MAX_ARRAY_SIZE) ?</p><pre><code> Integer.MAX_VALUE : MAX_ARRAY_SIZE;</code></pre><p>}</p></li></ol><p>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配 内存空间了。这边也可以看到ArrayList允许的最大容量，就是Integer的最大值（-2的31次方~2的31次方减1）。<br>4.    新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</p><ol start="5"><li>不是原子操作，，没有任何锁控制，所以这里的操作是线程不安全的，原因主要是elementData[size++] = e可以继续进行拆分<br>private static int hugeCapacity(int minCapacity) {<br> if (minCapacity &lt; 0) // overflow<pre><code> throw new OutOfMemoryError();</code></pre> return (minCapacity &gt; MAX_ARRAY_SIZE) ?<pre><code> Integer.MAX_VALUE : MAX_ARRAY_SIZE;</code></pre>}</li></ol><p>    扩容是通过这行代码来实现的： Arrays.copyOf(elementData, newCapacity); 这行代码描述的 本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据 拷贝过去，我们通过 System.arraycopy 方法进行拷贝<br>/** * @param src 被拷贝的数组 </p><ul><li>@param srcPos 从数组那里开始</li><li>@param dest 目标数组 </li><li>@param destPos 从目标数组那个索引位置开始拷贝 </li><li>@param length 拷贝的长度 </li><li>此方法是没有返回值的，通过 dest 的引用进行传值 */<br>public static native void arraycopy(Object src,  int  srcPos,<pre><code>                              Object dest, int destPos,                              int length);</code></pre></li></ul><h3 id="2-4：remove"><a href="#2-4：remove" class="headerlink" title="2-4：remove"></a>2-4：remove</h3><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理 和思路都差不多，我们选取根据值删除方式来进行源码说明：</p><p>我们需要注意的两点是：</p><p>新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的； 找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我 们关注 equals 的具体实现。</p><p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：<br>public boolean remove(Object o) {<br>    if (o == null) {<br>        for (int index = 0; index &lt; size; index++)<br>            if (elementData[index] == null) {<br>                fastRemove(index);<br>                return true;<br>            }<br>    } else {<br>        for (int index = 0; index &lt; size; index++)<br>            if (o.equals(elementData[index])) {<br>                fastRemove(index);<br>                return true;<br>            }<br>    }<br>    return false;<br>}</p><p>private void fastRemove(int index) {<br>    modCount++;<br>    int numMoved = size - index - 1;<br>    if (numMoved &gt; 0)<br>// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去<br>// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 num<br>        System.arraycopy(elementData, index+1, elementData, index,<br>                         numMoved);<br>// remove方法会让下标到数组末尾的元素向前移动一个单位，<br>并把最后一位的值置空，方便GC<br>    elementData[–size] = null; // clear to let GC do its work</p><p>}</p><h2 id="2-6：ArrayList线程不安全"><a href="#2-6：ArrayList线程不安全" class="headerlink" title="2-6：ArrayList线程不安全"></a>2-6：ArrayList线程不安全</h2><p>只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。<br>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p><h3 id="2-7：那如何解决ArrayList线程不安全问题呢？"><a href="#2-7：那如何解决ArrayList线程不安全问题呢？" class="headerlink" title="2-7：那如何解决ArrayList线程不安全问题呢？"></a>2-7：那如何解决ArrayList线程不安全问题呢？</h3><ol><li>用Collections.synchronizedList<ul><li>因为Collections.synchronizedList封装后的list，<br> list的所有操作方法都是带synchronized关键字的，<br> 相当于所有操作都会进行加锁，<br> 所以使用它是线程安全的，但是性能大大降低，<br>SynchronizedCollection(Collection<E> c) {<br>this.c = Objects.requireNonNull(c);<br>mutex = this;<br>}</li></ul></li></ol><p>public boolean add(E e) {<br>    synchronized (mutex) {return c.add(e);}<br>}</p><ol start="2"><li>CopyOnWriteArrayList<ul><li>写操作：添加元素时，<pre><code>   不直接往当前容器添加，而是先拷贝一份数组，   在新的数组中添加元素后，   在将原容器的引用指向新的容器。   因为数组时用volatile关键字修饰的，   所以当array重新赋值后，   其他线程可以立即知道（volatile的可见性）</code></pre></li><li>读操作：读取数组时，读老的数组，不需要加锁。</li><li>读写分离：写操作是copy了一份新的数组进行写，<pre><code>     读操作是读老的数组，所以是读写分离。</code></pre>采用了Fail-Fast机制，<br>面对并发的修改时，迭代器很快就会完全失败，<br>而不是冒着在将来某个不确定时间发生任意不确定行为的风险<br>嗯嗯嗯不错不错，学习到了再来看看Linkedlist的源码吧</li></ul></li><li>LINKEDLIST<h2 id="3-1：linkedlist数据结构"><a href="#3-1：linkedlist数据结构" class="headerlink" title="3-1：linkedlist数据结构"></a>3-1：linkedlist数据结构</h2></li></ol><p>LinkedList是List接口的双向链表非同步实现，<br>并允许包括null在内的所有元素。<br>双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如 下：</p><p>first 是双向链表的头节点，它的前一个节点是 null。<br>last 是双向链表的尾节点，它的后一个节点是 null；<br>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；<br>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。<br>双向链表节点对应的类Node的实例，<br>Node中包含成员变量：prev，next，item。<br>prev是该节点的上一个节点，<br>next是该节点的下一个节点，<br>item是该节点所包含的值。</p><p>/**</p><ul><li><p>Returns the (non-null) Node at the specified element index.</p></li><li><p>/<br>Node<E> node(int index) {<br>  // assert isElementIndex(index);</p><p>  if (index &lt; (size &gt;&gt; 1)) {<br>// 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; 1 是 size 除以 2 的意思。</p><pre><code>  Node&lt;E&gt; x = first;</code></pre><p>// 直到 for 循环到 index 的前一个 node 停止</p><pre><code>  for (int i = 0; i &lt; index; i++)      x = x.next;  return x;</code></pre><p>  } else {<br>// 如果 index 处于队列的后半部分，从尾开始找</p><pre><code>  Node&lt;E&gt; x = last;</code></pre><p>// 直到 for 循环到 index 的后一个 node 停止</p><pre><code>  for (int i = size - 1; i &gt; index; i--)      x = x.prev;  return x;</code></pre><p>  }<br>}</p></li></ul><p>从源码中我们可以发现， LinkedList 并没有采用从头循环到尾的做法， 而是采取了简单二分 法， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值 得我们借鉴。</p><h2 id="3-1：linkedlist-add"><a href="#3-1：linkedlist-add" class="headerlink" title="3-1：linkedlist  add"></a>3-1：linkedlist  add</h2><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把 节点的值，前后指向节点都置为 null，帮助 GC 进行回收。<br>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开 始追加，addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：<br>void linkLast(E e) {<br>// 把尾节点数据暂存<br>    final Node<E> l = last;<br>// 新建新的节点，初始化入参含义：<br>// l 是新节点的前一个节点，当前值是尾节点值<br>    final Node<E> newNode = new Node&lt;&gt;(l, e, null);<br>    last = newNode;<br>//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节<br>    if (l == null)<br>        first = newNode;<br>//否则把前尾节点的下一个节点，指向当前尾节点。<br>    else<br>        l.next = newNode;<br>//大小和版本更改<br>    size++;<br>    modCount++;<br>}<br>从头部追加（addFirst）<br>/**</p><ul><li>Links e as first element.</li><li>/<br>private void linkFirst(E e) {<br>  final Node<E> f = first;<br>  final Node<E> newNode = new Node&lt;&gt;(null, e, f);<br>  first = newNode;<br>  if (f == null)<pre><code>  last = newNode;</code></pre>  else<pre><code>  f.prev = newNode;</code></pre>  size++;<br>  modCount++;<br>}</li></ul><h2 id="3-1：linkedlist"><a href="#3-1：linkedlist" class="headerlink" title="3-1：linkedlist"></a>3-1：linkedlist</h2><p>private E unlinkLast(Node<E> l) {<br>    // assert l == last &amp;&amp; l != null;<br>    final E element = l.item;<br>    final Node<E> prev = l.prev;<br>    l.item = null;<br>    l.prev = null; // help GC<br>    last = prev;<br>    if (prev == null)<br>        first = null;<br>    else<br>        prev.next = null;<br>    size–;<br>    modCount++;<br>    return element;<br>}</p><p>private E unlinkFirst(Node<E> f) {<br>    // assert f == first &amp;&amp; f != null;<br>    final E element = f.item;<br>    final Node<E> next = f.next;<br>    f.item = null;<br>    f.next = null; // help GC<br>    first = next;<br>    if (next == null)<br>        last = null;<br>    else<br>        next.prev = null;<br>    size–;<br>    modCount++;<br>    return element;<br>}</p><p>List 源码会问哪些面试题<br>   手画一个小心心<br>源码扩容过程有什么值得借鉴的地方？<br>答：有两点：<br>    是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封 装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时， 也可快速扩容。<br>    扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</p><p>这两点在我们平时设计和写代码时都可以借鉴。</p><p>ArrayList 和 LinkedList 两者有没有最大容量</p><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存 空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用 的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p><h2 id="：vector、Arraylist区别和适用场景"><a href="#：vector、Arraylist区别和适用场景" class="headerlink" title="：vector、Arraylist区别和适用场景"></a>：vector、Arraylist区别和适用场景</h2><ol><li><p>线程：Vector是多线程安全的， Vector类中的方法很多有synchronized进行修饰，</p><pre><code>  只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是 方法内的局部变量时，是没有线程安全的问题的。  ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。  这样就导致了Vector在效率上无法与ArrayList相比</code></pre></li><li><p>底层：两个都是数组实现，支持快速随机访问，其 API 都做了一层对数组底层访问的封装</p></li><li><p>初始化：Vector无参构造器初始化时就生成了容量为10的空数组，ArrayList 无参构造器初始化时，默认大小是空数组，10 是在第一次 add 的时候扩容的数组值。</p><pre><code>  Vector可以设置增长因子CapacityIncrement，而ArrayList不可以</code></pre></li><li><p>扩容机制：<br>Vector在每次add增加元素(可能是1个，也可能是一组)时，都要调用ensureCapacityHelper方法来确保足够的容量，当容量不足以容纳当前的元素个数时，即minCapacity（指的是当前元素数目elementCount + 1） - elementData.length &gt; 0，就会grow(minCapacity)扩容，就看构造方法中传入的容量增长系数CapacityIncrement是否为0，</p><pre><code>  如果不为0，就设置新的容量为 旧容量 + 容量增长量；  如果为0，设置新的容量为旧的容量的2倍，  如果设置后的容量还不够，则直接新的容量设置为  传入参数所需要的容量 </code></pre><p>ArrayList在每次add增加元素(可能是1个，也可能是一组)时，都要调用nsureCapacityInternal方法来确保足够的容量,如果我们期望的最小容量大于目前数组的长度，那么就扩容.</p><ol><li>ArrayList第一次add元素时，扩容为长度为10的数组。<br>当前数组是由默认构造方法生成的空数组并且第一次添加数据。<br>此时minCapacity等于默认的容量（10）<br>那么根据下面逻辑可以看到最后数组的容量会从0扩容成10。<br>而后的数组扩容才是按照当前容量的1.5倍进行扩容；<br>arraylist、linkedlist区别和适用场景</li></ol></li><li><p>是否保证线程安全： ArrayList在单线程下是线程安全的，</p><pre><code>             多线程下由于多个线程不断抢夺资源，             所以会出现不安全             和 LinkedList 都是不同步的，也就是不保证线程安全；</code></pre></li><li><p>底层数据结构： Arraylist 底层使用的是 Object 数组；</p><pre><code>          LinkedList 底层使用的是 双向链表 数据结构</code></pre></li><li><p>插入和删除是否受元素位置的影响：<br>① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。<br>② LinkedList 采用链表存储，插入删除元素时间复杂度不受元素位置的影响，</p><pre><code>         如果是要在指定位置i插入和删除元素的话需要先移动到指定位置再插入。</code></pre></li><li><p>是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，<br>LinkedList 并没有采用从头循环到尾的做法， 而是采取了简单二分 法， 首先看看 index 是在链表的前半部分， 还是后半部分。 如果是前半部分， 就从头开始寻 找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值 得我们借鉴。</p><pre><code>                 而 ArrayList 支持。                 快速随机访问就是通过                 元素的序号快速获取元素对象(对应于get(int index) 方法)。</code></pre></li><li><p>内存空间占用： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，</p><pre><code>          而LinkedList的空间花费则体现在          它的每一个元素都需要消耗比ArrayList更多的空间</code></pre><p>双向链表节点对应的类Node的实例，<br>Node中包含成员变量：prev，next，item。<br>prev是该节点的上一个节点，<br>next是该节点的下一个节点，<br>item是该节点所包含的值。</p><pre><code>          （因为要存放直接后继和直接前驱以及数据）</code></pre><p>当需要对数据进行对此访问的情况下选用ArrayList，<br>当需要对数据进行多次增加删除修改时采用LinkedList。<br>•    ArrayList与LinkedList集合各有所长，可以在不同场合根据具体需求选用:<br>–    ArrayList元素的检索速度高于LinkedList<br>–    LinkedList因为内存的不连续性，更适合于大批量数据的存放和管理<br>–    如果在非末端插入数据，LinkedList速度优于ArrayList</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="2020/11/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/11/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="你好～"><a href="#你好～" class="headerlink" title="你好～"></a>你好～</h2><p>我的第一篇博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/17/hello-world/"/>
      <url>2020/11/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
